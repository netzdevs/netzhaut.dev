<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.9.2"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Netzhaut | Web Browser Engine | General</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="resize.js"></script>
    <script type="text/javascript" src="navtreedata.js"></script>
    <script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/searchdata.js"></script>
    <script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript">
    /* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
      $(document).ready(function() { init_search(); });
    /* @license-end */
    </script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link rel="icon" href="../../logo/favicon.png">
    <link href="../../theme/custom.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>  
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
       <div style="height: 56px;">
        <div style="left:10px;top:5px;position:absolute;">
          <b>Netzhaut</b>
          <br>
          <b>Web Browser Engine</b>
        </div>
        <div style="height:56px;right:10px;top:0px;position:absolute;background-color:#151515;"><a href="https://netzwerkz.org"><img alt="netzwerkz logo" style="height:56px;" src="../../logo/netzwerkz.png"/></a></div>
        <div id="projectlogo"><img alt="netzhaut logo" src="../../logo/netzhaut.png"/></div>
       </div>
      </div>
      <div id="titlearea">
        <div class="topnav">
          <a href="../../index.html">Home</a>
          <a href="../../guides/html/index.html">Guides</a>
          <a class="active" href="../../general/html/index.html">General</a>
          <a href="../../architecture/html/index.html">Architecture</a>
          <a href="../../design/html/index.html">Design</a>
          <a href="../../internals/html/index.html">Internals</a>
          <a href="../../api/html/index.html">API</a>
        </div>
       </div>
      </div>
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__selfmakeFunctions.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Functions<div class="ingroups"><a class="el" href="group__selfmake.html">selfmake internal</a></div></div></div>
</div><!--header-->
<div class="contents">
<ul>
<li><p class="startli">* +/**</p>
<p class="startli">*/</p>
</li>
<li>-#endif diff &ndash;git a/external/selfmake/src/bin/smmake/Main.c b/external/selfmake/src/bin/smmake/Main.c deleted file mode 100644 index 07010e2..0000000 &mdash; a/external/selfmake/src/bin/smmake/Main.c +++ /dev/null @ -1,85 +0,0 @ -// LICENSE NOTICE ==================================================================================</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-// INCLUDE =========================================================================================</li>
<li>-#include "Version.h" -#include "Documents.h"</li>
<li>-#include "../../../include/selfmake/selfmake.h"</li>
<li>-#include &lt;stdio.h&gt; -#include &lt;string.h&gt; -#include &lt;stdlib.h&gt; -#include &lt;ctype.h&gt;</li>
<li>-// MAIN ============================================================================================</li>
<li>-static SM_RESULT sourceContextCallback(</li>
<li>sm_Runtime *Runtime_p, sm_SourceContext *SourceContext_p) -{</li>
<li>if (!strcmp(SourceContext_p-&gt;name_p, "selfmake"))</li>
<li>{</li>
<li>int versionNums_p[4];</li>
<li>long versionDates_pp[4][3];</li>
<li>getVersionData(versionNums_p, versionDates_pp);</li>
<li>SourceContext_p-&gt;api = versionNums_p[0];</li>
<li>SourceContext_p-&gt;major = versionNums_p[1];</li>
<li>SourceContext_p-&gt;minor = versionNums_p[2];</li>
<li>SourceContext_p-&gt;patch = versionNums_p[3];</li>
<li>}</li>
<li></li>
<li>return SM_SUCCESS; -}</li>
<li>-static SM_RESULT functionCallback(</li>
<li>sm_Runtime *Runtime_p, sm_Function *Function_p) -{</li>
<li>if (!strcmp(Function_p-&gt;name_p, "generateFooter")) {</li>
<li>generateFooter(Runtime_p);</li>
<li>}</li>
<li>else if (!strcmp(Function_p-&gt;name_p, "generateHomepage")) {</li>
<li>generateHomepage(Runtime_p);</li>
<li>}</li>
<li></li>
<li>return SM_SUCCESS; -}</li>
<li>-int main(</li>
<li>int argc, char <b>argv_pp) -{</b></li>
<li><b> sm_initialize();</b></li>
<li><b></b></li>
<li><b> sm_Runtime *Runtime_p = sm_createRuntime("smmake");</b></li>
<li><b> if (!Runtime_p) {return 1;}</b></li>
<li><b></b></li>
<li><b> SM_BYTE *wrkDir_p = malloc(255);</b></li>
<li><b> if (!wrkDir_p) {return 1;}</b></li>
<li><b> SM_BYTE *version_p = malloc(255);</b></li>
<li><b> if (!version_p) {return 1;}</b></li>
<li><b></b></li>
<li><b> sprintf(wrkDir_p, "%s/..", sm_getProcessDirectory());</b></li>
<li><b> getProjectVersion(Runtime_p, version_p);</b></li>
<li><b></b></li>
<li><b> sm_setVariable(Runtime_p, "PROJ_REV", &amp;version_p, 1);</b></li>
<li><b> sm_setVariable(Runtime_p, "WRK_DIR", &amp;wrkDir_p, 1);</b></li>
<li><b></b></li>
<li><b> sm_addFile(Runtime_p, "build/.sm/smmake.sm");</b></li>
<li><b> sm_setFunctionCallback(Runtime_p, functionCallback);</b></li>
<li><b> sm_setSourceContextCallback(Runtime_p, sourceContextCallback);</b></li>
<li><b></b></li>
<li><b> if (sm_run(Runtime_p, argc - 1, argv_pp + 1)) {return 1;}</b></li>
<li><b></b></li>
<li><b> while (sm_isRunning()) {sm_sleepMs(100);}</b></li>
<li><b></b></li>
<li><b> sm_destroyRuntime(Runtime_p);</b></li>
<li><b> sm_terminate();</b></li>
<li><b></b></li>
<li><b> return 0; -}</b></li>
<li><b>diff &ndash;git a/external/selfmake/src/bin/smmake/Version.c b/external/selfmake/src/bin/smmake/Version.c deleted file mode 100644 index 047e85d..0000000 &mdash; a/external/selfmake/src/bin/smmake/Version.c +++ /dev/null @ -1,112 +0,0 @ -// LICENSE NOTICE ==================================================================================</b></li>
<li><b>-/</b></li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-// INCLUDE =========================================================================================</li>
<li>-#include "Version.h"</li>
<li>-#include &lt;stdio.h&gt; -#include &lt;string.h&gt; -#include &lt;stdlib.h&gt; -#include &lt;ctype.h&gt;</li>
<li>-// VERSION =========================================================================================</li>
<li>-static long getVersion(</li>
<li>SM_BYTE *data_p, SM_BYTE *macro_p) -{</li>
<li>SM_BYTE *p = strstr(data_p, macro_p);</li>
<li>if (!p) {return 0;}</li>
<li>p += strlen(macro_p);</li>
<li>long val = strtol(p, &amp;p, 10);</li>
<li></li>
<li>return val; -}</li>
<li>-static void getVersionDate(</li>
<li>SM_BYTE *data_p, SM_BYTE *macro_p, long date_p[3]) -{</li>
<li>date_p[0] = 0;</li>
<li>date_p[1] = 0;</li>
<li>date_p[2] = 0;</li>
<li></li>
<li>SM_BYTE *p = strstr(data_p, macro_p);</li>
<li>if (!p) {return;}</li>
<li></li>
<li>while (p[0] != '/' || p[1] != '' || p[2] != '*') {p&ndash;;}</li>
<li>while (*p &amp;&amp; !isdigit(*p++)) {}</li>
<li>if (!*p) {return;}</li>
<li></li>
<li>p&ndash;;</li>
<li></li>
<li>date_p[0] = strtol(p, &amp;p, 10);</li>
<li>p++;</li>
<li>date_p[1] = strtol(p, &amp;p, 10);</li>
<li>p++;</li>
<li>date_p[2] = strtol(p, &amp;p, 10);</li>
<li>p++; -}</li>
<li>-SM_RESULT getVersionData(</li>
<li>int version_p[4], long versionDates_pp[4][3]) -{</li>
<li>SM_BYTE *api_p = "SM_API_VERSION";</li>
<li>SM_BYTE *major_p = "SM_MAJOR_VERSION";</li>
<li>SM_BYTE *minor_p = "SM_MINOR_VERSION";</li>
<li>SM_BYTE *patch_p = "SM_PATCH_VERSION";</li>
<li></li>
<li>SM_BYTE path_p[512];</li>
<li>sprintf(path_p, "src/lib/Common/About.h");</li>
<li></li>
<li>SM_BYTE *data_p = sm_getFileData(path_p, NULL);</li>
<li>if (!data_p) {return SM_ERROR_BAD_STATE;}</li>
<li></li>
<li>version_p[0] = getVersion(data_p, api_p);</li>
<li>version_p[1] = getVersion(data_p, major_p);</li>
<li>version_p[2] = getVersion(data_p, minor_p);</li>
<li>version_p[3] = getVersion(data_p, patch_p);</li>
<li></li>
<li>getVersionDate(data_p, api_p, versionDates_pp[0]);</li>
<li>getVersionDate(data_p, major_p, versionDates_pp[1]);</li>
<li>getVersionDate(data_p, minor_p, versionDates_pp[2]);</li>
<li>getVersionDate(data_p, patch_p, versionDates_pp[3]);</li>
<li></li>
<li>free(data_p);</li>
<li></li>
<li>return SM_SUCCESS; -}</li>
<li>-void getProjectVersion(</li>
<li>sm_Runtime *Runtime_p, SM_BYTE *version_p) -{</li>
<li>sm_ValueArray Stage = sm_getVariableValues(Runtime_p, "PROJ_STAGE");</li>
<li></li>
<li>int versionNums_p[4];</li>
<li>long versionDates_pp[4][3];</li>
<li>getVersionData(versionNums_p, versionDates_pp);</li>
<li></li>
<li>sm_ValueArray LangVer = sm_getVariableValues(Runtime_p, "LANG_VER");</li>
<li></li>
<li>if (LangVer.length &amp;&amp; Stage.length) {</li>
<li>sprintf(version_p, "v%d.%d.%d.%d-%s %s", versionNums_p[0], versionNums_p[1], versionNums_p[2],</li>
<li>versionNums_p[3], LangVer.values_pp[0], Stage.values_pp[0]);</li>
<li>}</li>
<li>else if (LangVer.length) {</li>
<li>sprintf(version_p, "v%d.%d.%d.%d-%s", versionNums_p[0], versionNums_p[1], versionNums_p[2],</li>
<li>versionNums_p[3], LangVer.values_pp[0]);</li>
<li>}</li>
<li>else if (Stage.length) {</li>
<li>sprintf(version_p, "v%d.%d.%d.%d %s", versionNums_p[0], versionNums_p[1], versionNums_p[2],</li>
<li>versionNums_p[3], Stage.values_pp[0]);</li>
<li>}</li>
<li>else {</li>
<li>sprintf(version_p, "v%d.%d.%d.%d", versionNums_p[0], versionNums_p[1], versionNums_p[2],</li>
<li>versionNums_p[3]);</li>
<li>} -}</li>
<li>diff &ndash;git a/external/selfmake/src/bin/smmake/Version.h b/external/selfmake/src/bin/smmake/Version.h deleted file mode 100644 index d1743bd..0000000 &mdash; a/external/selfmake/src/bin/smmake/Version.h +++ /dev/null @ -1,30 +0,0 @ -#ifndef VERSION_H -#define VERSION_H</li>
<li>-#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-#include "../../../include/selfmake/selfmake.h"</li>
<li>-#endif</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>SM_RESULT getVersionData(</li>
<li>int version_p[3], long versionDates_pp[3][3]</li>
<li>);</li>
<li></li>
<li>void getProjectVersion(</li>
<li>sm_Runtime *Runtime_p, SM_BYTE *version_p</li>
<li>);</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
<li>-#endif diff --git a/external/selfmake/src/lib/Core/Binaries.c b/external/selfmake/src/lib/Core/Binaries.c deleted file mode 100644 index b327a73..0000000 --- a/external/selfmake/src/lib/Core/Binaries.c +++ /dev/null @ -1,151 +0,0 @ -// LICENSE NOTICE ==================================================================================</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-// INCLUDE =========================================================================================</li>
<li>-#include "Binaries.h" -#include "Util.h" -#include "Main.h"</li>
<li>-#include "../Common/Macro.h"</li>
<li>-#include SM_FLOW -#include SM_CUSTOM_CHECK</li>
<li>-#include &lt;stdio.h&gt; -#include &lt;stdlib.h&gt; -#include &lt;string.h&gt; -#include &lt;unistd.h&gt;</li>
<li>-// BUILD BINARY ====================================================================================</li>
<li>-SM_RESULT sm_buildnhterminal() -{ -SM_BEGIN()</li>
<li></li>
<li>char projDir_p[2048] = {'\0'};</li>
<li>SM_CHECK(SM_ERROR_GET_PROJECT_DIRECTORY, sm_getProjectDir(projDir_p, 2048))</li>
<li></li>
<li>// set -no-pie because of <a href="https://stackoverflow.com/questions/41398444/gcc-creates-mime-type-application-x-sharedlib-instead-of-application-x-applicati">https://stackoverflow.com/questions/41398444/gcc-creates-mime-type-application-x-sharedlib-instead-of-application-x-applicati</a></li>
<li>static char command_p[2048] = {'\0'};</li>
<li>sprintf(command_p, "gcc -std=gnu99 -Wl,-rpath=%s/lib:/usr/local/lib -o%s/bin/nhterminal -no-pie -L%s/lib -lnetzhaut %s/src/bin/nhterminal/Terminal.c", projDir_p, projDir_p, projDir_p, projDir_p);</li>
<li></li>
<li>int status = system(command_p);</li>
<li>if (WEXITSTATUS(status) || WIFSIGNALED(status)) {SM_DIAGNOSTIC_END(SM_ERROR_GCC_EXECUTION_FAILED)}</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-SM_RESULT sm_buildnhwebbrowser() -{ -SM_BEGIN()</li>
<li></li>
<li>char projDir_p[2048] = {'\0'};</li>
<li>SM_CHECK(SM_ERROR_GET_PROJECT_DIRECTORY, sm_getProjectDir(projDir_p, 2048))</li>
<li></li>
<li>// set -no-pie because of <a href="https://stackoverflow.com/questions/41398444/gcc-creates-mime-type-application-x-sharedlib-instead-of-application-x-applicati">https://stackoverflow.com/questions/41398444/gcc-creates-mime-type-application-x-sharedlib-instead-of-application-x-applicati</a></li>
<li>static char command_p[2048] = {'\0'};</li>
<li>sprintf(command_p, "gcc -std=gnu99 -Wl,-rpath=%s/lib:/usr/local/lib -o%s/bin/nhwebbrowser -no-pie -L%s/lib -lnetzhaut %s/src/bin/nhwebbrowser/WebBrowser.c", projDir_p, projDir_p, projDir_p, projDir_p);</li>
<li></li>
<li>int status = system(command_p);</li>
<li>if (WEXITSTATUS(status) || WIFSIGNALED(status)) {SM_DIAGNOSTIC_END(SM_ERROR_GCC_EXECUTION_FAILED)}</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-// INSTALL BINARY ==================================================================================</li>
<li>-SM_RESULT sm_installnhterminal() -{ -SM_BEGIN()</li>
<li></li>
<li>char wrkDir_p[2048] = {'\0'};</li>
<li>SM_CHECK_NULL(SM_ERROR_GET_WORK_DIRECTORY, getcwd(wrkDir_p, 2048))</li>
<li></li>
<li>char projDir_p[2048] = {'\0'};</li>
<li>SM_CHECK(SM_ERROR_GET_PROJECT_DIRECTORY, sm_getProjectDir(projDir_p, 2048))</li>
<li></li>
<li>chdir(projDir_p);</li>
<li></li>
<li>const char *homedir_p = sm_getHomeDir();</li>
<li>char dest_p[512] = {'\0'};</li>
<li></li>
<li>sprintf(dest_p, "%s/.local/share/applications/", homedir_p);</li>
<li>SM_CHECK(SM_ERROR_COPY_FAILED, sm_copy("src/bin/nhterminal/Common/Data/nhterminal.desktop", dest_p, SM_FALSE, SM_FALSE))</li>
<li>SM_CHECK(SM_ERROR_COPY_FAILED, sm_copy("bin/nhterminal", "/usr/local/bin", SM_FALSE, SM_TRUE))</li>
<li></li>
<li>chdir(wrkDir_p);</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-SM_RESULT sm_installnhwebbrowser() -{ -SM_BEGIN()</li>
<li></li>
<li>char wrkDir_p[2048] = {'\0'};</li>
<li>SM_CHECK_NULL(SM_ERROR_GET_WORK_DIRECTORY, getcwd(wrkDir_p, 2048))</li>
<li></li>
<li>char projDir_p[2048] = {'\0'};</li>
<li>SM_CHECK(SM_ERROR_GET_PROJECT_DIRECTORY, sm_getProjectDir(projDir_p, 2048))</li>
<li></li>
<li>chdir(projDir_p);</li>
<li></li>
<li>const char *homedir_p = sm_getHomeDir();</li>
<li>char dest_p[512] = {'\0'};</li>
<li></li>
<li>sprintf(dest_p, "%s/.local/share/applications/", homedir_p);</li>
<li>SM_CHECK(SM_ERROR_COPY_FAILED, sm_copy("src/bin/nhwebbrowser/Common/Data/nhwebbrowser.desktop", dest_p, SM_FALSE, SM_FALSE))</li>
<li>SM_CHECK(SM_ERROR_COPY_FAILED, sm_copy("bin/nhwebbrowser", "/usr/local/bin", SM_FALSE, SM_TRUE))</li>
<li></li>
<li>chdir(wrkDir_p);</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-// INSTALL LOGO ====================================================================================</li>
<li>-SM_RESULT sm_installLogo() -{ -SM_BEGIN()</li>
<li></li>
<li>char wrkDir_p[2048] = {'\0'};</li>
<li>SM_CHECK_NULL(SM_ERROR_GET_WORK_DIRECTORY, getcwd(wrkDir_p, 2048))</li>
<li></li>
<li>char projDir_p[2048] = {'\0'};</li>
<li>SM_CHECK(SM_ERROR_GET_PROJECT_DIRECTORY, sm_getProjectDir(projDir_p, 2048))</li>
<li></li>
<li>chdir(projDir_p);</li>
<li></li>
<li>const char *homedir_p = sm_getHomeDir();</li>
<li>char dest_p[512] = {'\0'};</li>
<li></li>
<li>sprintf(dest_p, "%s/.local/share/icons/hicolor/32x32/apps", homedir_p);</li>
<li>SM_CHECK(SM_ERROR_COPY_FAILED, sm_copy("docs/Logo/32x32/netzhaut.png", dest_p, SM_FALSE, SM_TRUE))</li>
<li></li>
<li>memset(dest_p, '\0', sizeof(char) * 512);</li>
<li>sprintf(dest_p, "%s/.local/share/icons/hicolor/64x64/apps", homedir_p);</li>
<li>SM_CHECK(SM_ERROR_COPY_FAILED, sm_copy("docs/Logo/64x64/netzhaut.png", dest_p, SM_FALSE, SM_TRUE))</li>
<li></li>
<li>memset(dest_p, '\0', sizeof(char) * 512);</li>
<li>sprintf(dest_p, "%s/.local/share/icons/hicolor/128x128/apps", homedir_p);</li>
<li>SM_CHECK(SM_ERROR_COPY_FAILED, sm_copy("docs/Logo/128x128/netzhaut.png", dest_p, SM_FALSE, SM_TRUE))</li>
<li></li>
<li>memset(dest_p, '\0', sizeof(char) * 512);</li>
<li>sprintf(dest_p, "%s/.local/share/icons/hicolor/256x256/apps", homedir_p);</li>
<li>SM_CHECK(SM_ERROR_COPY_FAILED, sm_copy("docs/Logo/256x256/netzhaut.png", dest_p, SM_FALSE, SM_TRUE))</li>
<li></li>
<li>memset(dest_p, '\0', sizeof(char) * 512);</li>
<li>sprintf(dest_p, "%s/.local/share/icons/hicolor/512x512/apps", homedir_p);</li>
<li>SM_CHECK(SM_ERROR_COPY_FAILED, sm_copy("docs/Logo/512x512/netzhaut.png", dest_p, SM_FALSE, SM_TRUE))</li>
<li></li>
<li>chdir(wrkDir_p);</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>diff &ndash;git a/external/selfmake/src/lib/Core/Build.c b/external/selfmake/src/lib/Core/Build.c deleted file mode 100644 index 079b940..0000000 &mdash; a/external/selfmake/src/lib/Core/Build.c +++ /dev/null @ -1,345 +0,0 @ -// LICENSE NOTICE ==================================================================================</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-// INCLUDE =========================================================================================</li>
<li>-#include "Build.h" -#include "Utils.h"</li>
<li>-#include "../UI/Message.h" -#include "../Common/Macros/Macros.h"</li>
<li>-#include SM_FLOW -#include SM_DEFAULT_CHECK</li>
<li>-#include &lt;stdio.h&gt; -#include &lt;stdlib.h&gt; -#include &lt;string.h&gt; -#include &lt;unistd.h&gt; -#include &lt;pthread.h&gt; -#include &lt;dirent.h&gt; -#include &lt;errno.h&gt;</li>
<li>-// CREATE BINARY ===================================================================================</li>
<li>-static SM_RESULT sm_createBinary(</li>
<li>sm_Runtime *Runtime_p, sm_SourceContext *SourceContext_p) -{ -SM_BEGIN()</li>
<li></li>
<li>chdir(SourceContext_p-&gt;path_p);</li>
<li></li>
<li>SM_BYTE binPath_p[256] = {'\0'};</li>
<li>sprintf(binPath_p, "%s/%s", sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "BIN_DEST")-&gt;values_pp[0], SourceContext_p-&gt;name_p);</li>
<li>if (SourceContext_p-&gt;outputPath_p) {</li>
<li>sprintf(binPath_p, "%s/%s", SourceContext_p-&gt;outputPath_p, SourceContext_p-&gt;name_p);</li>
<li>}</li>
<li></li>
<li>int length = 0;</li>
<li>for (int i = 0; i &lt; Runtime_p-&gt;SourceArray.length; ++i) {</li>
<li>sm_Source *Source_p = &amp;Runtime_p-&gt;SourceArray.Sources_p[i];</li>
<li>if (Source_p-&gt;Context_p == SourceContext_p) {</li>
<li>length += strlen(Source_p-&gt;path_p) + 1;</li>
<li>}</li>
<li>}</li>
<li><br  />
</li>
<li>SM_BYTE *sources_p = malloc(length + 1);</li>
<li>SM_CHECK_NULL(sources_p)</li>
<li>memset(sources_p, 0, length + 1);</li>
<li></li>
<li>int offset = 0;</li>
<li>for (int i = 0; i &lt; Runtime_p-&gt;SourceArray.length; ++i) {</li>
<li>sm_Source *Source_p = &amp;Runtime_p-&gt;SourceArray.Sources_p[i];</li>
<li>if (Source_p-&gt;Context_p == SourceContext_p) {</li>
<li>sprintf(sources_p + strlen(sources_p), "%s ", Source_p-&gt;path_p);</li>
<li>}</li>
<li>}</li>
<li></li>
<li>int compileArgsLength = SourceContext_p-&gt;compileArgs_p ? strlen(SourceContext_p-&gt;compileArgs_p) : 0;</li>
<li>int linkArgsLength = SourceContext_p-&gt;linkArgs_p ? strlen(SourceContext_p-&gt;linkArgs_p) : 0;</li>
<li>int commandLength = strlen(sources_p) + compileArgsLength + linkArgsLength + strlen(binPath_p) + 128;</li>
<li>SM_BYTE *command_p = malloc(commandLength);</li>
<li>SM_CHECK_NULL(command_p)</li>
<li>memset(command_p, 0, commandLength);</li>
<li></li>
<li>SM_BYTE empty = 0;</li>
<li>SM_BYTE *linkArgs_p = SourceContext_p-&gt;linkArgs_p ? SourceContext_p-&gt;linkArgs_p : &empty;</li>
<li>SM_BYTE *compileArgs_p = SourceContext_p-&gt;compileArgs_p ? SourceContext_p-&gt;compileArgs_p : &empty;</li>
<li></li>
<li>// set -no-pie because of <a href="https://stackoverflow.com/questions/41398444/gcc-creates-mime-type-application-x-sharedlib-instead-of-application-x-applicati">https://stackoverflow.com/questions/41398444/gcc-creates-mime-type-application-x-sharedlib-instead-of-application-x-applicati</a></li>
<li>sprintf(command_p, "gcc %s -o%s -no-pie %s %s", compileArgs_p, binPath_p, linkArgs_p, sources_p);</li>
<li>sm_messagef(command_p);</li>
<li></li>
<li>int status = system(command_p);</li>
<li>if (WEXITSTATUS(status) || WIFSIGNALED(status)) {SM_DIAGNOSTIC_END(SM_ERROR_GCC_EXECUTION_FAILED)}</li>
<li></li>
<li>chdir(sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "WRK_DIR")-&gt;values_pp[0]);</li>
<li></li>
<li>free(command_p);</li>
<li>free(sources_p);</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-// CREATE LIBRARY ==================================================================================</li>
<li>-static SM_RESULT sm_createSharedLibraryUsingGCC(</li>
<li>const SM_BYTE *objects_p, const SM_BYTE *out_p, SM_BYTE *compile_p, const SM_BYTE *link_p) -{ -SM_BEGIN()</li>
<li></li>
<li>static SM_BYTE command_p[16384] = {'\0'};</li>
<li></li>
<li>sprintf(command_p, "gcc -shared %s %s %s -o %s", objects_p, compile_p, link_p, out_p);</li>
<li>sm_messagef(command_p);</li>
<li></li>
<li>int status = system(command_p);</li>
<li>if (WEXITSTATUS(status) || WIFSIGNALED(status)) {SM_DIAGNOSTIC_END(SM_ERROR_GCC_EXECUTION_FAILED)}</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-static SM_RESULT sm_createLibrary(</li>
<li>sm_Runtime *Runtime_p, sm_SourceContext *Context_p) -{ -SM_BEGIN()</li>
<li></li>
<li>SM_BYTE empty = 0;</li>
<li>SM_BYTE *libName_p = Context_p-&gt;name_p;</li>
<li>SM_BYTE *linkArgs_p = Context_p-&gt;linkArgs_p ? Context_p-&gt;linkArgs_p : &empty;</li>
<li>SM_BYTE *compileArgs_p = Context_p-&gt;compileArgs_p ? Context_p-&gt;compileArgs_p : &empty;</li>
<li></li>
<li>int api = Context_p-&gt;api;</li>
<li>int major = Context_p-&gt;major;</li>
<li>int minor = Context_p-&gt;minor;</li>
<li>int patch = Context_p-&gt;patch;</li>
<li></li>
<li>SM_BYTE tmp_p[255] = {0};</li>
<li>sprintf(tmp_p, "/tmp/%s", sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "NAME")-&gt;values_pp[0]);</li>
<li>chdir(tmp_p);</li>
<li>-#if defined(<b>linux</b>) || defined(<b>APPLE</b>)</li>
<li></li>
<li>int index = 0;</li>
<li>SM_BYTE objects_p[16384] = {'\0'};</li>
<li></li>
<li>DIR *dir;</li>
<li>struct dirent *ent;</li>
<li><br  />
</li>
<li>if ((dir = opendir(tmp_p)) != NULL)</li>
<li>{</li>
<li>while ((ent = readdir(dir)) != NULL) {</li>
<li>for (int i = 0; ent-&gt;d_name[i] != '\0' &amp;&amp; ent-&gt;d_name[0] != '.'; ++i) {</li>
<li>objects_p[index++] = ent-&gt;d_name[i];</li>
<li>}</li>
<li>objects_p[index++] = ' ';</li>
<li>}</li>
<li>closedir(dir);</li>
<li>}</li>
<li>else {SM_DIAGNOSTIC_END(SM_ERROR_CANT_OPEN_DIR)}</li>
<li></li>
<li>SM_BYTE *dest_p = sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "LIB_DEST")-&gt;values_pp[0];</li>
<li>if (Context_p-&gt;outputPath_p) {dest_p = Context_p-&gt;outputPath_p;}</li>
<li></li>
<li>SM_BYTE libPath_p[256] = {'\0'};</li>
<li>sprintf(libPath_p, "%s/lib%s.so.%d.%d.%d.%d", dest_p, libName_p, api, major, minor, patch);</li>
<li>SM_BYTE symPath1_p[256] = {'\0'};</li>
<li>sprintf(symPath1_p, "%s/lib%s.so.%d", dest_p, libName_p, api);</li>
<li>SM_BYTE symPath2_p[256] = {'\0'};</li>
<li>sprintf(symPath2_p, "%s/lib%s.so", dest_p, libName_p);</li>
<li><br  />
</li>
<li>SM_CHECK(sm_createSharedLibraryUsingGCC(objects_p, libPath_p, compileArgs_p, linkArgs_p))</li>
<li></li>
<li>memset(libPath_p, 0, 256);</li>
<li>sprintf(libPath_p, "lib%s.so.%d.%d.%d.%d", libName_p, api, major, minor, patch);</li>
<li>sm_createSymLink(libPath_p, symPath1_p, SM_FALSE);</li>
<li>sm_createSymLink(libPath_p, symPath2_p, SM_FALSE);</li>
<li>-#endif</li>
<li></li>
<li>chdir(sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "WRK_DIR")-&gt;values_pp[0]);</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-// COMPILE =========================================================================================</li>
<li>-static void sm_getObjectFileName(</li>
<li>sm_Source *Source_p, SM_BYTE *name_p) -{ -SM_BEGIN()</li>
<li></li>
<li>SM_BYTE path_p[255] = {0};</li>
<li>strcpy(path_p, Source_p-&gt;path_p);</li>
<li></li>
<li>int index = strlen(path_p) - 1;</li>
<li>while (path_p[index] != '/' &amp;&amp; index) {index&ndash;;}</li>
<li></li>
<li>SM_BYTE fileName_p[255] = {0};</li>
<li>strcpy(fileName_p, index ? path_p + index + 1 : path_p);</li>
<li></li>
<li>int tmp = index ? index - 1 : 0;</li>
<li>while (path_p[tmp] != '/' &amp;&amp; tmp) {tmp&ndash;;}</li>
<li></li>
<li>if (index) {</li>
<li>path_p[index] = '\0';</li>
<li>sprintf(name_p, "%s%s.o", path_p + tmp, fileName_p);</li>
<li>}</li>
<li>else {</li>
<li>sprintf(name_p, "%s.o", fileName_p);</li>
<li>}</li>
<li>-SM_SILENT_END() -}</li>
<li>-static SM_RESULT sm_createPICObjectFileUsingGCC(</li>
<li>const SM_BYTE *in_p, const SM_BYTE *out_p, SM_BYTE *compileArgs_p) -{ -SM_BEGIN()</li>
<li></li>
<li>SM_BYTE realout_p[1024] = {'\0'};</li>
<li>realpath(out_p, realout_p);</li>
<li></li>
<li>SM_BYTE command_p[1024] = {'\0'};</li>
<li></li>
<li>if (compileArgs_p != NULL) {sprintf(command_p, "gcc -fPIC %s -c %s -o %s", compileArgs_p, in_p, out_p);}</li>
<li>else {sprintf(command_p, "gcc -fPIC -c %s -o %s", in_p, out_p);}</li>
<li></li>
<li>sm_messagef(command_p);</li>
<li></li>
<li>int status = system(command_p);</li>
<li>if (WEXITSTATUS(status) || WIFSIGNALED(status)) {SM_DIAGNOSTIC_END(SM_ERROR_GCC_EXECUTION_FAILED)}</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-static SM_RESULT sm_compileFiles(</li>
<li>sm_Runtime *Runtime_p, sm_SourceContext *Context_p) -{ -SM_BEGIN()</li>
<li></li>
<li>chdir(Context_p-&gt;path_p);</li>
<li></li>
<li>for (int i = 0; i &lt; Runtime_p-&gt;SourceArray.length; ++i)</li>
<li>{</li>
<li>sm_Source *Source_p = &amp;Runtime_p-&gt;SourceArray.Sources_p[i];</li>
<li></li>
<li>if (Source_p-&gt;Context_p == Context_p)</li>
<li>{</li>
<li>SM_BYTE tmp_p[255] = {0};</li>
<li>SM_BYTE fileName_p[255] = {0};</li>
<li>sm_getObjectFileName(Source_p, fileName_p);</li>
<li></li>
<li>sprintf(tmp_p, "/tmp/%s/%s", sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "NAME")-&gt;values_pp[0], fileName_p);</li>
<li>SM_BYTE empty = 0;</li>
<li></li>
<li>if (Context_p-&gt;type == SM_SOURCE_CONTEXT_SHARED_LIBRARY) {</li>
<li>SM_CHECK(sm_createPICObjectFileUsingGCC(</li>
<li>Source_p-&gt;path_p, tmp_p, Context_p-&gt;compileArgs_p ? Context_p-&gt;compileArgs_p : &amp;empty</li>
<li>))</li>
<li>}</li>
<li>}</li>
<li>}</li>
<li></li>
<li>chdir(sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "WRK_DIR")-&gt;values_pp[0]);</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-// INSTALL =========================================================================================</li>
<li>-//static SM_RESULT sm_installLibrary( -// SM_BYTE *libName_p, int major, int minor, int patch) -//{ -//SM_BEGIN() -// -// SM_BYTE wrkDir_p[2048] = {'\0'}; -// SM_CHECK_NULL(SM_ERROR_GET_WORK_DIRECTORY, getcwd(wrkDir_p, 2048)) -// -// SM_BYTE projDir_p[2048] = {'\0'}; -// SM_CHECK(SM_ERROR_GET_PROJECT_DIRECTORY, sm_getProjectDir(projDir_p, 2048)) -// -// chdir(projDir_p); -// -// SM_BYTE libPath_p[512] = {'\0'}; -// sprintf(libPath_p, "lib/lib%s.so.%d.%d.%d", libName_p, major, minor, patch); -// -// SM_CHECK(SM_ERROR_COPY_FAILED, sm_copy(libPath_p, "/usr/local/lib", SM_FALSE, SM_TRUE)) -// -// chdir("/usr/local/lib"); -// -// SM_BYTE cpyPath_p[256] = {'\0'}; -// sprintf(cpyPath_p, "lib%s.so.%d.%d.%d", libName_p, major, minor, patch); -// SM_BYTE symPath1_p[256] = {'\0'}; -// sprintf(symPath1_p, "lib%s.so.%d", libName_p, major); -// SM_BYTE symPath2_p[256] = {'\0'}; -// sprintf(symPath2_p, "lib%s.so", libName_p); -// -// sm_createSymLink(cpyPath_p, symPath1_p, SM_TRUE); -// sm_createSymLink(cpyPath_p, symPath2_p, SM_TRUE); -// -// chdir(wrkDir_p); -// -//SM_DIAGNOSTIC_END(SM_SUCCESS) -//}</li>
<li>-// BUILD ===========================================================================================</li>
<li>-static SM_RESULT sm_buildSourceContext(</li>
<li>sm_Runtime *Runtime_p, sm_SourceContext *Context_p) -{ -SM_BEGIN()</li>
<li></li>
<li>SM_BYTE empty = 0;</li>
<li>SM_BYTE tmp_p[255];</li>
<li>sprintf(tmp_p, "/tmp/%s", sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "NAME")-&gt;values_pp[0]);</li>
<li></li>
<li>SM_CHECK(sm_createDir(tmp_p))</li>
<li></li>
<li>if (Runtime_p-&gt;beforeBuildCallback_f) {</li>
<li>SM_CHECK(Runtime_p-&gt;beforeBuildCallback_f(Runtime_p, Context_p))</li>
<li>}</li>
<li></li>
<li>if (Context_p-&gt;type == SM_SOURCE_CONTEXT_BINARY) {</li>
<li>SM_CHECK(sm_createBinary(Runtime_p, Context_p))</li>
<li>}</li>
<li>else {</li>
<li>SM_CHECK(sm_compileFiles(Runtime_p, Context_p))</li>
<li>SM_CHECK(sm_createLibrary(Runtime_p, Context_p))</li>
<li>}</li>
<li></li>
<li>if (Runtime_p-&gt;afterBuildCallback_f) {</li>
<li>SM_CHECK(Runtime_p-&gt;afterBuildCallback_f(Runtime_p, Context_p))</li>
<li>}</li>
<li>-// if (install) { -// SM_CHECK(SM_ERROR_BAD_STATE, sm_installLibrary( -// Library_p-&gt;name_p, 0, 0, 0 -// )) -// }</li>
<li></li>
<li>SM_CHECK(sm_removeDir(tmp_p))</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-SM_RESULT sm_build(</li>
<li>sm_Runtime *Runtime_p, SM_BYTE *name_p) -{ -SM_BEGIN()</li>
<li></li>
<li>for (int i = 0; i &lt; Runtime_p-&gt;SourceContextArray.length; ++i) {</li>
<li>sm_SourceContext *SourceContext_p = &amp;Runtime_p-&gt;SourceContextArray.SourceContexts_p[i];</li>
<li>if (!strcmp(SourceContext_p-&gt;name_p, name_p)) {</li>
<li>SM_CHECK(sm_buildSourceContext(Runtime_p, SourceContext_p))</li>
<li>}</li>
<li>}</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>diff &ndash;git a/external/selfmake/src/lib/Core/Build.h b/external/selfmake/src/lib/Core/Build.h deleted file mode 100644 index c54b5cf..0000000 &mdash; a/external/selfmake/src/lib/Core/Build.h +++ /dev/null @ -1,28 +0,0 @ -#ifndef SM_BUILD_H -#define SM_BUILD_H</li>
<li>-#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-#include "../Parser/Functions.h" -#include "../Common/Result.h" -#include "../Common/Types.h"</li>
<li>-#endif</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>SM_RESULT sm_build(</li>
<li>sm_Runtime *Runtime_p, SM_BYTE *name_p</li>
<li>);</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>SM_RESULT sm_executeRuntime(</li>
<li>sm_Runtime *Runtime_p, SM_BYTE <b>args_pp, int args</b></li>
<li><b> );</b></li>
<li><p class="startli"><b>-/</b></p>
<p class="startli">*/</p>
</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>SM_BOOL sm_canFindSharedLib(</li>
<li>const SM_BYTE <em>lib_p</em></li>
<li><em> );</em></li>
<li><em></em></li>
<li><em> SM_RESULT sm_copy(</em></li>
<li><em> sm_VariableArray *Array_p, SM_BYTE *in_p, SM_BYTE *out_p, SM_BOOL recursive, SM_BOOL sudo</em></li>
<li><em> );</em></li>
<li><em></em></li>
<li><em> SM_RESULT sm_createSymLink(</em></li>
<li><em> SM_BYTE *filePath_p, SM_BYTE *symLinkPath_p, SM_BOOL sudo</em></li>
<li><em> );</em></li>
<li><em></em></li>
<li><em> SM_BOOL sm_fileExists(</em></li>
<li><em> SM_BYTE *filename_p</em></li>
<li><em> );</em></li>
<li><em></em></li>
<li><em> void sm_initFileArray(</em></li>
<li><em> sm_FileArray *Array_p</em></li>
<li><em> );</em></li>
<li><em> <br  />
</em></li>
<li><em> SM_RESULT sm_appendFile(</em></li>
<li><em> sm_FileArray *Array_p, SM_BYTE *path_p</em></li>
<li><em> );</em></li>
<li><p class="startli"><em>-/**</em></p>
<p class="startli"><em> */</em></p>
</li>
<li><em>-#endif diff &ndash;git a/external/selfmake/src/lib/Core/Options.c b/external/selfmake/src/lib/Core/Options.c deleted file mode 100644 index 7b25535..0000000 &mdash; a/external/selfmake/src/lib/Core/Options.c +++ /dev/null @ -1,469 +0,0 @ -// LICENSE NOTICE ==================================================================================</em></li>
<li><em>-/**</em></li>
<li><em>* selfmake - Script Language</em></li>
<li><em>* Copyright (C) 2021 The selfmake Authors</em></li>
<li><em>* Published under MIT</em></li>
<li><em>*/</em></li>
<li><em>-// INCLUDE =========================================================================================</em></li>
<li><em>-#include "Options.h" -#include "Thread.h" -#include "File.h" -#include "Build.h"</em></li>
<li><em>-#include "../Parser/Functions.h" -#include "../Parser/Variables.h"</em></li>
<li><em>-#include "../Common/Functions.h" -#include "../Common/Macros/Macros.h" -#include SM_FLOW -#include SM_DEFAULT_CHECK</em></li>
<li><em>-#include &lt;stdio.h&gt; -#include &lt;string.h&gt; -#include &lt;stdlib.h&gt; -#include &lt;ctype.h&gt;</em></li>
<li><em>-// HELPER ==========================================================================================</em></li>
<li><em>-static SM_BYTE *sm_offsetBuildArgumentPrefix(</em></li>
<li><em> sm_Runtime *Runtime_p, SM_BYTE *name_p) -{ -SM_BEGIN()</em></li>
<li><em></em></li>
<li><em> sm_Variable *Prefix_p = sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "PREFIX");</em></li>
<li><em></em></li>
<li><em> if (Prefix_p) {</em></li>
<li><em> int offset = 0;</em></li>
<li><em> for (offset = 0; offset &lt; strlen(Prefix_p-&gt;values_pp[0]) &amp;&amp; offset &lt; strlen(name_p)</em></li>
<li><em> &amp;&amp; Prefix_p-&gt;values_pp[0][offset] == name_p[offset]; ++offset) {};</em></li>
<li><em> if (offset == strlen(Prefix_p-&gt;values_pp[0])) {</em></li>
<li><em> SM_END(name_p + offset)</em></li>
<li><em> }</em></li>
<li><em> }</em></li>
<li><em>-SM_END(name_p) -}</em></li>
<li><em>-// GET OPTION ======================================================================================</em></li>
<li><em>-static sm_Option *sm_getOptionFromBlock(</em></li>
<li><em> sm_Runtime *Runtime_p, sm_Block *Block_p, SM_BYTE *name_p, SM_BYTE **argv_pp, int args) -{ -SM_BEGIN()</em></li>
<li><em></em></li>
<li><em> for (int d = 0; d &lt; Block_p-&gt;definitions; ++d)</em></li>
<li><em> {</em></li>
<li><em> switch (Block_p-&gt;Definitions_p[d].type)</em></li>
<li><em> {</em></li>
<li><em> case SM_DEFINITION_IF :</em></li>
<li><em> if (sm_compareIf(Runtime_p, &amp;Block_p-&gt;Definitions_p[d].If, SM_TRUE)) {</em></li>
<li><em> sm_Option *Option_p = sm_getOptionFromBlock(Runtime_p, &amp;Block_p-&gt;Definitions_p[d].If.Block_p-&gt;Block, name_p, argv_pp, args);</em></li>
<li><em> if (Option_p) {SM_END(Option_p)}</em></li>
<li><em> }</em></li>
<li><em> break;</em></li>
<li><em></em></li>
<li><em> case SM_DEFINITION_OPTION :</em></li>
<li><em> if (!strcmp(Block_p-&gt;Definitions_p[d].Option.name_p, name_p)</em></li>
<li><em> &amp;&amp; Block_p-&gt;Definitions_p[d].Option.arguments == args) {</em></li>
<li><em> SM_BOOL sameArguments = SM_TRUE;</em></li>
<li><em> for (int i = 0; i &lt; args; ++i) {</em></li>
<li><em> SM_BYTE *argument_p = Block_p-&gt;Definitions_p[d].Option.arguments_pp[i];</em></li>
<li><em> SM_BYTE *offsetArgument_p = argument_p;</em></li>
<li><em> if (Block_p-&gt;Definitions_p[d].Option.name_p[0] == 'b' || Block_p-&gt;Definitions_p[d].Option.name_p[0] == 't') {</em></li>
<li><em> offsetArgument_p = sm_offsetBuildArgumentPrefix(Runtime_p, argument_p);</em></li>
<li><em> }</em></li>
<li><em> if (strcmp(argument_p, argv_pp[i]) &amp;&amp; strcmp(offsetArgument_p, argv_pp[i])) {</em></li>
<li><em> sameArguments = SM_FALSE;</em></li>
<li><em> break;</em></li>
<li><em> }</em></li>
<li><em> }</em></li>
<li><em> if (sameArguments) {</em></li>
<li><em> SM_END(&amp;Block_p-&gt;Definitions_p[d].Option)</em></li>
<li><em> }</em></li>
<li><em> }</em></li>
<li><em> break;</em></li>
<li><em> }</em></li>
<li><em> }</em></li>
<li><em>-SM_END(NULL) -}</em></li>
<li><em>-static sm_Option *sm_getOptionFromParser(</em></li>
<li><em> sm_Runtime *Runtime_p, sm_Parser *Parser_p, SM_BYTE *name_p, SM_BYTE **argv_pp, int args) -{ -SM_BEGIN()</em></li>
<li><em></em></li>
<li><em> sm_Block Block;</em></li>
<li><em> Block.definitions = Parser_p-&gt;definitions;</em></li>
<li><em> Block.Definitions_p = Parser_p-&gt;Definitions_p;</em></li>
<li><em>-SM_END(sm_getOptionFromBlock(Runtime_p, &amp;Block, name_p, argv_pp, args)) -}</em></li>
<li><em>-static sm_Option *sm_getShortOptions(</em></li>
<li><em> sm_Runtime *Runtime_p, SM_BYTE *name_p, SM_BYTE **argv_pp, int args, int *options_p) -{ -SM_BEGIN()</em></li>
<li><em></em></li>
<li><em> *options_p = 0;</em></li>
<li><em></em></li>
<li><em> sm_Option *Options_p = NULL;</em></li>
<li><em> SM_BYTE c = 0;</em></li>
<li><em></em></li>
<li><em> for (int i = 0; i &lt; strlen(name_p); ++i)</em></li>
<li><em> {</em></li>
<li><em> if (i + 1 &lt; strlen(name_p)) {</em></li>
<li><em> c = name_p[i+1];</em></li>
<li><em> name_p[i+1] = 0;</em></li>
<li><em> }</em></li>
<li><em></em></li>
<li><em> sm_Option *Option_p = NULL;</em></li>
<li><em> for (int j = 0; j &lt; Runtime_p-&gt;ParserArray.length; ++j) {</em></li>
<li><em> sm_Parser *Parser_p = &amp;Runtime_p-&gt;ParserArray.Parsers_p[j];</em></li>
<li><em> Option_p = sm_getOptionFromParser(Runtime_p, Parser_p, name_p+i, argv_pp, args);</em></li>
<li><em> if (Option_p) {break;}</em></li>
<li><em> }</em></li>
<li><em></em></li>
<li><em> if (Option_p) {</em></li>
<li><em> if (*options_p == 0) {</em></li>
<li><em> Options_p = Option_p;</em></li>
<li><em> }</em></li>
<li><em> else if (*options_p == 1) {</em></li>
<li><em> sm_Option *Tmp_p = malloc(sizeof(sm_Option)*2);</em></li>
<li><em> Tmp_p[0] = *Options_p;</em></li>
<li><em> Tmp_p[1] = *Option_p;</em></li>
<li><em> Options_p = Tmp_p;</em></li>
<li><em> }</em></li>
<li><em> else {</em></li>
<li><em> Options_p = realloc(Options_p, sizeof(sm_Option)</em>(<em>options_p+1));</em></li>
<li><em> Options_p[*options_p] = *Option_p;</em></li>
<li><em> }</em></li>
<li><em> *options_p += 1;</em></li>
<li><em> }</em></li>
<li><em></em></li>
<li><em> if (c != 0) {</em></li>
<li><em> name_p[i+1] = c;</em></li>
<li><em> c = 0;</em></li>
<li><em> }</em></li>
<li><em> }</em></li>
<li><em>-SM_END(Options_p) -}</em></li>
<li><em>-static sm_Option *sm_getOption(</em></li>
<li><em> sm_Runtime *Runtime_p, SM_BYTE *name_p, SM_BYTE **argv_pp, int args) -{ -SM_BEGIN()</em></li>
<li><em></em></li>
<li><em> sm_Option *Option_p = NULL;</em></li>
<li><em></em></li>
<li><em> for (int j = 0; j &lt; Runtime_p-&gt;ParserArray.length; ++j) {</em></li>
<li><em> sm_Parser *Parser_p = &amp;Runtime_p-&gt;ParserArray.Parsers_p[j];</em></li>
<li><em> Option_p = sm_getOptionFromParser(Runtime_p, Parser_p, name_p, argv_pp, args);</em></li>
<li><em> if (Option_p) {break;}</em></li>
<li><em> }</em></li>
<li><em>-SM_END(Option_p) -}</em></li>
<li><em>-// OPTION NAME =====================================================================================</em></li>
<li><em>-static SM_BOOL sm_optionNameExistsInBlock(</em></li>
<li><em> sm_Runtime *Runtime_p, sm_Block *Block_p, SM_BYTE *name_p) -{ -SM_BEGIN()</em></li>
<li><em></em></li>
<li><em> for (int d = 0; d &lt; Block_p-&gt;definitions; ++d) {</em></li>
<li><em> switch (Block_p-&gt;Definitions_p[d].type) {</em></li>
<li><em> case SM_DEFINITION_OPTION :</em></li>
<li><em> if (!strcmp(Block_p-&gt;Definitions_p[d].Option.name_p, name_p)) {</em></li>
<li><em> SM_END(SM_TRUE)</em></li>
<li><em> }</em></li>
<li><em> break;</em></li>
<li><em> case SM_DEFINITION_IF :</em></li>
<li><em> if (sm_compareIf(Runtime_p, &amp;Block_p-&gt;Definitions_p[d].If, SM_TRUE)) {</em></li>
<li><em> if (sm_optionNameExistsInBlock(Runtime_p, &amp;Block_p-&gt;Definitions_p[d].If.Block_p-&gt;Block, name_p)) {</em></li>
<li><em> SM_END(SM_TRUE)</em></li>
<li><em> }</em></li>
<li><em> }</em></li>
<li><em> break;</em></li>
<li><em> }</em></li>
<li><em> <br  />
</em></li>
<li><em> }</em></li>
<li><em>-SM_END(SM_FALSE) -}</em></li>
<li><em>-static SM_BOOL sm_optionNameExists(</em></li>
<li><em> sm_Runtime *Runtime_p, SM_BYTE *name_p) -{ -SM_BEGIN()</em></li>
<li><em></em></li>
<li><em> for (int i = 0; i &lt; Runtime_p-&gt;ParserArray.length; ++i) {</em></li>
<li><em> sm_Parser *Parser_p = &amp;Runtime_p-&gt;ParserArray.Parsers_p[i];</em></li>
<li><em> sm_Block Block;</em></li>
<li><em> Block.definitions = Parser_p-&gt;definitions;</em></li>
<li><em> Block.Definitions_p = Parser_p-&gt;Definitions_p;</em></li>
<li><em> if (sm_optionNameExistsInBlock(Runtime_p, &amp;Block, name_p)) {</em></li>
<li><em> SM_END(SM_TRUE)</em></li>
<li><em> }</em></li>
<li><em> }</em></li>
<li><em>-SM_END(SM_FALSE) -}</em></li>
<li><em>-// EXECUTE OPTION ==================================================================================</em></li>
<li><em>-static SM_RESULT sm_printOption(</em></li>
<li><em> sm_Option *Option_p) -{ -SM_BEGIN()</em></li>
<li><em></em></li>
<li><em> SM_BYTE args_p[1024]; // TODO malloc</em></li>
<li><em> memset(args_p, 0, 1024);</em></li>
<li><em> for (int i = 0; i &lt; Option_p-&gt;arguments; ++i) {</em></li>
<li><em> sprintf(args_p + strlen(args_p), "%s ", Option_p-&gt;arguments_pp[i]);</em></li>
<li><em> }</em></li>
<li><em></em></li>
<li><em> sm_operationf(Option_p-&gt;longOption ? "--%s %s'%s'" : "-%s %s'%s'", Option_p-&gt;name_p, args_p, Option_p-&gt;description_p);</em></li>
<li><em>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</em></li>
<li><em>-static SM_RESULT sm_executeOption(</em></li>
<li><em> sm_Runtime *Runtime_p, sm_Option *Option_p) -{ -SM_BEGIN()</em></li>
<li><em></em></li>
<li><em> SM_CHECK(sm_printOption(Option_p))</em></li>
<li><em></em></li>
<li><em> if (!Option_p-&gt;Block_p) {</em></li>
<li><em> if (!strcmp(Option_p-&gt;name_p, "b")) {</em></li>
<li><em> SM_CHECK(sm_build(Runtime_p, Option_p-&gt;arguments_pp[0]))</em></li>
<li><em> }</em></li>
<li><em> else if (!strcmp(Option_p-&gt;name_p, "i")) {</em></li>
<li><em> }</em></li>
<li><em> else if (!strcmp(Option_p-&gt;name_p, "t")) {</em></li>
<li><em> SM_CHECK(sm_test(Runtime_p, Option_p-&gt;arguments_pp[0]))</em></li>
<li><em> }</em></li>
<li><em> else {SM_DIAGNOSTIC_END(SM_ERROR_BAD_STATE)}</em></li>
<li><em> }</em></li>
<li><em> else {</em></li>
<li><em> SM_CHECK(sm_executeBlock(Runtime_p, &amp;Option_p-&gt;Block_p-&gt;Block))</em></li>
<li><em> }</em></li>
<li><em>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</em></li>
<li><em>-// BUILD OPTIONS ===================================================================================</em></li>
<li><em>-static SM_BOOL sm_buildOptionOverride(</em></li>
<li><em> sm_Runtime *Runtime_p, SM_BYTE *name_p) -{ -SM_BEGIN()</em></li>
<li><em></em></li>
<li><em> for (int j = 0; j &lt; Runtime_p-&gt;ParserArray.length; ++j)</em></li>
<li><em> {</em></li>
<li><em> sm_Parser *Parser_p = &amp;Runtime_p-&gt;ParserArray.Parsers_p[j];</em></li>
<li><em></em></li>
<li><em> for (int i = 0; i &lt; Parser_p-&gt;definitions; ++i)</em></li>
<li><em> {</em></li>
<li><em> sm_Definition *Definition_p = &amp;Parser_p-&gt;Definitions_p[i];</em></li>
<li><em></em></li>
<li><em> if (Definition_p-&gt;type == SM_DEFINITION_OPTION</em></li>
<li><em> &amp;&amp; !Definition_p-&gt;Option.longOption</em></li>
<li><em> &amp;&amp; !strcmp(Definition_p-&gt;Option.name_p, "b")</em></li>
<li><em> &amp;&amp; Definition_p-&gt;Option.arguments == 1</em></li>
<li><em> &amp;&amp; (!strcmp(Definition_p-&gt;Option.arguments_pp[0], name_p) || !strcmp(sm_offsetBuildArgumentPrefix(Runtime_p, Definition_p-&gt;Option.arguments_pp[0]), name_p))) {</em></li>
<li><em> SM_END(SM_TRUE)</em></li>
<li><em> }</em></li>
<li><em> }</em></li>
<li><em> }</em></li>
<li><em>-SM_END(SM_FALSE) -}</em></li>
<li><em>-SM_RESULT sm_addBuildOption(</em></li>
<li><em> sm_Runtime *Runtime_p, SM_BYTE *name_p) -{ -SM_BEGIN()</em></li>
<li><em></em></li>
<li><em> if (sm_buildOptionOverride(Runtime_p, name_p)) {SM_DIAGNOSTIC_END(SM_SUCCESS)}</em></li>
<li><em></em></li>
<li><em> static SM_BYTE *option_p = "b";</em></li>
<li><em></em></li>
<li><em> sm_Parser *Parser_p = &amp;Runtime_p-&gt;ParserArray.Parsers_p[0];</em></li>
<li><em></em></li>
<li><em> Parser_p-&gt;Definitions_p = realloc(Parser_p-&gt;Definitions_p, sizeof(sm_Definition) * (Parser_p-&gt;definitions + 1));</em></li>
<li><em> SM_CHECK_NULL(Parser_p-&gt;Definitions_p)</em></li>
<li><em></em></li>
<li><em> sm_Definition *Definition_p = &amp;Parser_p-&gt;Definitions_p[Parser_p-&gt;definitions++];</em></li>
<li><em></em></li>
<li><em> SM_BYTE *description_p = malloc(strlen(name_p) + 7);</em></li>
<li><em> SM_CHECK_NULL(description_p)</em></li>
<li><em> sprintf(description_p, "build %s", name_p);</em></li>
<li><em></em></li>
<li><em> SM_BYTE *argument_p = malloc(strlen(name_p) + 1);</em></li>
<li><em> SM_CHECK_NULL(argument_p)</em></li>
<li><em> strcpy(argument_p, name_p);</em></li>
<li><em></em></li>
<li><em> SM_BYTE **arguments_pp = malloc(sizeof(SM_BYTE</em>));</li>
<li>SM_CHECK_NULL(arguments_pp)</li>
<li>arguments_pp[0] = argument_p;</li>
<li></li>
<li>Definition_p-&gt;type = SM_DEFINITION_OPTION;</li>
<li>Definition_p-&gt;Option.arguments = 1;</li>
<li>Definition_p-&gt;Option.arguments_pp = arguments_pp;</li>
<li>Definition_p-&gt;Option.longOption = SM_FALSE;</li>
<li>Definition_p-&gt;Option.name_p = option_p;</li>
<li>Definition_p-&gt;Option.description_p = description_p;</li>
<li>Definition_p-&gt;Option.Block_p = NULL;</li>
<li></li>
<li>sm_messagef("Generate Option '-b %s'", name_p);</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-SM_RESULT sm_addTestOption(</li>
<li>sm_Runtime <em>Runtime_p, SM_BYTE *name_p) -{ -SM_BEGIN()</em></li>
<li><em></em></li>
<li><em> static SM_BYTE *option_p = "t";</em></li>
<li><em></em></li>
<li><em> sm_Parser *Parser_p = &amp;Runtime_p-&gt;ParserArray.Parsers_p[0];</em></li>
<li><em></em></li>
<li><em> Parser_p-&gt;Definitions_p = realloc(Parser_p-&gt;Definitions_p, sizeof(sm_Definition) * (Parser_p-&gt;definitions + 1));</em></li>
<li><em> SM_CHECK_NULL(Parser_p-&gt;Definitions_p)</em></li>
<li><em></em></li>
<li><em> sm_Definition *Definition_p = &amp;Parser_p-&gt;Definitions_p[Parser_p-&gt;definitions++];</em></li>
<li><em></em></li>
<li><em> SM_BYTE *description_p = malloc(strlen(name_p) + 7);</em></li>
<li><em> SM_CHECK_NULL(description_p)</em></li>
<li><em> sprintf(description_p, "test %s", name_p);</em></li>
<li><em></em></li>
<li><em> SM_BYTE *argument_p = malloc(strlen(name_p) + 1);</em></li>
<li><em> SM_CHECK_NULL(argument_p)</em></li>
<li><em> strcpy(argument_p, name_p);</em></li>
<li><em></em></li>
<li><em> SM_BYTE **arguments_pp = malloc(sizeof(SM_BYTE</em>));</li>
<li>SM_CHECK_NULL(arguments_pp)</li>
<li>arguments_pp[0] = argument_p;</li>
<li></li>
<li>Definition_p-&gt;type = SM_DEFINITION_OPTION;</li>
<li>Definition_p-&gt;Option.arguments = 1;</li>
<li>Definition_p-&gt;Option.arguments_pp = arguments_pp;</li>
<li>Definition_p-&gt;Option.longOption = SM_FALSE;</li>
<li>Definition_p-&gt;Option.name_p = option_p;</li>
<li>Definition_p-&gt;Option.description_p = description_p;</li>
<li>Definition_p-&gt;Option.Block_p = NULL;</li>
<li></li>
<li>sm_messagef("Generate Option '-t %s'", name_p);</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-// PARSE ===========================================================================================</li>
<li>-static SM_RESULT sm_parseShortOption(</li>
<li>sm_Runtime *Runtime_p, int argc, SM_BYTE <b>argv_pp, int *advance_p) -{ -SM_BEGIN()</b></li>
<li><b></b></li>
<li><b> SM_BOOL match = SM_FALSE;</b></li>
<li><b> int options = 0;</b></li>
<li><b> sm_Option *Options_p = NULL;</b></li>
<li><b></b></li>
<li><b> *advance_p = 1;</b></li>
<li><b></b></li>
<li><b> for (int i = 1; i &lt; argc; ++i)</b></li>
<li><b> {</b></li>
<li><b> if (argv_pp[i][0] == '-') {</b></li>
<li><b> break;</b></li>
<li><b> }</b></li>
<li><b></b></li>
<li><b> Options_p = sm_getShortOptions(Runtime_p, &amp;argv_pp[0][1], &amp;argv_pp[i], 1, &amp;options);</b></li>
<li><b> if (Options_p) {</b></li>
<li><b> for (int j = 0; j &lt; options; ++j) {</b></li>
<li><b> SM_CHECK(sm_executeOption(Runtime_p, Options_p+j))</b></li>
<li><b> }</b></li>
<li><b> if (options &gt; 1) {free(Options_p);}</b></li>
<li><b> Options_p = NULL;</b></li>
<li><b> match = SM_TRUE;</b></li>
<li><b> }</b></li>
<li><b></b></li>
<li><b> *advance_p += 1;</b></li>
<li><b> }</b></li>
<li><b></b></li>
<li><b> if (Options_p) {</b></li>
<li><b> for (int i = 0; i &lt; options; ++i) {</b></li>
<li><b> SM_CHECK(sm_executeOption(Runtime_p, Options_p+i))</b></li>
<li><b> }</b></li>
<li><b> if (options &gt; 1) {free(Options_p);}</b></li>
<li><b> }</b></li>
<li><b>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</b></li>
<li><b>-static SM_RESULT sm_parseLongOption(</b></li>
<li><b> sm_Runtime *Runtime_p, int argc, SM_BYTE **argv_pp, int *advance_p) -{ -SM_BEGIN()</b></li>
<li><b></b></li>
<li><b> SM_BOOL match = SM_FALSE;</b></li>
<li><b> sm_Option *Option_p = NULL;</b></li>
<li><b></b></li>
<li><b> for (int i = 0; i &lt; argc; ++i)</b></li>
<li><b> {</b></li>
<li><b> if (i &gt; 0 &amp;&amp; argv_pp[i][0] == '-') {</b></li>
<li><b> break;</b></li>
<li><b> }</b></li>
<li><b></b></li>
<li><b> sm_Option *NewOption_p =</b></li>
<li><b> sm_getOption(Runtime_p, &amp;argv_pp[0][2], i == 0 ? NULL : &amp;argv_pp[1], *advance_p);</b></li>
<li><b></b></li>
<li><b> if (NewOption_p) {</b></li>
<li><b> Option_p = NewOption_p;</b></li>
<li><b> }</b></li>
<li><b> else {</b></li>
<li><b> sm_noticef("Invalid option \"%s\"", argv_pp[i]);</b></li>
<li><b> SM_DIAGNOSTIC_END(SM_ERROR_INVALID_OPTION)</b></li>
<li><b> }</b></li>
<li><b></b></li>
<li><b> *advance_p += 1;</b></li>
<li><b> }</b></li>
<li><b></b></li>
<li><b> if (Option_p) {</b></li>
<li><b> SM_CHECK(sm_executeOption(Runtime_p, Option_p))</b></li>
<li><b> }</b></li>
<li><b> -SM_DIAGNOSTIC_END(SM_SUCCESS) -}</b></li>
<li><b>-SM_RESULT sm_parseOption(</b></li>
<li><b> sm_Runtime *Runtime_p, int argc, SM_BYTE **argv_pp, int *advance_p) -{ -SM_BEGIN()</b></li>
<li><b></b></li>
<li><b> int advance = 0;</b></li>
<li><b></b></li>
<li><b> for (int i = 0; i &lt; argc; i += advance)</b></li>
<li><b> {</b></li>
<li><b> advance = 0;</b></li>
<li><b></b></li>
<li><b> if (argv_pp[i][0] == '-' &amp;&amp; argv_pp[i][1] != '-') {</b></li>
<li><b> SM_CHECK(sm_parseShortOption(Runtime_p, argc-i, &amp;argv_pp[i], &amp;advance))</b></li>
<li><b> }</b></li>
<li><b> else if (argv_pp[i][0] == '-' &amp;&amp; argv_pp[i][1] == '-') {</b></li>
<li><b> SM_CHECK(sm_parseLongOption(Runtime_p, argc-i, &amp;argv_pp[i], &amp;advance))</b></li>
<li><b> }</b></li>
<li><b></b></li>
<li><b> *advance_p += advance;</b></li>
<li><b> }</b></li>
<li><b>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</b></li>
<li><b>diff &ndash;git a/external/selfmake/src/lib/Core/Options.h b/external/selfmake/src/lib/Core/Options.h deleted file mode 100644 index 170aa88..0000000 &mdash; a/external/selfmake/src/lib/Core/Options.h +++ /dev/null @ -1,40 +0,0 @ -#ifndef SM_OPTIONS_H -#define SM_OPTIONS_H</b></li>
<li><b>-#ifndef DOXYGEN_SHOULD_SKIP_THIS</b></li>
<li><b>-/</b></li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-#include "Source.h"</li>
<li>-#include "../Common/Result.h" -#include "../Common/Types.h"</li>
<li>-#include "../Parser/Parser.h" -#include "../Parser/Variables.h"</li>
<li>-#endif</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>SM_RESULT sm_addBuildOption(</li>
<li>sm_Runtime <em>Runtime_p, SM_BYTE *name_p</em></li>
<li><em> );</em></li>
<li><em></em></li>
<li><em> SM_RESULT sm_addTestOption(</em></li>
<li><em> sm_Runtime *Runtime_p, SM_BYTE *name_p</em></li>
<li><em> );</em></li>
<li><em></em></li>
<li><em> SM_RESULT sm_parseOption(</em></li>
<li><em> sm_Runtime *Runtime_p, int argc, SM_BYTE <b>argv_pp, int *advance_p</b></em></li>
<li><em><b> );</b></em></li>
<li><p class="startli"><em><b>-/</b></em></p>
<p class="startli"><em> */</em></p>
</li>
<li><em>-/**</em></li>
<li><em>*</em></li>
<li><em>*/</em></li>
<li><em></em></li>
<li><em> void sm_initSourceArray(</em></li>
<li><em> sm_SourceArray *Array_p</em></li>
<li><em> );</em></li>
<li><em></em></li>
<li><em> SM_RESULT sm_addSource(</em></li>
<li><em> sm_SourceContextArray *ContextArray_p, sm_SourceArray *SourceArray_p, sm_Function *Function_p,</em></li>
<li><em> SM_SOURCE_CONTEXT type</em></li>
<li><em> );</em></li>
<li><em></em></li>
<li><em> void sm_initSourceContextArray(</em></li>
<li><em> sm_SourceContextArray *Array_p</em></li>
<li><em> );</em></li>
<li><em></em></li>
<li><em> void sm_getIndentAfterSourceContext(</em></li>
<li><em> SM_BYTE *name_p, SM_BYTE *buffer_p, int size, sm_SourceContextArray *Array_p</em></li>
<li><em> );</em></li>
<li><em></em></li>
<li><em> SM_RESULT sm_addSourceContext(</em></li>
<li><em> sm_Runtime *Runtime_p, sm_Function *Function_p, SM_SOURCE_CONTEXT type, int offset</em></li>
<li><em> );</em></li>
<li><em></em></li>
<li><em> SM_RESULT sm_addCompileArguments(</em></li>
<li><em> sm_SourceContextArray *ContextArray_p, sm_Function *Function_p, SM_SOURCE_CONTEXT type</em></li>
<li><em> );</em></li>
<li><em> <br  />
</em></li>
<li><em> SM_RESULT sm_addLinkArguments(</em></li>
<li><em> sm_SourceContextArray *Array_p, sm_Function *Function_p, SM_SOURCE_CONTEXT type</em></li>
<li><em> );</em></li>
<li><p class="startli"><em>-/**</em></p>
<p class="startli"><em> */</em></p>
</li>
<li><em>-/**</em></li>
<li><em>*</em></li>
<li><em>*/</em></li>
<li><em></em></li>
<li><em> void sm_initThreadPool(</em></li>
<li><em> );</em></li>
<li><em> <br  />
</em></li>
<li><em> SM_RESULT sm_runThread(</em></li>
<li><em> sm_Runtime *Runtime_p, SM_BYTE <b>args_pp, int args</b></em></li>
<li><em><b> );</b></em></li>
<li><em><b></b></em></li>
<li><em><b> sm_Thread *_sm_getThread(</b></em></li>
<li><em><b> );</b></em></li>
<li><p class="startli"><em><b> <br  />
 -/</b></em></p>
<p class="startli"><em> */</em></p>
</li>
<li><em>-#endif diff &ndash;git a/external/selfmake/src/lib/Core/Utils.h b/external/selfmake/src/lib/Core/Utils.h deleted file mode 100644 index 69d34b2..0000000 &mdash; a/external/selfmake/src/lib/Core/Utils.h +++ /dev/null @ -1,40 +0,0 @ -#ifndef SM_UTILS_H -#define SM_UTILS_H</em></li>
<li><em>-#ifndef DOXYGEN_SHOULD_SKIP_THIS</em></li>
<li><em>-/**</em></li>
<li><em>* selfmake - Script Language</em></li>
<li><em>* Copyright (C) 2021 The selfmake Authors</em></li>
<li><em>* Published under MIT</em></li>
<li><em>*/</em></li>
<li><em>-#include "../Common/Result.h" -#include "../Common/Types.h"</em></li>
<li><em>-#include &lt;stddef.h&gt;</em></li>
<li><em>-#endif</em></li>
<li><em>-/**</em></li>
<li><em>*</em></li>
<li><em>*/</em></li>
<li><em></em></li>
<li><em> const SM_BYTE <em>sm_getHomeDir(</em></em></li>
<li><em><em> );</em></em></li>
<li><em><em></em></em></li>
<li><em><em> SM_RESULT sm_createDir(</em></em></li>
<li><em><em> SM_BYTE *path_p</em></em></li>
<li><em><em> );</em></em></li>
<li><em><em> <br  />
</em></em></li>
<li><em><em> SM_RESULT sm_removeDir(</em></em></li>
<li><em><em> SM_BYTE *path_p</em></em></li>
<li><em><em> );</em></em></li>
<li><em><em></em></em></li>
<li><em><em> SM_BOOL sm_canRunCommand(</em></em></li>
<li><em><em> const SM_BYTE *cmd</em></em></li>
<li><em><em> );</em></em></li>
<li><p class="startli"><em><em>-/**</em></em></p>
<p class="startli"><em><em> */</em></em></p>
</li>
<li><em><em>-#endif diff &ndash;git a/external/selfmake/src/lib/Parser/Functions.c b/external/selfmake/src/lib/Parser/Functions.c deleted file mode 100644 index 5bc130f..0000000 &mdash; a/external/selfmake/src/lib/Parser/Functions.c +++ /dev/null @ -1,275 +0,0 @ -// LICENSE NOTICE ==================================================================================</em></em></li>
<li><em><em>-/**</em></em></li>
<li><em><em>* selfmake - Script Language</em></em></li>
<li><em><em>* Copyright (C) 2021 The selfmake Authors</em></em></li>
<li><em><em>* Published under MIT</em></em></li>
<li><em><em>*/</em></em></li>
<li><em><em>-// INCLUDE =========================================================================================</em></em></li>
<li><em><em>-#include "Functions.h" -#include "Variables.h"</em></em></li>
<li><em><em>-#include "../Core/Build.h" -#include "../Core/Utils.h" -#include "../UI/Message.h" -#include "../Common/Macros/Macros.h" -#include SM_FLOW -#include SM_DEFAULT_CHECK</em></em></li>
<li><em><em>-#include &lt;stdio.h&gt; -#include &lt;stdlib.h&gt; -#include &lt;string.h&gt; -#include &lt;unistd.h&gt; -#include &lt;ctype.h&gt;</em></em></li>
<li><em><em>-#include &lt;sys/types.h&gt; -#include &lt;sys/stat.h&gt;</em></em></li>
<li><em><em>-// HELPER ==========================================================================================</em></em></li>
<li><em><em>-static SM_BOOL sm_caseInsensitiveMatch(</em></em></li>
<li><em><em> SM_BYTE *str1_p, SM_BYTE *str2_p) -{ -SM_BEGIN()</em></em></li>
<li><em><em></em></em></li>
<li><em><em> if (strlen(str1_p) != strlen(str2_p)) {SM_END(SM_FALSE)}</em></em></li>
<li><em><em></em></em></li>
<li><em><em> for (int i = 0; i &lt; strlen(str1_p); ++i) {</em></em></li>
<li><em><em> int d = tolower((unsigned char)str1_p[i]) - tolower((unsigned char)str2_p[i]);</em></em></li>
<li><em><em> if (d != 0) {</em></em></li>
<li><em><em> SM_END(SM_FALSE)</em></em></li>
<li><em><em> }</em></em></li>
<li><em><em> }</em></em></li>
<li><em><em> <br  />
 -SM_END(SM_TRUE) -}</em></em></li>
<li><em><em>-// EXECUTE =========================================================================================</em></em></li>
<li><em><em>-static SM_RESULT sm_executeCopyFunction(</em></em></li>
<li><em><em> sm_Runtime *Runtime_p, sm_Function *Function_p) -{ -SM_BEGIN()</em></em></li>
<li><em><em></em></em></li>
<li><em><em> if (Function_p-&gt;arguments &lt;= 0 || Function_p-&gt;arguments &gt; 4) {SM_DIAGNOSTIC_END(SM_ERROR_BAD_STATE)}</em></em></li>
<li><em><em></em></em></li>
<li><em><em> switch(Function_p-&gt;arguments)</em></em></li>
<li><em><em> {</em></em></li>
<li><em><em> case 2 :</em></em></li>
<li><em><em> sm_copy(&amp;Runtime_p-&gt;VariableArray, Function_p-&gt;arguments_pp[0], Function_p-&gt;arguments_pp[1], SM_FALSE, SM_FALSE);</em></em></li>
<li><em><em> break;</em></em></li>
<li><em><em> case 3 :</em></em></li>
<li><em><em> sm_copy(&amp;Runtime_p-&gt;VariableArray, Function_p-&gt;arguments_pp[0], Function_p-&gt;arguments_pp[1], !strcmp(Function_p-&gt;arguments_pp[2], "true") ? SM_TRUE : SM_FALSE, SM_FALSE);</em></em></li>
<li><em><em> break;</em></em></li>
<li><em><em> case 4 :</em></em></li>
<li><em><em> sm_copy(&amp;Runtime_p-&gt;VariableArray, Function_p-&gt;arguments_pp[0], Function_p-&gt;arguments_pp[1], !strcmp(Function_p-&gt;arguments_pp[2], "true") ? SM_TRUE : SM_FALSE, !strcmp(Function_p-&gt;arguments_pp[3], "true") ? SM_TRUE : SM_FALSE);</em></em></li>
<li><em><em> break;</em></em></li>
<li><em><em> }</em></em></li>
<li><em><em>-SM_END(SM_SUCCESS) -}</em></em></li>
<li><em><em>-static SM_RESULT sm_executeChdirFunction(</em></em></li>
<li><em><em> sm_Runtime *Runtime_p, sm_Function *Function_p) -{ -SM_BEGIN()</em></em></li>
<li><em><em></em></em></li>
<li><em><em> if (Function_p-&gt;arguments == 0) {</em></em></li>
<li><em><em> sm_updateVariable(&amp;Runtime_p-&gt;VariableArray, "WRK_DIR", sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "PROJ_DIR")-&gt;values_pp, 1);</em></em></li>
<li><em><em> }</em></em></li>
<li><em><em> else {</em></em></li>
<li><em><em> sm_updateVariable(&amp;Runtime_p-&gt;VariableArray, "WRK_DIR", Function_p-&gt;arguments_pp, 1);</em></em></li>
<li><em><em> }</em></em></li>
<li><em><em></em></em></li>
<li><em><em> sm_messagef("chdir %s", sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "WRK_DIR")-&gt;values_pp[0]);</em></em></li>
<li><em><em>-SM_END(SM_SUCCESS) -}</em></em></li>
<li><em><em>-static SM_RESULT sm_executeMkdirFunction(</em></em></li>
<li><em><em> sm_Function *Function_p) -{ -SM_BEGIN()</em></em></li>
<li><em><em></em></em></li>
<li><em><em> if (Function_p-&gt;arguments != 1) {SM_DIAGNOSTIC_END(SM_SUCCESS)}</em></em></li>
<li><em><em></em></em></li>
<li><em><em> struct stat st = {0};</em></em></li>
<li><em><em> if (stat(Function_p-&gt;arguments_pp[0], &amp;st) == -1) {</em></em></li>
<li><em><em> int err = mkdir(Function_p-&gt;arguments_pp[0], 0755); // 0755 -&gt; drwxr-xr-x</em></em></li>
<li><em><em> if (err != 0) {</em></em></li>
<li><em><em> SM_DIAGNOSTIC_END(SM_ERROR_CANT_CREATE_DIRECTORY)</em></em></li>
<li><em><em> }</em></em></li>
<li><em><em> }</em></em></li>
<li><em><em></em></em></li>
<li><em><em> sm_messagef("mkdir %s", Function_p-&gt;arguments_pp[0]);</em></em></li>
<li><em><em>-SM_END(SM_SUCCESS) -}</em></em></li>
<li><em><em>-static SM_RESULT sm_executeSystemFunction(</em></em></li>
<li><em><em> sm_Function *Function_p) -{ -SM_BEGIN()</em></em></li>
<li><em><em></em></em></li>
<li><em><em> if (Function_p-&gt;arguments != 1) {SM_DIAGNOSTIC_END(SM_ERROR_BAD_STATE)}</em></em></li>
<li><em><em> sm_messagef("system %s", Function_p-&gt;arguments_pp[0]);</em></em></li>
<li><em><em> system(Function_p-&gt;arguments_pp[0]);</em></em></li>
<li><em><em>-SM_END(SM_SUCCESS) -}</em></em></li>
<li><em><em>-SM_RESULT sm_executeFunction(</em></em></li>
<li><em><em> sm_Runtime *Runtime_p, sm_Function *Function_p) -{ -SM_BEGIN()</em></em></li>
<li><em><em></em></em></li>
<li><em><em> SM_BYTE **arguments_pp = malloc(sizeof(SM_BYTE</em>) * Function_p-&gt;arguments);</em></li>
<li><em> memcpy(arguments_pp, Function_p-&gt;arguments_pp, sizeof(SM_BYTE*) * Function_p-&gt;arguments);</em></li>
<li><em></em></li>
<li><em> for (int i = 0; i &lt; Function_p-&gt;arguments; ++i) {</em></li>
<li><em> Function_p-&gt;arguments_pp[i] = sm_substituteVariables(&amp;Runtime_p-&gt;VariableArray, arguments_pp[i]);</em></li>
<li><em> SM_CHECK_NULL(Function_p-&gt;arguments_pp[i])</em></li>
<li><em> }</em></li>
<li><em> SM_RESULT result = SM_SUCCESS;</em></li>
<li><em></em></li>
<li><em> if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "lib")) {</em></li>
<li><em> if (!strcmp(Function_p-&gt;arguments_pp[0], "SHARED")) {</em></li>
<li><em> result = sm_addSourceContext(Runtime_p, Function_p, SM_SOURCE_CONTEXT_SHARED_LIBRARY, 1);</em></li>
<li><em> }</em></li>
<li><em> else if (!strcmp(Function_p-&gt;arguments_pp[0], "STATIC")) {</em></li>
<li><em> result = sm_addSourceContext(Runtime_p, Function_p, SM_SOURCE_CONTEXT_STATIC_LIBRARY, 1);</em></li>
<li><em> }</em></li>
<li><em> else {</em></li>
<li><em> result = sm_addSourceContext(Runtime_p, Function_p, SM_SOURCE_CONTEXT_SHARED_LIBRARY, 0);</em></li>
<li><em> }</em></li>
<li><em> if (!result &amp;&amp; Runtime_p-&gt;sourceContextCallback_f) {</em></li>
<li><em> result = Runtime_p-&gt;sourceContextCallback_f(</em></li>
<li><em> Runtime_p, &amp;Runtime_p-&gt;SourceContextArray.SourceContexts_p[Runtime_p-&gt;SourceContextArray.length - 1]</em></li>
<li><em> );</em></li>
<li><em> }</em></li>
<li><em> }</em></li>
<li><em> else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "bin")) {</em></li>
<li><em> result = sm_addSourceContext(Runtime_p, Function_p, SM_SOURCE_CONTEXT_BINARY, 0);</em></li>
<li><em> if (!result &amp;&amp; Runtime_p-&gt;sourceContextCallback_f) {</em></li>
<li><em> result = Runtime_p-&gt;sourceContextCallback_f(</em></li>
<li><em> Runtime_p, &amp;Runtime_p-&gt;SourceContextArray.SourceContexts_p[Runtime_p-&gt;SourceContextArray.length - 1]</em></li>
<li><em> );</em></li>
<li><em> }</em></li>
<li><em> }</em></li>
<li><em> else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "compile")) {</em></li>
<li><em> result = sm_addCompileArguments(&amp;Runtime_p-&gt;SourceContextArray, Function_p, SM_SOURCE_CONTEXT_UNDEFINED);</em></li>
<li><em> }</em></li>
<li><em> else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "compile_lib")) {</em></li>
<li><em> result = sm_addCompileArguments(&amp;Runtime_p-&gt;SourceContextArray, Function_p, SM_SOURCE_CONTEXT_SHARED_LIBRARY);</em></li>
<li><em> }</em></li>
<li><em> else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "compile_bin")) {</em></li>
<li><em> result = sm_addCompileArguments(&amp;Runtime_p-&gt;SourceContextArray, Function_p, SM_SOURCE_CONTEXT_BINARY);</em></li>
<li><em> }</em></li>
<li><em> else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "link")) {</em></li>
<li><em> result = sm_addLinkArguments(&amp;Runtime_p-&gt;SourceContextArray, Function_p, SM_SOURCE_CONTEXT_UNDEFINED);</em></li>
<li><em> }</em></li>
<li><em> else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "link_lib")) {</em></li>
<li><em> result = sm_addLinkArguments(&amp;Runtime_p-&gt;SourceContextArray, Function_p, SM_SOURCE_CONTEXT_SHARED_LIBRARY);</em></li>
<li><em> }</em></li>
<li><em> else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "link_bin")) {</em></li>
<li><em> result = sm_addLinkArguments(&amp;Runtime_p-&gt;SourceContextArray, Function_p, SM_SOURCE_CONTEXT_BINARY);</em></li>
<li><em> }</em></li>
<li><em> else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "source")) {</em></li>
<li><em> result = sm_addSource(&amp;Runtime_p-&gt;SourceContextArray, &amp;Runtime_p-&gt;SourceArray, Function_p, SM_SOURCE_CONTEXT_UNDEFINED);</em></li>
<li><em> }</em></li>
<li><em> else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "source_lib")) {</em></li>
<li><em> result = sm_addSource(&amp;Runtime_p-&gt;SourceContextArray, &amp;Runtime_p-&gt;SourceArray, Function_p, SM_SOURCE_CONTEXT_SHARED_LIBRARY);</em></li>
<li><em> }</em></li>
<li><em> else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "source_bin")) {</em></li>
<li><em> result = sm_addSource(&amp;Runtime_p-&gt;SourceContextArray, &amp;Runtime_p-&gt;SourceArray, Function_p, SM_SOURCE_CONTEXT_BINARY);</em></li>
<li><em> }</em></li>
<li><em> else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "test")) {</em></li>
<li><em> result = sm_addTest(&amp;Runtime_p-&gt;SourceContextArray, &amp;Runtime_p-&gt;TestArray, Function_p);</em></li>
<li><em> }</em></li>
<li><em> else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "copy")) {</em></li>
<li><em> result = sm_executeCopyFunction(Runtime_p, Function_p);</em></li>
<li><em> }</em></li>
<li><em> else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "build")) {</em></li>
<li><em> result = sm_build(Runtime_p, Function_p-&gt;arguments_pp[0]);</em></li>
<li><em> }</em></li>
<li><em> else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "chdir")) {</em></li>
<li><em> result = sm_executeChdirFunction(Runtime_p, Function_p);</em></li>
<li><em> }</em></li>
<li><em> else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "mkdir")) {</em></li>
<li><em> result = sm_executeMkdirFunction(Function_p);</em></li>
<li><em> }</em></li>
<li><em> else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "system")) {</em></li>
<li><em> result = sm_executeSystemFunction(Function_p);</em></li>
<li><em> }</em></li>
<li><em> else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "system")) {</em></li>
<li><em> result = sm_executeSystemFunction(Function_p);</em></li>
<li><em> }</em></li>
<li><em> else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "set")) {</em></li>
<li><em> result = sm_updateVariable(</em></li>
<li><em> &amp;Runtime_p-&gt;VariableArray, Function_p-&gt;arguments_pp[0], Function_p-&gt;arguments_pp + 1,</em></li>
<li><em> Function_p-&gt;arguments - 1</em></li>
<li><em> );</em></li>
<li><em> }</em></li>
<li><em></em></li>
<li><em> if (!result &amp;&amp; Runtime_p-&gt;functionCallback_f) {</em></li>
<li><em> result = Runtime_p-&gt;functionCallback_f(Runtime_p, Function_p);</em></li>
<li><em> }</em></li>
<li><em></em></li>
<li><em> for (int i = 0; i &lt; Function_p-&gt;arguments; ++i) {</em></li>
<li><em> free(Function_p-&gt;arguments_pp[i]);</em></li>
<li><em> }</em></li>
<li><em></em></li>
<li><em> memcpy(Function_p-&gt;arguments_pp, arguments_pp, sizeof(SM_BYTE*) * Function_p-&gt;arguments);</em></li>
<li><em> free(arguments_pp);</em></li>
<li><em>-SM_DIAGNOSTIC_END(result) -}</em></li>
<li><em>-SM_BOOL sm_compareIf(</em></li>
<li><em> sm_Runtime *Runtime_p, sm_If *If_p, SM_BOOL b) -{ -SM_BEGIN()</em></li>
<li><em></em></li>
<li><em> sm_Variable *Var_p = sm_getVariable(&amp;Runtime_p-&gt;VariableArray, If_p-&gt;string_p);</em></li>
<li><em> if (Var_p &amp;&amp; Var_p-&gt;valueCount &gt; 0) {</em></li>
<li><em> if (!strcmp(*Var_p-&gt;values_pp, "true") &amp;&amp; b == SM_TRUE) {SM_END(SM_TRUE)}</em></li>
<li><em> if (!strcmp(*Var_p-&gt;values_pp, "false") &amp;&amp; b == SM_FALSE) {SM_END(SM_TRUE)}</em></li>
<li><em> }</em></li>
<li><em>-SM_END(SM_FALSE) -}</em></li>
<li><em>-SM_RESULT sm_executeIf(</em></li>
<li><em> sm_Runtime *Runtime_p, sm_If *If_p) -{ -SM_BEGIN()</em></li>
<li><em></em></li>
<li><em> sm_Variable *Var_p = sm_getVariable(&amp;Runtime_p-&gt;VariableArray, If_p-&gt;string_p);</em></li>
<li><em> if (Var_p &amp;&amp; Var_p-&gt;valueCount &gt; 0 &amp;&amp; !strcmp(*Var_p-&gt;values_pp, "true")) {</em></li>
<li><em> SM_CHECK(sm_executeBlock(Runtime_p, &amp;If_p-&gt;Block_p-&gt;Block))</em></li>
<li><em> }</em></li>
<li><em>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</em></li>
<li><em>-// EXECUTE BLOCK ===================================================================================</em></li>
<li><em>-SM_RESULT sm_executeBlock(</em></li>
<li><em> sm_Runtime *Runtime_p, sm_Block *Block_p) -{ -SM_BEGIN()</em></li>
<li><em></em></li>
<li><em> for (int d = 0; d &lt; Block_p-&gt;definitions; ++d) {</em></li>
<li><em> switch (Block_p-&gt;Definitions_p[d].type) {</em></li>
<li><em> case SM_DEFINITION_FUNCTION :</em></li>
<li><em> SM_CHECK(sm_executeFunction(Runtime_p, &amp;Block_p-&gt;Definitions_p[d].Function))</em></li>
<li><em> case SM_DEFINITION_IF :</em></li>
<li><em> SM_CHECK(sm_executeIf(Runtime_p, &amp;Block_p-&gt;Definitions_p[d].If))</em></li>
<li><em> }</em></li>
<li><em> }</em></li>
<li><em>-SM_END(SM_SUCCESS) -}</em></li>
<li><em>diff &ndash;git a/external/selfmake/src/lib/Parser/Functions.h b/external/selfmake/src/lib/Parser/Functions.h deleted file mode 100644 index 8dc85f9..0000000 &mdash; a/external/selfmake/src/lib/Parser/Functions.h +++ /dev/null @ -1,39 +0,0 @ -#ifndef SM_FUNCTIONS_H -#define SM_FUNCTIONS_H</em></li>
<li><em>-#ifndef DOXYGEN_SHOULD_SKIP_THIS</em></li>
<li><em>-/**</em></li>
<li><em>* selfmake - Script Language</em></li>
<li><em>* Copyright (C) 2021 The selfmake Authors</em></li>
<li><em>* Published under MIT</em></li>
<li><em>*/</em></li>
<li><em>-#include "Parser.h"</em></li>
<li><em>-#include "../Core/Runtime.h"</em></li>
<li><em>-#include "../Common/Types.h" -#include "../Common/Result.h"</em></li>
<li><em>-#endif</em></li>
<li><em>-/**</em></li>
<li><em>*</em></li>
<li><em>*/</em></li>
<li><em></em></li>
<li><em> SM_RESULT sm_executeFunction(</em></li>
<li><em> sm_Runtime <em>Runtime_p, sm_Function *Function_p</em></em></li>
<li><em><em> );</em></em></li>
<li><em><em></em></em></li>
<li><em><em> SM_RESULT sm_executeBlock(</em></em></li>
<li><em><em> sm_Runtime *Runtime_p, sm_Block *Block_p</em></em></li>
<li><em><em> );</em></em></li>
<li><em><em></em></em></li>
<li><em><em> SM_BOOL sm_compareIf(</em></em></li>
<li><em><em> sm_Runtime *Runtime_p, sm_If *If_p, SM_BOOL b</em></em></li>
<li><em><em> );</em></em></li>
<li><p class="startli"><em><em>-/**</em></em></p>
<p class="startli"><em><em> */</em></em></p>
</li>
<li><em><em>-/**</em></em></li>
<li><em><em>*</em></em></li>
<li><em><em>*/</em></em></li>
<li><em><em></em></em></li>
<li><em><em> void sm_initParserArray(</em></em></li>
<li><em><em> sm_ParserArray *Array_p</em></em></li>
<li><em><em> );</em></em></li>
<li><em><em></em></em></li>
<li><em><em> SM_RESULT sm_appendParser(</em></em></li>
<li><em><em> sm_ParserArray *Array_p, sm_File *File_p, SM_BOOL showParseTree</em></em></li>
<li><em><em> );</em></em></li>
<li><p class="startli"><em><em>-/**</em></em></p>
<p class="startli"><em><em> */</em></em></p>
</li>
<li><em><em>-/**</em></em></li>
<li><em><em>*</em></em></li>
<li><em><em>*/</em></em></li>
<li><em><em></em></em></li>
<li><em><em> sm_Tokenizer sm_initTokenizer(</em></em></li>
<li><em><em> );</em></em></li>
<li><em><em></em></em></li>
<li><em><em> SM_RESULT sm_tokenizeFile(</em></em></li>
<li><em><em> sm_Tokenizer *Tokenizer_p, sm_File *File_p</em></em></li>
<li><em><em> );</em></em></li>
<li><p class="startli"><em><em>-/**</em></em></p>
<p class="startli"><em><em> */</em></em></p>
</li>
<li><em><em>-/**</em></em></li>
<li><em><em>*</em></em></li>
<li><em><em>*/</em></em></li>
<li><em><em></em></em></li>
<li><em><em> void sm_initVariableArray(</em></em></li>
<li><em><em> sm_VariableArray *Array_p</em></em></li>
<li><em><em> );</em></em></li>
<li><em><em></em></em></li>
<li><em><em> sm_Variable *sm_getVariable(</em></em></li>
<li><em><em> sm_VariableArray *Array_p, SM_BYTE *name_p</em></em></li>
<li><em><em> );</em></em></li>
<li><em><em></em></em></li>
<li><em><em> SM_RESULT sm_appendToVariable(</em></em></li>
<li><em><em> sm_VariableArray *Array_p, SM_BYTE *variable_p, SM_BYTE <b>values_pp, int valueCount</b></em></em></li>
<li><em><em><b> );</b></em></em></li>
<li><em><em><b></b></em></em></li>
<li><em><em><b> SM_RESULT sm_updateVariable(</b></em></em></li>
<li><em><em><b> sm_VariableArray *Array_p, SM_BYTE *variable_p, SM_BYTE **values_pp, int valueCount</b></em></em></li>
<li><em><em><b> );</b></em></em></li>
<li><em><em><b></b></em></em></li>
<li><em><em><b> SM_BYTE *sm_substituteVariables(</b></em></em></li>
<li><em><em><b> sm_VariableArray *Array_p, SM_BYTE *string_p</b></em></em></li>
<li><em><em><b> );</b></em></em></li>
<li><p class="startli"><em><em><b>-/</b></em></em></p>
<p class="startli"><em><em> */</em></em></p>
</li>
<li><em><em>-#endif diff &ndash;git a/external/selfmake/src/lib/Test/Library.h b/external/selfmake/src/lib/Test/Library.h deleted file mode 100644 index 808ed3f..0000000 &mdash; a/external/selfmake/src/lib/Test/Library.h +++ /dev/null @ -1,41 +0,0 @ -#ifndef SM_LIBRARY_H -#define SM_LIBRARY_H</em></em></li>
<li><em><em>-#ifndef DOXYGEN_SHOULD_SKIP_THIS</em></em></li>
<li><em><em>-/**</em></em></li>
<li><em><em>* selfmake - Script Language</em></em></li>
<li><em><em>* Copyright (C) 2021 The selfmake Authors</em></em></li>
<li><em><em>* Published under MIT</em></em></li>
<li><em><em>*/</em></em></li>
<li><em><em>-#include "../Common/Result.h" -#include "../Common/Types.h"</em></em></li>
<li><em><em>-#include &lt;stddef.h&gt;</em></em></li>
<li><em><em>-#endif</em></em></li>
<li><em><em>-/**</em></em></li>
<li><em><em>*</em></em></li>
<li><em><em>*/</em></em></li>
<li><em><em></em></em></li>
<li><em><em> void *sm_openLibrary(</em></em></li>
<li><em><em> SM_BYTE *path_p</em></em></li>
<li><em><em> );</em></em></li>
<li><em><em> <br  />
</em></em></li>
<li><em><em> void sm_closeLibrary(</em></em></li>
<li><em><em> void *lib_p</em></em></li>
<li><em><em> );</em></em></li>
<li><em><em> <br  />
</em></em></li>
<li><em><em> SM_RESULT sm_getExeDir(</em></em></li>
<li><em><em> SM_BYTE *buffer_p, size_t size</em></em></li>
<li><em><em> );</em></em></li>
<li><em><em> <br  />
</em></em></li>
<li><em><em> void *sm_loadSymbol(</em></em></li>
<li><em><em> void *lib_p, const SM_BYTE *name_p</em></em></li>
<li><em><em> );</em></em></li>
<li><p class="startli"><em><em>-/**</em></em></p>
<p class="startli"><em><em> */</em></em></p>
</li>
<li><em><em>-/**</em></em></li>
<li><em><em>*</em></em></li>
<li><em><em>*/</em></em></li>
<li><em><em></em></em></li>
<li><em><em> sm_Process sm_fork(</em></em></li>
<li><em><em> );</em></em></li>
<li><p class="startli"><em><em>-/**</em></em></p>
<p class="startli"><em><em> */</em></em></p>
</li>
<li><em><em>-/**</em></em></li>
<li><em><em>*</em></em></li>
<li><em><em>*/</em></em></li>
<li><em><em></em></em></li>
<li><em><em> void sm_initTestArray(</em></em></li>
<li><em><em> sm_TestArray *Array_p</em></em></li>
<li><em><em> );</em></em></li>
<li><em><em> <br  />
</em></em></li>
<li><em><em> SM_RESULT sm_addTest(</em></em></li>
<li><em><em> sm_SourceContextArray *ContextArray_p, sm_TestArray *TestArray_p, sm_Function *Function_p</em></em></li>
<li><em><em> );</em></em></li>
<li><em><em></em></em></li>
<li><em><em> SM_RESULT sm_test(</em></em></li>
<li><em><em> sm_Runtime *Runtime_p, SM_BYTE *name_p</em></em></li>
<li><em><em> );</em></em></li>
<li><p class="startli"><em><em>-/**</em></em></p>
<p class="startli"><em><em> */</em></em></p>
</li>
<li><em><em>-/**</em></em></li>
<li><em><em>*</em></em></li>
<li><em><em>*/</em></em></li>
<li><em><em></em></em></li>
<li><em><em> SM_RESULT sm_runGUI(</em></em></li>
<li><em><em> );</em></em></li>
<li><em><em></em></em></li>
<li><em><em> SM_RESULT sm_handleGUIExpose(</em></em></li>
<li><em><em> );</em></em></li>
<li><em><em></em></em></li>
<li><em><em> void sm_handleGUIExit(</em></em></li>
<li><em><em> );</em></em></li>
<li><p class="startli"><em><em>-/**</em></em></p>
<p class="startli"><em><em> */</em></em></p>
</li>
<li><em><em>-#endif diff &ndash;git a/external/selfmake/src/lib/UI/Message.h b/external/selfmake/src/lib/UI/Message.h deleted file mode 100644 index 9fc4b52..0000000 &mdash; a/external/selfmake/src/lib/UI/Message.h +++ /dev/null @ -1,43 +0,0 @ -#ifndef SM_MESSAGE_H -#define SM_MESSAGE_H</em></em></li>
<li><em><em>-#ifndef DOXYGEN_SHOULD_SKIP_THIS</em></em></li>
<li><em><em>-/**</em></em></li>
<li><em><em>* selfmake - Script Language</em></em></li>
<li><em><em>* Copyright (C) 2021 The selfmake Authors</em></em></li>
<li><em><em>* Published under MIT</em></em></li>
<li><em><em>*/</em></em></li>
<li><em><em>-#include "../Common/Result.h" -#include "../Common/Types.h"</em></em></li>
<li><em><em>-#endif</em></em></li>
<li><em><em>-/**</em></em></li>
<li><em><em>*</em></em></li>
<li><em><em>*/</em></em></li>
<li><em><em></em></em></li>
<li><em><em> SM_RESULT sm_operationf(</em></em></li>
<li><em><em> SM_BYTE *format_p, ...</em></em></li>
<li><em><em> );</em></em></li>
<li><em><em> <br  />
</em></em></li>
<li><em><em> SM_RESULT sm_messagef(</em></em></li>
<li><em><em> SM_BYTE *format_p, ...</em></em></li>
<li><em><em> );</em></em></li>
<li><em><em></em></em></li>
<li><em><em> SM_RESULT sm_noticef(</em></em></li>
<li><em><em> SM_BYTE *format_p, ...</em></em></li>
<li><em><em> );</em></em></li>
<li><em><em></em></em></li>
<li><em><em> SM_RESULT sm_externalMessage(</em></em></li>
<li><em><em> SM_BYTE *prepend_p, SM_BYTE *message_p</em></em></li>
<li><em><em> );</em></em></li>
<li><em><em></em></em></li>
<li><em><em> SM_RESULT sm_exitMessage(</em></em></li>
<li><em><em> SM_RESULT result</em></em></li>
<li><em><em> );</em></em></li>
<li><p class="startli"><em><em>-/**</em></em></p>
<p class="startli"><em><em> */</em></em></p>
</li>
</ul>
<p ><em><em>-/** +/** </em></em></p>
</div><!-- contents -->
</div><!-- doc-content -->
  <!-- HTML footer for doxygen 1.8.15-->
  <!-- start footer part -->
  <div id="nav-path" class="navpath">
    <!--  -->
    <!-- <li class="footer">Generated by -->
    <!-- <a href="http://www.doxygen.org/index.html"> -->
    <!-- <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li> -->
    <div id="foot"> 
      <div style="color:#24bbc4;text-align:center;margin:auto;font-size:16px;">
        <b>
[
<!-- NH_MAKE_INSERT_STAGE_BEGIN -->
prototype.1
<!-- NH_MAKE_INSERT_STAGE_END -->
]
[
<!-- NH_MAKE_INSERT_API_VER_BEGIN -->
api.0.2.2.0
<!-- NH_MAKE_INSERT_API_VER_END -->
]
[
<!-- NH_MAKE_INSERT_ACC_VER_BEGIN -->
ver.0.8.23.10
<!-- NH_MAKE_INSERT_ACC_VER_END -->
]
          </b>
        </div>
      </div>
    </div>
  </body>
  <style>
    #foot {display: flex; padding-top:13px; padding-bottom:14px; background: #151515; border-top: 3px solid #24bbc4; justify-content: space-between;}
  </style>
</html>
