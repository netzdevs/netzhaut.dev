<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.9.2"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Netzhaut | Web Browser Engine | General</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="resize.js"></script>
    <script type="text/javascript" src="navtreedata.js"></script>
    <script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/searchdata.js"></script>
    <script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript">
    /* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
      $(document).ready(function() { init_search(); });
    /* @license-end */
    </script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link rel="icon" href="../../logo/favicon.png">
    <link href="../../theme/custom.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>  
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
       <div style="height: 56px;">
        <div style="left:10px;top:5px;position:absolute;">
          <b>Netzhaut</b>
          <br>
          <b>Web Browser Engine</b>
        </div>
        <div style="height:56px;right:10px;top:0px;position:absolute;background-color:#151515;"><a href="https://netzwerkz.org"><img alt="netzwerkz logo" style="height:56px;" src="../../logo/netzwerkz.png"/></a></div>
        <div id="projectlogo"><img alt="netzhaut logo" src="../../logo/netzhaut.png"/></div>
       </div>
      </div>
      <div id="titlearea">
        <div class="topnav">
          <a href="../../index.html">Home</a>
          <a href="../../guides/html/index.html">Guides</a>
          <a class="active" href="../../general/html/index.html">General</a>
          <a href="../../architecture/html/index.html">Architecture</a>
          <a href="../../design/html/index.html">Design</a>
          <a href="../../internals/html/index.html">Internals</a>
          <a href="../../api/html/index.html">API</a>
        </div>
       </div>
      </div>
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__selfmakeStructs.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Data Structures<div class="ingroups"><a class="el" href="group__selfmake.html">selfmake internal</a></div></div></div>
</div><!--header-->
<div class="contents">
<ul>
<li><p class="startli">* +/**</p>
<p class="startli">*/</p>
</li>
<li>-#endif diff &ndash;git a/external/selfmake/src/lib/Core/Configure.c b/external/selfmake/src/lib/Core/Configure.c deleted file mode 100644 index ff898c6..0000000 &mdash; a/external/selfmake/src/lib/Core/Configure.c +++ /dev/null @ -1,149 +0,0 @ -// LICENSE NOTICE ==================================================================================</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-// INCLUDE =========================================================================================</li>
<li>-#include "Runtime.h" -#include "Thread.h" -#include "File.h" -#include "../Parser/Functions.h" -#include "../Parser/Variables.h"</li>
<li>-#include "../Common/Macros/Macros.h" -#include SM_FLOW -#include SM_DEFAULT_CHECK</li>
<li>-#include &lt;stdio.h&gt; -#include &lt;string.h&gt; -#include &lt;stdlib.h&gt; -#include &lt;ctype.h&gt; -#include &lt;unistd.h&gt;</li>
<li>-// ADD =============================================================================================</li>
<li>-SM_RESULT sm_addFile(</li>
<li>sm_Runtime *Runtime_p, SM_BYTE *path_p) -{ -SM_BEGIN()</li>
<li></li>
<li>SM_CHECK_NULL(Runtime_p)</li>
<li>SM_CHECK_NULL(path_p)</li>
<li></li>
<li>SM_CHECK(sm_appendFile(&amp;Runtime_p-&gt;FileArray, path_p))</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-// SET =============================================================================================</li>
<li>-void sm_setFunctionCallback(</li>
<li>sm_Runtime *Runtime_p, sm_functionCallback_f functionCallback_f) -{ -SM_BEGIN()</li>
<li></li>
<li>Runtime_p-&gt;functionCallback_f = functionCallback_f;</li>
<li>-SM_SILENT_END() -}</li>
<li>-void sm_setSourceContextCallback(</li>
<li>sm_Runtime *Runtime_p, sm_sourceContextCallback_f sourceContextCallback_f) -{ -SM_BEGIN()</li>
<li></li>
<li>Runtime_p-&gt;sourceContextCallback_f = sourceContextCallback_f;</li>
<li>-SM_SILENT_END() -}</li>
<li>-void sm_setBeforeBuildCallback(</li>
<li>sm_Runtime *Runtime_p, sm_sourceContextCallback_f sourceContextCallback_f) -{ -SM_BEGIN()</li>
<li></li>
<li>Runtime_p-&gt;beforeBuildCallback_f = sourceContextCallback_f;</li>
<li>-SM_SILENT_END() -}</li>
<li>-void sm_setAfterBuildCallback(</li>
<li>sm_Runtime *Runtime_p, sm_sourceContextCallback_f sourceContextCallback_f) -{ -SM_BEGIN()</li>
<li></li>
<li>Runtime_p-&gt;afterBuildCallback_f = sourceContextCallback_f;</li>
<li>-SM_SILENT_END() -}</li>
<li>-sm_SourceContextArray *sm_getSourceContextArray(</li>
<li>sm_Runtime *Runtime_p) -{ -SM_BEGIN() -SM_END(&amp;Runtime_p-&gt;SourceContextArray) -}</li>
<li>-sm_SourceContext *sm_getSourceContext(</li>
<li>sm_Runtime *Runtime_p, SM_BYTE *name_p) -{ -SM_BEGIN()</li>
<li></li>
<li>for (int i = 0; i &lt; Runtime_p-&gt;SourceContextArray.length; ++i) {</li>
<li>sm_SourceContext *Context_p = &amp;Runtime_p-&gt;SourceContextArray.SourceContexts_p[i];</li>
<li>if (!strcmp(Context_p-&gt;name_p, name_p)) {SM_END(Context_p)}</li>
<li>}</li>
<li>-SM_END(NULL) -}</li>
<li>-void sm_setQuiet(</li>
<li>sm_Runtime *Runtime_p, SM_BOOL quiet) -{ -SM_BEGIN()</li>
<li></li>
<li>Runtime_p-&gt;quiet = quiet;</li>
<li>-SM_SILENT_END() -}</li>
<li>-void sm_setShowParseTree(</li>
<li>sm_Runtime *Runtime_p, SM_BOOL showParseTree) -{ -SM_BEGIN()</li>
<li></li>
<li>Runtime_p-&gt;showParseTree = showParseTree;</li>
<li>-SM_SILENT_END() -}</li>
<li>-SM_RESULT sm_setVariable(</li>
<li>sm_Runtime *Runtime_p, SM_BYTE *variable_p, SM_BYTE <b>values_pp, int valueCount) -{ -SM_BEGIN() -SM_END(sm_updateVariable(&amp;Runtime_p-&gt;VariableArray, variable_p, values_pp, valueCount)) -}</b></li>
<li><b>-sm_ValueArray sm_getVariableValues(</b></li>
<li><b> sm_Runtime *Runtime_p, SM_BYTE *variable_p) -{ -SM_BEGIN()</b></li>
<li><b></b></li>
<li><b> sm_Variable *Variable_p = sm_getVariable(&amp;Runtime_p-&gt;VariableArray, variable_p);</b></li>
<li><b></b></li>
<li><b> sm_ValueArray Values;</b></li>
<li><b> Values.values_pp = NULL;</b></li>
<li><b> Values.length = 0;</b></li>
<li><b></b></li>
<li><b> if (Variable_p) {</b></li>
<li><b> Values.values_pp = Variable_p-&gt;values_pp;</b></li>
<li><b> Values.length = Variable_p-&gt;valueCount;</b></li>
<li><b> }</b></li>
<li><b>-SM_END(Values) -}</b></li>
<li><b>diff &ndash;git a/external/selfmake/src/lib/Core/Configure.h b/external/selfmake/src/lib/Core/Configure.h deleted file mode 100644 index 8fd588d..0000000 &mdash; a/external/selfmake/src/lib/Core/Configure.h +++ /dev/null @ -1,60 +0,0 @ -#ifndef SM_RUNTIME_H -#define SM_RUNTIME_H</b></li>
<li><b>-#ifndef DOXYGEN_SHOULD_SKIP_THIS</b></li>
<li><b>-/</b></li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-#include "Source.h"</li>
<li>-#include "../Common/Result.h" -#include "../Common/Types.h"</li>
<li>-#include "../Parser/Parser.h" -#include "../Parser/Variables.h"</li>
<li>-#endif</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>typedef struct sm_Runtime {</li>
<li>SM_BOOL quiet;</li>
<li>SM_BOOL GUI;</li>
<li>SM_BOOL showParseTree;</li>
<li>SM_BYTE *name_p;</li>
<li>SM_BYTE *prefix_p;</li>
<li>SM_BYTE *projectDirectory_p;</li>
<li>sm_ParserArray ParserArray;</li>
<li>sm_SourceArray SourceArray;</li>
<li>sm_SourceContextArray SourceContextArray;</li>
<li>sm_VariableArray VariableArray;</li>
<li>sm_FileArray FileArray;</li>
<li>} sm_Runtime;</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
<li>-#endif diff &ndash;git a/external/selfmake/src/lib/Core/File.c b/external/selfmake/src/lib/Core/File.c deleted file mode 100644 index 805db9a..0000000 &mdash; a/external/selfmake/src/lib/Core/File.c +++ /dev/null @ -1,199 +0,0 @ -// LICENSE NOTICE ==================================================================================</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-// INCLUDE =========================================================================================</li>
<li>-#include "File.h" -#include "Utils.h"</li>
<li>-#include "../UI/Message.h" -#include "../Common/Macros/Macros.h"</li>
<li>-#include SM_FLOW -#include SM_DEFAULT_CHECK</li>
<li>-#include &lt;unistd.h&gt; -#include &lt;string.h&gt; -#include &lt;stdlib.h&gt; -#include &lt;dlfcn.h&gt; -#include &lt;stdio.h&gt; -#include &lt;pwd.h&gt;</li>
<li>-#if defined(<b>linux</b>) || defined(<b>APPLE</b>)</li>
<li>#include &lt;sys/stat.h&gt;</li>
<li>#include &lt;sys/types.h&gt; -#endif</li>
<li>-// FILE ============================================================================================</li>
<li>-SM_BOOL sm_canFindSharedLib(</li>
<li>const SM_BYTE *lib_p) -{ -SM_BEGIN()</li>
<li></li>
<li>SM_BYTE path_p[1024] = {'\0'};</li>
<li>sprintf(path_p, "/usr/lib/lib%s.so", lib_p);</li>
<li></li>
<li>if(access(path_p, F_OK) != -1) {SM_DIAGNOSTIC_END(SM_TRUE)}</li>
<li>-SM_DIAGNOSTIC_END(SM_FALSE) -}</li>
<li>-SM_RESULT sm_copy(</li>
<li>sm_VariableArray *Array_p, SM_BYTE *in_p, SM_BYTE *out_p, SM_BOOL recursive, SM_BOOL sudo) -{ -SM_BEGIN()</li>
<li></li>
<li>SM_BYTE realin_p[1024] = {'\0'}, realout_p[1024] = {'\0'};</li>
<li>realpath(out_p, realout_p);</li>
<li>realpath(in_p, realin_p);</li>
<li>sm_messagef(sudo ? "COPY %s TO %s \e[1;31mSUDO PREPENDED\e[0m" : "COPY %s TO %s", realin_p, realout_p);</li>
<li></li>
<li>if (!sm_canRunCommand("cp")) {SM_DIAGNOSTIC_END(SM_ERROR_CP_NOT_FOUND)}</li>
<li>-#if defined(<b>linux</b>) || defined(<b>APPLE</b>)</li>
<li></li>
<li>SM_BYTE command_p[32] = {'\0'};</li>
<li>sprintf(command_p, sudo ? "sudo cp" : "cp");</li>
<li>SM_BYTE fullCommand_p[1024] = {'\0'};</li>
<li></li>
<li>if (out_p[0] != '/') {</li>
<li>sprintf(fullCommand_p, recursive ? "%s -rp %s %s" : "%s -p %s %s", command_p, in_p, out_p);</li>
<li>}</li>
<li>else {</li>
<li>sprintf(fullCommand_p, recursive ? "%s -rp %s %s" : "%s -p %s %s", command_p, in_p, out_p);</li>
<li>}</li>
<li></li>
<li>int status = system(fullCommand_p);</li>
<li>if (WEXITSTATUS(status) || WIFSIGNALED(status)) {SM_DIAGNOSTIC_END(SM_ERROR_CP_EXECUTION_FAILED)}</li>
<li>-#elif defined(WIN_32)</li>
<li>-#endif</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-SM_RESULT sm_createSymLink(</li>
<li>SM_BYTE *filePath_p, SM_BYTE *symLinkPath_p, SM_BOOL sudo) -{ -SM_BEGIN()</li>
<li>-#if defined(<b>linux</b>) || defined(<b>APPLE</b>)</li>
<li></li>
<li>if (!sm_canRunCommand("ln")) {SM_DIAGNOSTIC_END(SM_ERROR_CP_NOT_FOUND)}</li>
<li></li>
<li>SM_BYTE command_p[64] = {'\0'};</li>
<li>sprintf(command_p, sudo ? "sudo ln -s" : "ln -s");</li>
<li></li>
<li>SM_BYTE fullCommand_p[1024] = {'\0'};</li>
<li>sprintf(fullCommand_p, "%s %s %s", command_p, filePath_p, symLinkPath_p);</li>
<li></li>
<li>int status = system(fullCommand_p);</li>
<li>if (WEXITSTATUS(status) || WIFSIGNALED(status)) {SM_DIAGNOSTIC_END(SM_ERROR_CP_EXECUTION_FAILED)}</li>
<li>-#elif defined(WIN_32)</li>
<li>-#endif</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-SM_BOOL sm_fileExists(</li>
<li>SM_BYTE *filename_p) -{ -SM_BEGIN() -SM_END(access(filename_p, F_OK) != -1 ? SM_TRUE : SM_FALSE) -}</li>
<li>-SM_RESULT sm_writeBytesToFile(</li>
<li>SM_BYTE *filename_p, SM_BYTE *bytes_p) -{ -SM_BEGIN()</li>
<li></li>
<li>SM_CHECK_NULL(bytes_p)</li>
<li>SM_CHECK_NULL(filename_p)</li>
<li></li>
<li>FILE *f = fopen(filename_p, "w");</li>
<li>SM_CHECK_NULL(f) <br  />
</li>
<li><br  />
</li>
<li>fprintf(f, "%s\n", bytes_p);</li>
<li>fclose(f);</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-// FILE ARRAY ======================================================================================</li>
<li>-SM_BYTE <em>sm_getFileData(</em></li>
<li><em> const SM_BYTE</em> path_p, long *size_p) -{ -SM_BEGIN()</li>
<li></li>
<li>FILE *fh = fopen(path_p, "rb");</li>
<li>if (fh == NULL) {SM_END(NULL)}</li>
<li><br  />
</li>
<li>if (fseek(fh, 0, SEEK_END) != 0) {SM_END(NULL)}</li>
<li>long size = ftell(fh);</li>
<li>rewind(fh);</li>
<li></li>
<li>if(size &lt;= 0) {</li>
<li>fclose(fh);</li>
<li>SM_END(NULL)</li>
<li>}</li>
<li></li>
<li>SM_BYTE *data_p = malloc(size + 1);</li>
<li>if (data_p == NULL) {SM_END(NULL)}</li>
<li><br  />
</li>
<li>fread(data_p, 1, size, fh);</li>
<li>fclose(fh);</li>
<li></li>
<li>data_p[size] = 0;</li>
<li>if (size_p != NULL) {*size_p = size;}</li>
<li>-SM_END(data_p) -}</li>
<li>-void sm_initFileArray(</li>
<li>sm_FileArray *Array_p) -{ -SM_BEGIN()</li>
<li></li>
<li>Array_p-&gt;length = 0;</li>
<li>Array_p-&gt;Files_p = NULL;</li>
<li>-SM_SILENT_END() -}</li>
<li>-SM_RESULT sm_appendFile(</li>
<li>sm_FileArray *Array_p, SM_BYTE *path_p) -{ -SM_BEGIN()</li>
<li></li>
<li>SM_BYTE *data_p = sm_getFileData(path_p, NULL);</li>
<li>SM_CHECK_NULL(data_p)</li>
<li></li>
<li>if (!Array_p-&gt;length) {</li>
<li>Array_p-&gt;Files_p = malloc(sizeof(sm_File));</li>
<li>SM_CHECK_NULL(Array_p-&gt;Files_p) <br  />
</li>
<li>}</li>
<li>else {</li>
<li>Array_p-&gt;Files_p = realloc(Array_p-&gt;Files_p, sizeof(sm_File) * (Array_p-&gt;length + 1));</li>
<li>SM_CHECK_NULL(Array_p-&gt;Files_p) <br  />
</li>
<li>}</li>
<li></li>
<li>Array_p-&gt;Files_p[Array_p-&gt;length].data_p = data_p;</li>
<li>Array_p-&gt;Files_p[Array_p-&gt;length].path_p = malloc(strlen(path_p) + 1);</li>
<li>SM_CHECK_NULL(Array_p-&gt;Files_p[Array_p-&gt;length].path_p)</li>
<li>strcpy(Array_p-&gt;Files_p[Array_p-&gt;length].path_p, path_p);</li>
<li></li>
<li>Array_p-&gt;length++;</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>diff &ndash;git a/external/selfmake/src/lib/Core/File.h b/external/selfmake/src/lib/Core/File.h deleted file mode 100644 index b5f04e0..0000000 &mdash; a/external/selfmake/src/lib/Core/File.h +++ /dev/null @ -1,67 +0,0 @ -#ifndef SM_FILE_H -#define SM_FILE_H</li>
<li>-#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-#include "../Parser/Variables.h"</li>
<li>-#include "../Common/Result.h" -#include "../Common/Types.h"</li>
<li>-#include &lt;stddef.h&gt;</li>
<li>-#endif</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>typedef struct sm_File {</li>
<li>SM_BYTE *path_p;</li>
<li>SM_BYTE *data_p;</li>
<li>} sm_File;</li>
<li></li>
<li>typedef struct sm_FileArray {</li>
<li>int length;</li>
<li>sm_File *Files_p;</li>
<li>} sm_FileArray;</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
<li>-#endif diff &ndash;git a/external/selfmake/src/lib/Core/Runtime.c b/external/selfmake/src/lib/Core/Runtime.c deleted file mode 100644 index 57830f5..0000000 &mdash; a/external/selfmake/src/lib/Core/Runtime.c +++ /dev/null @ -1,267 +0,0 @ -// LICENSE NOTICE ==================================================================================</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-// INCLUDE =========================================================================================</li>
<li>-#include "Runtime.h" -#include "Thread.h" -#include "File.h" -#include "Build.h" -#include "Options.h"</li>
<li>-#include "../Parser/Functions.h" -#include "../Parser/Variables.h"</li>
<li>-#include "../Common/Functions.h" -#include "../Common/Macros/Macros.h" -#include SM_FLOW -#include SM_DEFAULT_CHECK</li>
<li>-#include &lt;stdio.h&gt; -#include &lt;string.h&gt; -#include &lt;stdlib.h&gt; -#include &lt;ctype.h&gt;</li>
<li>-// VARS ============================================================================================</li>
<li>-sm_Runtime SM_DEFAULT_RUNTIME;</li>
<li>-// HELPER ==========================================================================================</li>
<li>-SM_BYTE *sm_getSourceContextName(</li>
<li>sm_Runtime *Runtime_p, sm_SourceContext *SourceContext_p) -{ -SM_BEGIN()</li>
<li></li>
<li>sm_Variable *Prefix_p = sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "PREFIX");</li>
<li></li>
<li>if (!Prefix_p) {</li>
<li>SM_END(SourceContext_p-&gt;name_p)</li>
<li>}</li>
<li></li>
<li>int offset = 0;</li>
<li>for (int i = 0; i &lt; strlen(Prefix_p-&gt;values_pp[0]) &amp;&amp; i &lt; strlen(SourceContext_p-&gt;name_p); ++i) {</li>
<li>if (Prefix_p-&gt;values_pp[0][i] != SourceContext_p-&gt;name_p[i]) {</li>
<li>break;</li>
<li>}</li>
<li>offset++;</li>
<li>}</li>
<li>-SM_END(SourceContext_p-&gt;name_p + offset) -}</li>
<li>-// PARSE ===========================================================================================</li>
<li>-static SM_RESULT sm_parseArguments(</li>
<li>sm_Runtime *Runtime_p, int argc, SM_BYTE **argv_pp) -{ -SM_BEGIN()</li>
<li></li>
<li>for (int i = 0; i &lt; argc; ++i) {</li>
<li>int advance = 0;</li>
<li>SM_CHECK(sm_parseOption(Runtime_p, argc - i, &amp;argv_pp[i], &amp;advance))</li>
<li>i += advance - 1;</li>
<li>}</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-// RUN =============================================================================================</li>
<li>-SM_BYTE **sm_processArguments(</li>
<li>sm_VariableArray *Variables_p, SM_BYTE **args_pp, int args, int *processedArgCount_p) -{ -SM_BEGIN()</li>
<li>-#include SM_CUSTOM_CHECK</li>
<li></li>
<li>int processedArgCount = 0;</li>
<li>SM_BYTE **processedArgs_pp = malloc(sizeof(SM_BYTE));</li>
<li>SM_CHECK_NULL(NULL, processedArgs_pp) <br  />
</li>
<li></li>
<li>for (int i = 0; i &lt; args; ++i)</li>
<li>{</li>
<li>sm_Variable <em>Variable_p = sm_getVariable(Variables_p, args_pp[i]);</em></li>
<li><em> if (Variable_p) {</em></li>
<li><em> for (int j = 0; j &lt; Variable_p-&gt;valueCount; ++j) {</em></li>
<li><em> processedArgs_pp[processedArgCount] = malloc(strlen(Variable_p-&gt;values_pp[j]) + 1);</em></li>
<li><em> SM_CHECK_NULL(NULL, processedArgs_pp[processedArgCount])</em></li>
<li><em> strcpy(processedArgs_pp[processedArgCount++], Variable_p-&gt;values_pp[j]);</em></li>
<li><em> processedArgs_pp = realloc(processedArgs_pp, sizeof(SM_BYTE</em>) * (processedArgCount + 1));</li>
<li>SM_CHECK_NULL(NULL, processedArgs_pp)</li>
<li>}</li>
<li>}</li>
<li>else {</li>
<li>processedArgs_pp[processedArgCount] = malloc(strlen(args_pp[i]) + 1);</li>
<li>SM_CHECK_NULL(NULL, processedArgs_pp[processedArgCount])</li>
<li>strcpy(processedArgs_pp[processedArgCount++], args_pp[i]);</li>
<li>processedArgs_pp = realloc(processedArgs_pp, sizeof(SM_BYTE*) * (processedArgCount + 1));</li>
<li>SM_CHECK_NULL(NULL, processedArgs_pp)</li>
<li>}</li>
<li>}</li>
<li>-#include SM_DEFAULT_CHECK</li>
<li></li>
<li>*processedArgCount_p = processedArgCount;</li>
<li>-SM_END(processedArgs_pp) -}</li>
<li>-static SM_RESULT sm_executeGlobalFunctions(</li>
<li>sm_Runtime *Runtime_p, sm_Parser *Parser_p) -{ -SM_BEGIN()</li>
<li></li>
<li>if (Parser_p-&gt;executed) {SM_END(SM_SUCCESS)}</li>
<li></li>
<li>sm_Block Block;</li>
<li>Block.definitions = Parser_p-&gt;definitions;</li>
<li>Block.Definitions_p = Parser_p-&gt;Definitions_p;</li>
<li></li>
<li>SM_CHECK(sm_executeBlock(Runtime_p, &amp;Block))</li>
<li></li>
<li>Parser_p-&gt;executed = SM_TRUE;</li>
<li>-SM_END(SM_SUCCESS) -}</li>
<li>-SM_RESULT sm_executeRuntime(</li>
<li>sm_Runtime *Runtime_p, SM_BYTE <b>args_pp, int args) -{ -SM_BEGIN()</b></li>
<li><b></b></li>
<li><b> for (int i = 0; i &lt; Runtime_p-&gt;FileArray.length; ++i)</b></li>
<li><b> {</b></li>
<li><b> SM_CHECK(sm_appendParser(</b></li>
<li><b> &amp;Runtime_p-&gt;ParserArray, &amp;Runtime_p-&gt;FileArray.Files_p[i], Runtime_p-&gt;showParseTree</b></li>
<li><b> ))</b></li>
<li><b></b></li>
<li><b> sm_operationf("Execute Global Functions");</b></li>
<li><b> sm_Parser *Parser_p = &amp;Runtime_p-&gt;ParserArray.Parsers_p[Runtime_p-&gt;ParserArray.length - 1];</b></li>
<li><b></b></li>
<li><b> if (Parser_p-&gt;executed) {continue;}</b></li>
<li><b> SM_CHECK(sm_executeGlobalFunctions(Runtime_p, Parser_p))</b></li>
<li><b> Parser_p-&gt;executed = SM_TRUE;</b></li>
<li><b></b></li>
<li><b> sm_Variable *All_p = sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "ALL");</b></li>
<li><b> for (int j = 0; All_p &amp;&amp; j &lt; All_p-&gt;valueCount; ++j) {</b></li>
<li><b> SM_CHECK(sm_addBuildOption(Runtime_p, All_p-&gt;values_pp[j]))</b></li>
<li><b> SM_CHECK(sm_addTestOption(Runtime_p, All_p-&gt;values_pp[j]))</b></li>
<li><b> }</b></li>
<li><b> }</b></li>
<li><b> <br  />
</b></li>
<li><b> int processedArgs = 0;</b></li>
<li><b> SM_BYTE **processedArgs_pp = sm_processArguments(&amp;Runtime_p-&gt;VariableArray, args_pp, args, &amp;processedArgs);</b></li>
<li><b> SM_CHECK_NULL(processedArgs_pp)</b></li>
<li><b></b></li>
<li><b> SM_RESULT result = sm_parseArguments(Runtime_p, processedArgs, processedArgs_pp);</b></li>
<li><b></b></li>
<li><b> for (int i = 0; i &lt; processedArgs; ++i) {</b></li>
<li><b> free(processedArgs_pp[i]);</b></li>
<li><b> }</b></li>
<li><b> free(processedArgs_pp);</b></li>
<li><b></b></li>
<li><b> SM_CHECK(sm_exitMessage(result))</b></li>
<li><b>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</b></li>
<li><b>-SM_RESULT sm_run(</b></li>
<li><b> sm_Runtime *Runtime_p, int argc, SM_BYTE **argv_pp) -{ -SM_BEGIN() -SM_DIAGNOSTIC_END(sm_runThread(Runtime_p, argv_pp, argc)) -}</b></li>
<li><b>-// CREATE ==========================================================================================</b></li>
<li><b>-static SM_RESULT sm_initRuntime(</b></li>
<li><b> sm_Runtime *Runtime_p) -{ -SM_BEGIN()</b></li>
<li><b></b></li>
<li><b> Runtime_p-&gt;showParseTree = SM_TRUE;</b></li>
<li><b> Runtime_p-&gt;GUI = SM_FALSE;</b></li>
<li><b> Runtime_p-&gt;quiet = SM_FALSE;</b></li>
<li><b></b></li>
<li><b> Runtime_p-&gt;functionCallback_f = NULL;</b></li>
<li><b> Runtime_p-&gt;sourceContextCallback_f = NULL;</b></li>
<li><b> Runtime_p-&gt;beforeBuildCallback_f = NULL;</b></li>
<li><b> Runtime_p-&gt;afterBuildCallback_f = NULL;</b></li>
<li><b></b></li>
<li><b> sm_initFileArray(&amp;Runtime_p-&gt;FileArray);</b></li>
<li><b> sm_initParserArray(&amp;Runtime_p-&gt;ParserArray);</b></li>
<li><b> sm_initTestArray(&amp;Runtime_p-&gt;TestArray);</b></li>
<li><b> sm_initSourceArray(&amp;Runtime_p-&gt;SourceArray);</b></li>
<li><b> sm_initSourceContextArray(&amp;Runtime_p-&gt;SourceContextArray);</b></li>
<li><b> sm_initVariableArray(&amp;Runtime_p-&gt;VariableArray);</b></li>
<li><b></b></li>
<li><b> SM_BYTE *wrk_p = sm_getWorkDirectory();</b></li>
<li><b></b></li>
<li><b> sm_updateVariable(&amp;Runtime_p-&gt;VariableArray, "WRK_DIR", &amp;wrk_p, 1);</b></li>
<li><b> sm_updateVariable(&amp;Runtime_p-&gt;VariableArray, "PROJ_DIR", &amp;wrk_p, 1);</b></li>
<li><b> sm_updateVariable(&amp;Runtime_p-&gt;VariableArray, "LIB_DEST", &amp;wrk_p, 1);</b></li>
<li><b> sm_updateVariable(&amp;Runtime_p-&gt;VariableArray, "BIN_DEST", &amp;wrk_p, 1);</b></li>
<li><b></b></li>
<li><b> SM_BYTE *true_p = "true";</b></li>
<li><b>-#ifdef <b>APPLE</b></b></li>
<li><b> sm_updateVariable(&amp;Runtime_p-&gt;VariableArray, "MAC", &amp;true_p, 1); -#elif WIN32</b></li>
<li><b> sm_updateVariable(&amp;Runtime_p-&gt;VariableArray, "WINDOWS", &amp;true_p, 1); -#elif <b>linux</b></b></li>
<li><b> sm_updateVariable(&amp;Runtime_p-&gt;VariableArray, "LINUX", &amp;true_p, 1); -#endif</b></li>
<li><b>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</b></li>
<li><b>-sm_Runtime *sm_createRuntime(</b></li>
<li><b> SM_BYTE *name_p) -{ -SM_BEGIN()</b></li>
<li><b>-#include SM_CUSTOM_CHECK</b></li>
<li><b></b></li>
<li><b> SM_CHECK_NULL(NULL, name_p)</b></li>
<li><b></b></li>
<li><b> sm_Runtime *Runtime_p = malloc(sizeof(sm_Runtime));</b></li>
<li><b> SM_CHECK_NULL(NULL, Runtime_p)</b></li>
<li><b></b></li>
<li><b> SM_CHECK(NULL, sm_initRuntime(Runtime_p))</b></li>
<li><b></b></li>
<li><b> sm_updateVariable(&amp;Runtime_p-&gt;VariableArray, "NAME", &amp;name_p, 1);</b></li>
<li><b>-#include SM_DEFAULT_CHECK</b></li>
<li><b>-SM_END(Runtime_p) -}</b></li>
<li><b>-void sm_destroyRuntime(</b></li>
<li><b> sm_Runtime *Runtime_p) -{ -SM_BEGIN() -SM_SILENT_END() -}</b></li>
<li><b>-// INITIALIZE/TERMINATE ============================================================================</b></li>
<li><b>-SM_RESULT sm_initialize() -{</b></li>
<li><b> sm_initThreadPool();</b></li>
<li><b> SM_CHECK(sm_initRuntime(&amp;SM_DEFAULT_RUNTIME))</b></li>
<li><b> SM_BYTE *name_p = "selfmake";</b></li>
<li><b> sm_updateVariable(&amp;SM_DEFAULT_RUNTIME.VariableArray, "NAME", &amp;name_p, 1); -}</b></li>
<li><b>-void sm_terminate() -{ -SM_BEGIN() -SM_SILENT_END() -}</b></li>
<li><b>diff &ndash;git a/external/selfmake/src/lib/Core/Runtime.h b/external/selfmake/src/lib/Core/Runtime.h deleted file mode 100644 index 5c9efd8..0000000 &mdash; a/external/selfmake/src/lib/Core/Runtime.h +++ /dev/null @ -1,65 +0,0 @ -#ifndef SM_RUNTIME_H -#define SM_RUNTIME_H</b></li>
<li><b>-#ifndef DOXYGEN_SHOULD_SKIP_THIS</b></li>
<li><b>-/</b></li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-#include "Source.h"</li>
<li>-#include "../Common/Result.h" -#include "../Common/Types.h"</li>
<li>-#include "../Parser/Parser.h" -#include "../Parser/Variables.h"</li>
<li>-#include "../Test/Test.h"</li>
<li>-#endif</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>typedef struct sm_Runtime {</li>
<li>SM_BOOL quiet;</li>
<li>SM_BOOL GUI;</li>
<li>SM_BOOL showParseTree;</li>
<li>SM_BYTE *prefix_p;</li>
<li>sm_ParserArray ParserArray;</li>
<li>sm_SourceArray SourceArray;</li>
<li>sm_TestArray TestArray;</li>
<li>sm_SourceContextArray SourceContextArray;</li>
<li>sm_VariableArray VariableArray;</li>
<li>sm_FileArray FileArray;</li>
<li>sm_functionCallback_f functionCallback_f;</li>
<li>sm_sourceContextCallback_f sourceContextCallback_f;</li>
<li>sm_sourceContextCallback_f beforeBuildCallback_f;</li>
<li>sm_sourceContextCallback_f afterBuildCallback_f;</li>
<li>} sm_Runtime;</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
<li>-#endif diff &ndash;git a/external/selfmake/src/lib/Core/Source.c b/external/selfmake/src/lib/Core/Source.c deleted file mode 100644 index 5987e77..0000000 &mdash; a/external/selfmake/src/lib/Core/Source.c +++ /dev/null @ -1,317 +0,0 @ -// LICENSE NOTICE ==================================================================================</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-// INCLUDE =========================================================================================</li>
<li>-#include "Source.h" -#include "Runtime.h"</li>
<li>-#include "../Common/Macros/Macros.h" -#include SM_FLOW -#include SM_DEFAULT_CHECK</li>
<li>-#include &lt;stdio.h&gt; -#include &lt;stdlib.h&gt; -#include &lt;string.h&gt; -#include &lt;unistd.h&gt; -#include &lt;ctype.h&gt;</li>
<li>-// INIT ============================================================================================</li>
<li>-void sm_initSourceContextArray(</li>
<li>sm_SourceContextArray *Array_p) -{ -SM_BEGIN()</li>
<li></li>
<li>Array_p-&gt;length = 0;</li>
<li>Array_p-&gt;maxNameLength = 0;</li>
<li>Array_p-&gt;SourceContexts_p = NULL;</li>
<li>-SM_SILENT_END() -}</li>
<li>-static sm_SourceContext sm_initSourceContext(</li>
<li>SM_SOURCE_CONTEXT type) -{ -SM_BEGIN()</li>
<li></li>
<li>sm_SourceContext SourceContext;</li>
<li></li>
<li>SourceContext.type = type;</li>
<li>SourceContext.path_p = NULL;</li>
<li>SourceContext.compileArgs_p = NULL;</li>
<li>SourceContext.linkArgs_p = NULL;</li>
<li>SourceContext.api = 0;</li>
<li>SourceContext.major = 0;</li>
<li>SourceContext.minor = 0;</li>
<li>SourceContext.patch = 0;</li>
<li>SourceContext.outputPath_p = NULL;</li>
<li>memset(SourceContext.apiDate_p, 0, sizeof(long) * 3);</li>
<li>memset(SourceContext.majorDate_p, 0, sizeof(long) * 3);</li>
<li>memset(SourceContext.minorDate_p, 0, sizeof(long) * 3);</li>
<li>memset(SourceContext.patchDate_p, 0, sizeof(long) * 3);</li>
<li>-SM_END(SourceContext) -}</li>
<li>-void sm_initSourceArray(</li>
<li>sm_SourceArray *Array_p) -{ -SM_BEGIN()</li>
<li></li>
<li>Array_p-&gt;length = 0;</li>
<li>Array_p-&gt;Sources_p = NULL;</li>
<li>-SM_SILENT_END() -}</li>
<li>-static sm_Source sm_initSource() -{ -SM_BEGIN()</li>
<li></li>
<li>sm_Source Source;</li>
<li>Source.Context_p = NULL;</li>
<li>Source.path_p = NULL;</li>
<li>-SM_END(Source) -}</li>
<li>-// INDENT ==========================================================================================</li>
<li>-void sm_getIndentAfterSourceContext(</li>
<li>SM_BYTE *name_p, SM_BYTE *buffer_p, int size, sm_SourceContextArray *Array_p) -{ -SM_BEGIN()</li>
<li></li>
<li>memset(buffer_p, 0, size);</li>
<li>int diff = Array_p-&gt;maxNameLength - strlen(name_p);</li>
<li>for (int i = 0; i &lt; diff; ++i) {buffer_p[i] = ' ';}</li>
<li>-SM_SILENT_END() -}</li>
<li>-// ADD =============================================================================================</li>
<li>-static SM_BOOL sm_matchSourceContext(</li>
<li>sm_SourceContext *SourceContext_p, SM_SOURCE_CONTEXT type) -{ -SM_BEGIN()</li>
<li></li>
<li>if (type != SM_SOURCE_CONTEXT_UNDEFINED) {</li>
<li>if (type == SM_SOURCE_CONTEXT_BINARY &amp;&amp; SourceContext_p-&gt;type != SM_SOURCE_CONTEXT_BINARY) {</li>
<li>SM_END(SM_FALSE)</li>
<li>}</li>
<li>if ((type == SM_SOURCE_CONTEXT_SHARED_LIBRARY || type == SM_SOURCE_CONTEXT_STATIC_LIBRARY) &amp;&amp; SourceContext_p-&gt;type == SM_SOURCE_CONTEXT_BINARY) {</li>
<li>SM_END(SM_FALSE)</li>
<li>}</li>
<li>}</li>
<li>-SM_END(SM_TRUE) -}</li>
<li>-SM_RESULT sm_addSourceContext(</li>
<li>sm_Runtime *Runtime_p, sm_Function *Function_p, SM_SOURCE_CONTEXT type, int offset) -{ -SM_BEGIN()</li>
<li></li>
<li>sm_SourceContextArray *Array_p = &amp;Runtime_p-&gt;SourceContextArray;</li>
<li></li>
<li>if (Function_p-&gt;arguments &lt; 1) {SM_DIAGNOSTIC_END(SM_ERROR_BAD_STATE)}</li>
<li></li>
<li>if (!Array_p-&gt;SourceContexts_p) {</li>
<li>Array_p-&gt;SourceContexts_p = malloc(sizeof(sm_SourceContext));</li>
<li>SM_CHECK_NULL(Array_p-&gt;SourceContexts_p)</li>
<li>}</li>
<li>else {</li>
<li>Array_p-&gt;SourceContexts_p = realloc(Array_p-&gt;SourceContexts_p, sizeof(sm_SourceContext) * (Array_p-&gt;length + 1));</li>
<li>SM_CHECK_NULL(Array_p-&gt;SourceContexts_p)</li>
<li>}</li>
<li></li>
<li>sm_SourceContext *SourceContext_p = &amp;Array_p-&gt;SourceContexts_p[Array_p-&gt;length];</li>
<li>*SourceContext_p = sm_initSourceContext(type);</li>
<li></li>
<li>int index = offset;</li>
<li></li>
<li>SourceContext_p-&gt;name_p = malloc(strlen(Function_p-&gt;arguments_pp[index]) + 1);</li>
<li>SM_CHECK_NULL(SourceContext_p-&gt;name_p)</li>
<li>strcpy(SourceContext_p-&gt;name_p, Function_p-&gt;arguments_pp[index++]);</li>
<li></li>
<li>if (Function_p-&gt;arguments &gt; index) {</li>
<li>SourceContext_p-&gt;path_p = malloc(strlen(Function_p-&gt;arguments_pp[index]) + 1);</li>
<li>SM_CHECK_NULL(SourceContext_p-&gt;path_p)</li>
<li>strcpy(SourceContext_p-&gt;path_p, Function_p-&gt;arguments_pp[index++]);</li>
<li>}</li>
<li></li>
<li>if (Function_p-&gt;arguments &gt; index) {</li>
<li>SourceContext_p-&gt;outputPath_p = malloc(strlen(Function_p-&gt;arguments_pp[index]) + 1);</li>
<li>SM_CHECK_NULL(SourceContext_p-&gt;outputPath_p)</li>
<li>strcpy(SourceContext_p-&gt;outputPath_p, Function_p-&gt;arguments_pp[index++]);</li>
<li>}</li>
<li></li>
<li>if (Function_p-&gt;arguments &gt; index) {</li>
<li>SourceContext_p-&gt;major = strtol(Function_p-&gt;arguments_pp[index++], NULL, 10);</li>
<li>}</li>
<li></li>
<li>if (Function_p-&gt;arguments &gt; index) {</li>
<li>SourceContext_p-&gt;minor = strtol(Function_p-&gt;arguments_pp[index++], NULL, 10);</li>
<li>}</li>
<li></li>
<li>if (Function_p-&gt;arguments &gt; index) {</li>
<li>SourceContext_p-&gt;patch = strtol(Function_p-&gt;arguments_pp[index++], NULL, 10);</li>
<li>}</li>
<li></li>
<li>if (strlen(SourceContext_p-&gt;name_p) &gt; Array_p-&gt;maxNameLength) {</li>
<li>Array_p-&gt;maxNameLength = strlen(SourceContext_p-&gt;name_p);</li>
<li>}</li>
<li></li>
<li>Array_p-&gt;length++;</li>
<li></li>
<li>SM_CHECK(sm_appendToVariable(&amp;Runtime_p-&gt;VariableArray, "ALL", &amp;Function_p-&gt;arguments_pp[offset], 1))</li>
<li></li>
<li>if (type == SM_SOURCE_CONTEXT_BINARY) {</li>
<li>SM_CHECK(sm_appendToVariable(&amp;Runtime_p-&gt;VariableArray, "BINS", &amp;Function_p-&gt;arguments_pp[offset], 1))</li>
<li>}</li>
<li>else {</li>
<li>SM_CHECK(sm_appendToVariable(&amp;Runtime_p-&gt;VariableArray, "LIBS", &amp;Function_p-&gt;arguments_pp[offset], 1))</li>
<li>}</li>
<li></li>
<li>switch (type)</li>
<li>{</li>
<li>case SM_SOURCE_CONTEXT_BINARY :</li>
<li>sm_messagef("Add binary [%s]", SourceContext_p-&gt;name_p);</li>
<li>break;</li>
<li>case SM_SOURCE_CONTEXT_SHARED_LIBRARY :</li>
<li>sm_messagef("Add shared library [%s]", SourceContext_p-&gt;name_p);</li>
<li>break;</li>
<li>case SM_SOURCE_CONTEXT_STATIC_LIBRARY :</li>
<li>sm_messagef("Add static library [%s]", SourceContext_p-&gt;name_p);</li>
<li>break;</li>
<li>}</li>
<li>-SM_END(SM_SUCCESS) -}</li>
<li>-// ARGUMENTS =======================================================================================</li>
<li>-SM_RESULT sm_addCompileArguments(</li>
<li>sm_SourceContextArray *ContextArray_p, sm_Function *Function_p, SM_SOURCE_CONTEXT type) -{ -SM_BEGIN()</li>
<li></li>
<li>if (Function_p-&gt;arguments &lt; 2) {SM_DIAGNOSTIC_END(SM_ERROR_BAD_STATE)}</li>
<li></li>
<li>sm_SourceContext *Context_p = NULL;</li>
<li>for (int j = 0; j &lt; ContextArray_p-&gt;length; ++j) {</li>
<li>if (!sm_matchSourceContext(ContextArray_p-&gt;SourceContexts_p+j, type)) {</li>
<li>continue;</li>
<li>}</li>
<li>if (!strcmp(ContextArray_p-&gt;SourceContexts_p[j].name_p, Function_p-&gt;arguments_pp[0])) {</li>
<li>Context_p = &amp;ContextArray_p-&gt;SourceContexts_p[j];</li>
<li>}</li>
<li>}</li>
<li></li>
<li>if (!Context_p) {SM_DIAGNOSTIC_END(SM_ERROR_LIBRARY_NOT_FOUND)}</li>
<li></li>
<li>Context_p-&gt;compileArgs_p = malloc(strlen(Function_p-&gt;arguments_pp[1]) + 1);</li>
<li>SM_CHECK_NULL(Context_p-&gt;compileArgs_p)</li>
<li>sprintf(Context_p-&gt;compileArgs_p, Function_p-&gt;arguments_pp[1]);</li>
<li></li>
<li>SM_BYTE offset_p[64];</li>
<li>sm_getIndentAfterSourceContext(Context_p-&gt;name_p, offset_p, 64, ContextArray_p);</li>
<li>sm_messagef("[%s]%s Set compile arguments \"%s\"", Context_p-&gt;name_p, offset_p, Context_p-&gt;compileArgs_p);</li>
<li>-SM_END(SM_SUCCESS) -}</li>
<li>-SM_RESULT sm_addLinkArguments(</li>
<li>sm_SourceContextArray *ContextArray_p, sm_Function *Function_p, SM_SOURCE_CONTEXT type) -{ -SM_BEGIN()</li>
<li></li>
<li>if (Function_p-&gt;arguments != 2) {SM_DIAGNOSTIC_END(SM_ERROR_BAD_STATE)}</li>
<li></li>
<li>sm_SourceContext *Context_p = NULL;</li>
<li>for (int j = 0; j &lt; ContextArray_p-&gt;length; ++j) {</li>
<li>if (!sm_matchSourceContext(ContextArray_p-&gt;SourceContexts_p+j, type)) {</li>
<li>continue;</li>
<li>}</li>
<li>if (!strcmp(ContextArray_p-&gt;SourceContexts_p[j].name_p, Function_p-&gt;arguments_pp[0])) {</li>
<li>Context_p = &amp;ContextArray_p-&gt;SourceContexts_p[j];</li>
<li>}</li>
<li>}</li>
<li></li>
<li>if (!Context_p) {SM_DIAGNOSTIC_END(SM_ERROR_LIBRARY_NOT_FOUND)}</li>
<li></li>
<li>Context_p-&gt;linkArgs_p = malloc(strlen(Function_p-&gt;arguments_pp[1]) + 1);</li>
<li>SM_CHECK_NULL(Context_p-&gt;linkArgs_p)</li>
<li>sprintf(Context_p-&gt;linkArgs_p, Function_p-&gt;arguments_pp[1]);</li>
<li></li>
<li>SM_BYTE offset_p[64];</li>
<li>sm_getIndentAfterSourceContext(Context_p-&gt;name_p, offset_p, 64, ContextArray_p);</li>
<li>sm_messagef("[%s]%s Set link arguments \"%s\"", Context_p-&gt;name_p, offset_p, Context_p-&gt;linkArgs_p);</li>
<li>-SM_END(SM_SUCCESS) -}</li>
<li>-// SOURCES =========================================================================================</li>
<li>-SM_RESULT sm_addSource(</li>
<li>sm_SourceContextArray *ContextArray_p, sm_SourceArray *SourceArray_p, sm_Function *Function_p,</li>
<li>SM_SOURCE_CONTEXT type) -{ -SM_BEGIN()</li>
<li></li>
<li>sm_SourceContext *Context_p = NULL;</li>
<li></li>
<li>for (int i = 0; i &lt; Function_p-&gt;arguments; ++i)</li>
<li>{</li>
<li>if (Function_p-&gt;argumentTypes_p[i] == SM_TOKEN_IDENTIFIER) {</li>
<li>for (int j = 0; j &lt; ContextArray_p-&gt;length; ++j) {</li>
<li>if (!sm_matchSourceContext(ContextArray_p-&gt;SourceContexts_p+j, type)) {</li>
<li>continue;</li>
<li>}</li>
<li>if (!strcmp(ContextArray_p-&gt;SourceContexts_p[j].name_p, Function_p-&gt;arguments_pp[i])) {</li>
<li>Context_p = &amp;ContextArray_p-&gt;SourceContexts_p[j];</li>
<li>}</li>
<li>}</li>
<li>}</li>
<li>else {</li>
<li></li>
<li>if (!Context_p) {</li>
<li>if (!ContextArray_p-&gt;length) {SM_DIAGNOSTIC_END(SM_ERROR_BAD_STATE)}</li>
<li>Context_p = ContextArray_p-&gt;SourceContexts_p;</li>
<li>}</li>
<li></li>
<li>if (!SourceArray_p-&gt;Sources_p) {</li>
<li>SourceArray_p-&gt;Sources_p = malloc(sizeof(sm_Source));</li>
<li>SM_CHECK_NULL(SourceArray_p-&gt;Sources_p)</li>
<li>}</li>
<li>else {</li>
<li>SourceArray_p-&gt;Sources_p = realloc(SourceArray_p-&gt;Sources_p, sizeof(sm_Source) * (SourceArray_p-&gt;length + 1));</li>
<li>SM_CHECK_NULL(SourceArray_p-&gt;Sources_p)</li>
<li>}</li>
<li><br  />
</li>
<li>sm_Source *Source_p = &amp;SourceArray_p-&gt;Sources_p[SourceArray_p-&gt;length];</li>
<li>*Source_p = sm_initSource();</li>
<li></li>
<li>Source_p-&gt;Context_p = Context_p;</li>
<li>Source_p-&gt;path_p = malloc(strlen(Function_p-&gt;arguments_pp[i]) + 1);</li>
<li>SM_CHECK_NULL(Source_p-&gt;path_p)</li>
<li>sprintf(Source_p-&gt;path_p, Function_p-&gt;arguments_pp[i]);</li>
<li><br  />
</li>
<li>SourceArray_p-&gt;length++;</li>
<li></li>
<li>SM_BYTE offset_p[64];</li>
<li>sm_getIndentAfterSourceContext(Context_p-&gt;name_p, offset_p, 64, ContextArray_p);</li>
<li>sm_messagef("[%s]%s Add source file (%d) \"%s\"", Context_p-&gt;name_p, offset_p, Context_p-&gt;type, Source_p-&gt;path_p);</li>
<li>}</li>
<li>}</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>diff &ndash;git a/external/selfmake/src/lib/Core/Source.h b/external/selfmake/src/lib/Core/Source.h deleted file mode 100644 index df9e313..0000000 &mdash; a/external/selfmake/src/lib/Core/Source.h +++ /dev/null @ -1,68 +0,0 @ -#ifndef SM_SOURCE_H -#define SM_SOURCE_H</li>
<li>-#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-#include "../Common/Types.h" -#include "../Common/Result.h"</li>
<li>-#endif</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>typedef struct sm_Source {</li>
<li>sm_SourceContext *Context_p;</li>
<li>SM_BYTE *path_p;</li>
<li>} sm_Source;</li>
<li></li>
<li>typedef struct sm_SourceArray {</li>
<li>int length;</li>
<li>sm_Source *Sources_p;</li>
<li>} sm_SourceArray;</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>typedef struct sm_Thread {</li>
<li>int depth;</li>
<li>SM_BOOL running;</li>
<li>sm_Runtime *Runtime_p;</li>
<li>#if defined(<b>linux</b>) || defined(<b>APPLE</b>)</li>
<li>pthread_t id; <br  />
</li>
<li>#elif defined(_WIN32) || defined (WIN32)</li>
<li>DWORD id; <br  />
</li>
<li>#endif</li>
<li>} sm_Thread;</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
<li>-#endif diff &ndash;git a/external/selfmake/src/lib/Parser/Parser.c b/external/selfmake/src/lib/Parser/Parser.c deleted file mode 100644 index e5a7d1f..0000000 &mdash; a/external/selfmake/src/lib/Parser/Parser.c +++ /dev/null @ -1,369 +0,0 @ -// LICENSE NOTICE ==================================================================================</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-// INCLUDE =========================================================================================</li>
<li>-#include "Parser.h"</li>
<li>-#include "../Common/Macros/Macros.h" -#include SM_FLOW -#include SM_CUSTOM_CHECK</li>
<li>-#include &lt;stdio.h&gt; -#include &lt;stdlib.h&gt; -#include &lt;string.h&gt; -#include &lt;unistd.h&gt; -#include &lt;ctype.h&gt;</li>
<li>-// PARSE ===========================================================================================</li>
<li>-static sm_Token *sm_parseToken(</li>
<li>sm_Token *Token_p, sm_Definition *Definition_p -);</li>
<li>-static sm_Token *sm_parseFunction(</li>
<li>sm_Token *Token_p, sm_Definition *Definition_p) -{ -SM_BEGIN()</li>
<li></li>
<li>Definition_p-&gt;type = SM_DEFINITION_FUNCTION;</li>
<li>Definition_p-&gt;Function.name_p = Token_p-&gt;string_p;</li>
<li>Definition_p-&gt;Function.arguments_pp = NULL;</li>
<li>Definition_p-&gt;Function.arguments = 0;</li>
<li></li>
<li>++Token_p;</li>
<li></li>
<li>if (Token_p-&gt;type != SM_TOKEN_ROUND_BRACKET_LEFT) {</li>
<li>SM_END(Token_p)</li>
<li>}</li>
<li></li>
<li>Definition_p-&gt;Function.arguments_pp = malloc(sizeof(SM_BYTE));</li>
<li>SM_CHECK_NULL(NULL, Definition_p-&gt;Function.arguments_pp)</li>
<li></li>
<li>Definition_p-&gt;Function.argumentTypes_p = malloc(sizeof(SM_TOKEN));</li>
<li>SM_CHECK_NULL(NULL, Definition_p-&gt;Function.argumentTypes_p)</li>
<li></li>
<li>while (Token_p-&gt;type != SM_TOKEN_ROUND_BRACKET_RIGHT)</li>
<li>{</li>
<li>switch (Token_p-&gt;type)</li>
<li>{</li>
<li>case SM_TOKEN_IDENTIFIER :</li>
<li>case SM_TOKEN_STRING :</li>
<li>Definition_p-&gt;Function.argumentTypes_p[Definition_p-&gt;Function.arguments] = Token_p-&gt;type;</li>
<li>Definition_p-&gt;Function.arguments_pp[Definition_p-&gt;Function.arguments++] = Token_p-&gt;string_p;</li>
<li>Definition_p-&gt;Function.arguments_pp = realloc(Definition_p-&gt;Function.arguments_pp, sizeof(SM_BYTE*) * (Definition_p-&gt;Function.arguments + 1));</li>
<li>Definition_p-&gt;Function.argumentTypes_p = realloc(Definition_p-&gt;Function.argumentTypes_p, sizeof(SM_TOKEN) * (Definition_p-&gt;Function.arguments + 1));</li>
<li>break;</li>
<li>}</li>
<li>++Token_p;</li>
<li>}</li>
<li>-SM_END(++Token_p) -}</li>
<li>-static sm_Token <em>sm_parseBlock(</em></li>
<li><em> sm_Token *Token_p, sm_Definition *Definition_p) -{ -SM_BEGIN()</em></li>
<li><em></em></li>
<li><em> Definition_p-&gt;type = SM_DEFINITION_BLOCK;</em></li>
<li><em> Definition_p-&gt;Block.Definitions_p = NULL;</em></li>
<li><em> Definition_p-&gt;Block.definitions = 0;</em></li>
<li><em></em></li>
<li><em> if (Token_p-&gt;type == SM_TOKEN_CURLY_BRACKET_RIGHT) {</em></li>
<li><em> SM_END(Token_p)</em></li>
<li><em> }</em></li>
<li><em></em></li>
<li><em> Definition_p-&gt;Block.Definitions_p = malloc(sizeof(sm_Definition));</em></li>
<li><em> SM_CHECK_NULL(NULL, Definition_p-&gt;Block.Definitions_p)</em></li>
<li><em></em></li>
<li><em> while (Token_p-&gt;type != SM_TOKEN_CURLY_BRACKET_RIGHT) { <br  />
</em></li>
<li><em> Token_p = sm_parseToken(Token_p, &amp;Definition_p-&gt;Block.Definitions_p[Definition_p-&gt;Block.definitions++]);</em></li>
<li><em> Definition_p-&gt;Block.Definitions_p = realloc(Definition_p-&gt;Block.Definitions_p, sizeof(sm_Definition) * (Definition_p-&gt;Block.definitions + 1));</em></li>
<li><em> }</em></li>
<li><em>-SM_END(Token_p) -}</em></li>
<li><em>-static sm_Token *sm_parseOption(</em></li>
<li><em> sm_Token *Token_p, sm_Definition *Definition_p) -{ -SM_BEGIN()</em></li>
<li><em></em></li>
<li><em> Definition_p-&gt;type = SM_DEFINITION_OPTION;</em></li>
<li><em></em></li>
<li><em> sm_Token *Description_p = Token_p-&gt;type == SM_TOKEN_STRING ? Token_p : NULL;</em></li>
<li><em> SM_BOOL longOption = SM_FALSE;</em></li>
<li><em></em></li>
<li><em> if (Token_p-&gt;type == SM_TOKEN_STRING) {</em></li>
<li><em> if (Token_p[2].type == SM_TOKEN_HYPHEN_MINUS) {</em></li>
<li><em> longOption = SM_TRUE;</em></li>
<li><em> Token_p = Token_p + 3;</em></li>
<li><em> }</em></li>
<li><em> else {Token_p = Token_p + 2;}</em></li>
<li><em> }</em></li>
<li><em> else {</em></li>
<li><em> if (Token_p[1].type == SM_TOKEN_HYPHEN_MINUS) {</em></li>
<li><em> longOption = SM_TRUE;</em></li>
<li><em> Token_p = Token_p + 2;</em></li>
<li><em> }</em></li>
<li><em> else {Token_p = Token_p + 1;}</em></li>
<li><em> }</em></li>
<li><em></em></li>
<li><em> Definition_p-&gt;Option.arguments = 0;</em></li>
<li><em> Definition_p-&gt;Option.arguments_pp = NULL;</em></li>
<li><em> Definition_p-&gt;Option.longOption = longOption;</em></li>
<li><em> Definition_p-&gt;Option.name_p = Token_p-&gt;string_p;</em></li>
<li><em> Definition_p-&gt;Option.description_p = Description_p ? Description_p-&gt;string_p : NULL;</em></li>
<li><em> Definition_p-&gt;Option.Block_p = malloc(sizeof(sm_Block));</em></li>
<li><em> SM_CHECK_NULL(NULL, Definition_p-&gt;Option.Block_p)</em></li>
<li><em></em></li>
<li><em> ++Token_p;</em></li>
<li><em></em></li>
<li><em> sm_Token *Argument_p = Token_p;</em></li>
<li><em> int arguments = 0;</em></li>
<li><em> while (Argument_p-&gt;type == SM_TOKEN_IDENTIFIER || Argument_p-&gt;type == SM_TOKEN_STRING) {</em></li>
<li><em> arguments++;</em></li>
<li><em> Argument_p++;</em></li>
<li><em> }</em></li>
<li><em></em></li>
<li><em> if (arguments) {</em></li>
<li><em> Definition_p-&gt;Option.arguments = arguments;</em></li>
<li><em> Definition_p-&gt;Option.arguments_pp = malloc(sizeof(SM_BYTE</em>) * arguments);</li>
<li>SM_CHECK_NULL(NULL, Definition_p-&gt;Option.arguments_pp)</li>
<li>for (int i = 0; i &lt; arguments; ++i) {</li>
<li>Definition_p-&gt;Option.arguments_pp[i] = Token_p-&gt;string_p;</li>
<li>Token_p++;</li>
<li>}</li>
<li>}</li>
<li></li>
<li>if (Token_p-&gt;type != SM_TOKEN_CURLY_BRACKET_LEFT) {</li>
<li>SM_END(Token_p)</li>
<li>}</li>
<li>-SM_END(sm_parseBlock(++Token_p, Definition_p-&gt;Option.Block_p)) -}</li>
<li>-static sm_Token *sm_parseIf(</li>
<li>sm_Token *Token_p, sm_Definition *Definition_p) -{ -SM_BEGIN()</li>
<li></li>
<li>Definition_p-&gt;type = SM_DEFINITION_IF;</li>
<li>Definition_p-&gt;If.string_p = Token_p-&gt;string_p;</li>
<li>Definition_p-&gt;If.Block_p = malloc(sizeof(sm_Definition));</li>
<li>SM_CHECK_NULL(NULL, Definition_p-&gt;If.Block_p)</li>
<li></li>
<li>++Token_p;</li>
<li></li>
<li>if (Token_p-&gt;type != SM_TOKEN_CURLY_BRACKET_LEFT) {</li>
<li>SM_END(Token_p)</li>
<li>}</li>
<li>-SM_END(sm_parseBlock(++Token_p, Definition_p-&gt;If.Block_p)) -}</li>
<li>-static sm_Token *sm_parseToken(</li>
<li>sm_Token *Token_p, sm_Definition *Definition_p) -{ -SM_BEGIN()</li>
<li></li>
<li>Definition_p-&gt;type = SM_DEFINITION_UNDEFINED;</li>
<li></li>
<li>switch (Token_p-&gt;type)</li>
<li>{</li>
<li>case SM_TOKEN_CURLY_BRACKET_RIGHT :</li>
<li>case SM_TOKEN_CURLY_BRACKET_LEFT :</li>
<li>case SM_TOKEN_ROUND_BRACKET_RIGHT :</li>
<li>case SM_TOKEN_ROUND_BRACKET_LEFT :</li>
<li>case SM_TOKEN_ANGLE_BRACKET_RIGHT :</li>
<li>case SM_TOKEN_ANGLE_BRACKET_LEFT :</li>
<li>case SM_TOKEN_COMMA :</li>
<li>break;</li>
<li></li>
<li>case SM_TOKEN_STRING :</li>
<li>if (Token_p[1].type == SM_TOKEN_HYPHEN_MINUS) {</li>
<li>SM_END(sm_parseOption(Token_p, Definition_p))</li>
<li>}</li>
<li>break;</li>
<li></li>
<li>case SM_TOKEN_IDENTIFIER :</li>
<li>switch((Token_p+1)-&gt;type) {</li>
<li>case SM_TOKEN_CURLY_BRACKET_LEFT :</li>
<li>SM_END(sm_parseIf(Token_p, Definition_p))</li>
<li>case SM_TOKEN_ROUND_BRACKET_LEFT :</li>
<li>SM_END(sm_parseFunction(Token_p, Definition_p))</li>
<li>}</li>
<li>break;</li>
<li></li>
<li>case SM_TOKEN_HYPHEN_MINUS :</li>
<li>SM_END(sm_parseOption(Token_p, Definition_p))</li>
<li>break;</li>
<li>}</li>
<li>-SM_END(++Token_p) -}</li>
<li>-static SM_RESULT sm_parseFile(</li>
<li>sm_Parser *Parser_p, sm_File *File_p) -{ -SM_BEGIN()</li>
<li>-#include SM_DEFAULT_CHECK</li>
<li></li>
<li>sm_Tokenizer Tokenizer = sm_initTokenizer();</li>
<li>SM_CHECK(sm_tokenizeFile(&amp;Tokenizer, File_p))</li>
<li></li>
<li>sm_Token *Token_p = Tokenizer.Tokens_p;</li>
<li></li>
<li>Parser_p-&gt;definitions = 0;</li>
<li>Parser_p-&gt;Definitions_p = malloc(sizeof(sm_Definition));</li>
<li>SM_CHECK_NULL(Parser_p-&gt;Definitions_p)</li>
<li></li>
<li>while (Token_p-&gt;type != SM_TOKEN_EOF) {</li>
<li>Token_p = sm_parseToken(Token_p, &amp;Parser_p-&gt;Definitions_p[Parser_p-&gt;definitions]);</li>
<li>if (Parser_p-&gt;Definitions_p[Parser_p-&gt;definitions].type != SM_DEFINITION_UNDEFINED) {</li>
<li>Parser_p-&gt;definitions++;</li>
<li>Parser_p-&gt;Definitions_p = realloc(Parser_p-&gt;Definitions_p, sizeof(sm_Definition) * (Parser_p-&gt;definitions + 1));</li>
<li>}</li>
<li>}</li>
<li>-#include SM_CUSTOM_CHECK</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-// SHOW ============================================================================================</li>
<li>-static void sm_showParserDefinition(</li>
<li>sm_Definition *Definition_p, unsigned int depth) -{ -SM_BEGIN()</li>
<li></li>
<li>SM_BYTE depth_p[255];</li>
<li>memset(depth_p, 0, 255);</li>
<li></li>
<li>for (int i = 0; i &lt; (depth * 2); ++i) {depth_p[i] = ' ';}</li>
<li></li>
<li>switch (Definition_p-&gt;type)</li>
<li>{</li>
<li>case SM_DEFINITION_IF :</li>
<li>sm_messagef("%s%s", depth_p, Definition_p-&gt;If.string_p);</li>
<li>sm_messagef("%s{", depth_p);</li>
<li>for (int j = 0; j &lt; Definition_p-&gt;If.Block_p-&gt;Block.definitions; ++j) {</li>
<li>sm_showParserDefinition(&amp;Definition_p-&gt;If.Block_p-&gt;Block.Definitions_p[j], depth + 1);</li>
<li>}</li>
<li>sm_messagef("%s}", depth_p);</li>
<li>break;</li>
<li></li>
<li>case SM_DEFINITION_FUNCTION :</li>
<li>sm_messagef("%s%s", depth_p, Definition_p-&gt;Function.name_p);</li>
<li>for (int j = 0; j &lt; Definition_p-&gt;Function.arguments; ++j) {</li>
<li>sm_messagef("%s  %s", depth_p, Definition_p-&gt;Function.arguments_pp[j]);</li>
<li>}</li>
<li>break;</li>
<li></li>
<li>case SM_DEFINITION_BLOCK :</li>
<li>sm_messagef("%s{", depth_p);</li>
<li>for (int j = 0; j &lt; Definition_p-&gt;Block.definitions; ++j) {</li>
<li>sm_showParserDefinition(&amp;Definition_p-&gt;Block.Definitions_p[j], depth + 1);</li>
<li>}</li>
<li>sm_messagef("%s}", depth_p);</li>
<li>break;</li>
<li></li>
<li>case SM_DEFINITION_OPTION :</li>
<li>if (Definition_p-&gt;Option.longOption) {</li>
<li>sm_messagef("%s--%s", depth_p, Definition_p-&gt;Option.name_p);</li>
<li>}</li>
<li>else {</li>
<li>sm_messagef("%s-%s", depth_p, Definition_p-&gt;Option.name_p);</li>
<li>}</li>
<li>if (Definition_p-&gt;Option.description_p) {</li>
<li>sm_messagef("%s  description: %s", depth_p, Definition_p-&gt;Option.description_p);</li>
<li>}</li>
<li>for (int i = 0; i &lt; Definition_p-&gt;Option.arguments; ++i) {</li>
<li>sm_messagef("%s  argument %d: %s", depth_p, i, Definition_p-&gt;Option.arguments_pp[i]);</li>
<li>}</li>
<li>sm_showParserDefinition(Definition_p-&gt;Option.Block_p, depth + 1);</li>
<li>break;</li>
<li>}</li>
<li>-SM_SILENT_END() -}</li>
<li>-static void sm_showParseTree(</li>
<li>sm_Parser *Parser_p) -{ -SM_BEGIN()</li>
<li></li>
<li>sm_operationf("Show Parse-Tree");</li>
<li></li>
<li>for (int i = 0; i &lt; Parser_p-&gt;definitions; ++i) {</li>
<li>sm_showParserDefinition(&amp;Parser_p-&gt;Definitions_p[i], 0);</li>
<li>}</li>
<li>-SM_SILENT_END() -}</li>
<li>-// PARSER ARRAY ====================================================================================</li>
<li>-void sm_initParserArray(</li>
<li>sm_ParserArray *Array_p) -{ -SM_BEGIN()</li>
<li></li>
<li>Array_p-&gt;length = 0;</li>
<li>Array_p-&gt;Parsers_p = NULL;</li>
<li>-SM_SILENT_END() -}</li>
<li>-static sm_Parser sm_initParser() -{ -SM_BEGIN()</li>
<li></li>
<li>sm_Parser Parser;</li>
<li>Parser.executed = SM_FALSE;</li>
<li>Parser.Definitions_p = NULL;</li>
<li>Parser.definitions = 0;</li>
<li>-SM_END(Parser) -}</li>
<li>-SM_RESULT sm_appendParser(</li>
<li>sm_ParserArray *Array_p, sm_File *File_p, SM_BOOL showParseTree) -{ -SM_BEGIN()</li>
<li>-#include SM_DEFAULT_CHECK</li>
<li></li>
<li>if (!Array_p-&gt;Parsers_p) {</li>
<li>Array_p-&gt;Parsers_p = malloc(sizeof(sm_Parser));</li>
<li>SM_CHECK_NULL(Array_p-&gt;Parsers_p)</li>
<li>}</li>
<li>else {</li>
<li>Array_p-&gt;Parsers_p = realloc(Array_p-&gt;Parsers_p, sizeof(sm_Parser) * (Array_p-&gt;length + 1));</li>
<li>SM_CHECK_NULL(Array_p-&gt;Parsers_p)</li>
<li>}</li>
<li></li>
<li>sm_Parser *Parser_p = &amp;Array_p-&gt;Parsers_p[Array_p-&gt;length];</li>
<li></li>
<li>*Parser_p = sm_initParser();</li>
<li>SM_CHECK(sm_parseFile(Parser_p, File_p))</li>
<li></li>
<li>if (showParseTree) {</li>
<li>sm_showParseTree(Parser_p);</li>
<li>}</li>
<li></li>
<li>Array_p-&gt;length++;</li>
<li>-#include SM_CUSTOM_CHECK</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>diff &ndash;git a/external/selfmake/src/lib/Parser/Parser.h b/external/selfmake/src/lib/Parser/Parser.h deleted file mode 100644 index a6b2aad..0000000 &mdash; a/external/selfmake/src/lib/Parser/Parser.h +++ /dev/null @ -1,85 +0,0 @ -#ifndef SM_PARSER_H -#define SM_PARSER_H</li>
<li>-#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-#include "Tokenizer.h"</li>
<li>-#include "../Common/Types.h" -#include "../Common/Result.h"</li>
<li>-#include "../Core/File.h"</li>
<li>-#endif</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>typedef union sm_Definition sm_Definition;</li>
<li></li>
<li>typedef struct sm_Block {</li>
<li>SM_DEFINITION type;</li>
<li>unsigned int definitions;</li>
<li>sm_Definition *Definitions_p;</li>
<li>} sm_Block;</li>
<li></li>
<li>typedef struct sm_Option {</li>
<li>SM_DEFINITION type;</li>
<li>SM_BOOL longOption;</li>
<li>int arguments;</li>
<li>SM_BYTE <b>arguments_pp;</b></li>
<li><b> SM_BYTE *name_p;</b></li>
<li><b> SM_BYTE *description_p;</b></li>
<li><b> sm_Definition *Block_p;</b></li>
<li><b> } sm_Option;</b></li>
<li><b></b></li>
<li><b> typedef struct sm_If {</b></li>
<li><b> SM_DEFINITION type;</b></li>
<li><b> SM_BYTE *string_p;</b></li>
<li><b> sm_Definition *Block_p;</b></li>
<li><b> } sm_If;</b></li>
<li><b></b></li>
<li><b> typedef union sm_Definition {</b></li>
<li><b> SM_DEFINITION type;</b></li>
<li><b> sm_Option Option;</b></li>
<li><b> sm_Function Function;</b></li>
<li><b> sm_Block Block;</b></li>
<li><b> sm_If If;</b></li>
<li><b> } sm_Definition;</b></li>
<li><b></b></li>
<li><b> typedef struct sm_Parser {</b></li>
<li><b> SM_BOOL executed;</b></li>
<li><b> SM_BOOL expectExpression;</b></li>
<li><b> unsigned int definitions;</b></li>
<li><b> sm_Definition *Definitions_p;</b></li>
<li><b> } sm_Parser;</b></li>
<li><b></b></li>
<li><b> typedef struct sm_ParserArray {</b></li>
<li><b> int length;</b></li>
<li><b> sm_Parser *Parsers_p;</b></li>
<li><b> } sm_ParserArray;</b></li>
<li><p class="startli"><b>-/</b></p>
<p class="startli">*/</p>
</li>
<li>-#endif diff &ndash;git a/external/selfmake/src/lib/Parser/Tokenizer.c b/external/selfmake/src/lib/Parser/Tokenizer.c deleted file mode 100644 index 2329de6..0000000 &mdash; a/external/selfmake/src/lib/Parser/Tokenizer.c +++ /dev/null @ -1,228 +0,0 @ -// LICENSE NOTICE ==================================================================================</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-// INCLUDE =========================================================================================</li>
<li>-#include "Tokenizer.h"</li>
<li>-#include "../Core/Utils.h" -#include "../Common/Macros/Macros.h" -#include SM_FLOW -#include SM_DEFAULT_CHECK</li>
<li>-#include &lt;stdio.h&gt; -#include &lt;stdlib.h&gt; -#include &lt;string.h&gt; -#include &lt;unistd.h&gt; -#include &lt;ctype.h&gt;</li>
<li>-// HELPER ==========================================================================================</li>
<li>-static SM_BOOL sm_isASCIIUpperAlpha(</li>
<li>SM_BYTE codepoint) -{ -SM_BEGIN() -SM_END(codepoint &gt;= 0x41 &amp;&amp; codepoint &lt;= 0x5A) -}</li>
<li>-static SM_BOOL sm_isASCIILowerAlpha(</li>
<li>SM_BYTE codepoint) -{ -SM_BEGIN() -SM_END(codepoint &gt;= 0x61 &amp;&amp; codepoint &lt;= 0x7A) -}</li>
<li>-static SM_BOOL sm_isASCIIAlpha(</li>
<li>SM_BYTE codepoint) -{ -SM_BEGIN() -SM_END(sm_isASCIIUpperAlpha(codepoint) || sm_isASCIILowerAlpha(codepoint)) -}</li>
<li>-static SM_BOOL sm_isBracket(</li>
<li>SM_BYTE codepoint) -{ -SM_BEGIN() -SM_END(codepoint == '(' || codepoint == ')' || codepoint == '{' || codepoint == '}' || codepoint == '[' || codepoint == ']') -}</li>
<li>-static SM_BOOL sm_isTokenBegin(</li>
<li>SM_BYTE codepoint) -{ -SM_BEGIN()</li>
<li></li>
<li>if (sm_isASCIIAlpha(codepoint) || sm_isBracket(codepoint)</li>
<li>|| codepoint == ','</li>
<li>|| codepoint == '"'</li>
<li>|| codepoint == '-')</li>
<li></li>
<li>{SM_END(SM_TRUE)}</li>
<li>-SM_END(SM_FALSE) -}</li>
<li>-// TOKENIZE ========================================================================================</li>
<li>-static SM_BYTE *sm_tokenizeString(</li>
<li>sm_Token *Token_p, SM_BYTE *bytes_p) -{ -SM_BEGIN()</li>
<li></li>
<li>SM_BYTE *string_p = malloc(1);</li>
<li>unsigned int stringLength = 0;</li>
<li></li>
<li>SM_BYTE *stringBegin_p = bytes_p;</li>
<li></li>
<li>SM_BOOL escape = SM_FALSE;</li>
<li>while (*bytes_p &amp;&amp; (*bytes_p != '"' || escape)) {</li>
<li>escape = escape ? SM_FALSE : *bytes_p == 0x5C;</li>
<li>if (!escape) {</li>
<li>string_p = realloc(string_p, stringLength + 1);</li>
<li>string_p[stringLength++] = *bytes_p;</li>
<li>}</li>
<li>bytes_p++;</li>
<li>}</li>
<li>if (!*bytes_p) {SM_END(NULL)}</li>
<li></li>
<li>*bytes_p = 0;</li>
<li></li>
<li>string_p = realloc(string_p, stringLength + 1);</li>
<li>string_p[stringLength] = 0;</li>
<li></li>
<li>Token_p-&gt;string_p = string_p;</li>
<li></li>
<li>*bytes_p = '"';</li>
<li>-SM_END(&amp;bytes_p[1]) -}</li>
<li>-static SM_BYTE *sm_getToken(</li>
<li>sm_Token *Token_p, SM_BYTE *bytes_p) -{ -SM_BEGIN()</li>
<li></li>
<li>if (!*bytes_p) {SM_END(NULL)}</li>
<li></li>
<li>Token_p-&gt;type = SM_TOKEN_UNDEFINED;</li>
<li>Token_p-&gt;string_p = NULL;</li>
<li></li>
<li>while (*bytes_p &amp;&amp; !sm_isTokenBegin(*bytes_p)) {</li>
<li>if (bytes_p[0] == '/' &amp;&amp; bytes_p[1] == '/') {</li>
<li>while (*bytes_p &amp;&amp; *bytes_p != '<br  />
') {bytes_p++;}</li>
<li>}</li>
<li>bytes_p++;</li>
<li>}</li>
<li>if (!*bytes_p) {SM_END(NULL)}</li>
<li></li>
<li>SM_BYTE *tokenBegin_p = bytes_p;</li>
<li></li>
<li>switch (*tokenBegin_p)</li>
<li>{</li>
<li>case '(' : Token_p-&gt;type = SM_TOKEN_ROUND_BRACKET_LEFT; break;</li>
<li>case ')' : Token_p-&gt;type = SM_TOKEN_ROUND_BRACKET_RIGHT; break;</li>
<li>case '{' : Token_p-&gt;type = SM_TOKEN_CURLY_BRACKET_LEFT; break;</li>
<li>case '}' : Token_p-&gt;type = SM_TOKEN_CURLY_BRACKET_RIGHT; break;</li>
<li>case '[' : Token_p-&gt;type = SM_TOKEN_ANGLE_BRACKET_LEFT; break;</li>
<li>case ']' : Token_p-&gt;type = SM_TOKEN_ANGLE_BRACKET_RIGHT; break;</li>
<li>case '-' : Token_p-&gt;type = SM_TOKEN_HYPHEN_MINUS; break;</li>
<li>case ',' : Token_p-&gt;type = SM_TOKEN_COMMA; break;</li>
<li>case '"' :</li>
<li>Token_p-&gt;type = SM_TOKEN_STRING;</li>
<li>SM_END(sm_tokenizeString(Token_p, &amp;bytes_p[1]))</li>
<li>break;</li>
<li>}</li>
<li><br  />
</li>
<li>if (Token_p-&gt;type != SM_TOKEN_UNDEFINED) {</li>
<li>SM_END(&amp;bytes_p[1])</li>
<li>}</li>
<li></li>
<li>while (*bytes_p &amp;&amp; (sm_isASCIIAlpha(*bytes_p) || *bytes_p == '_')) {bytes_p++;}</li>
<li>if (!*bytes_p) {SM_END(NULL)}</li>
<li></li>
<li>SM_BYTE tmp = *bytes_p;</li>
<li>*bytes_p = 0; <br  />
</li>
<li></li>
<li>Token_p-&gt;type = SM_TOKEN_IDENTIFIER;</li>
<li>Token_p-&gt;string_p = malloc(strlen(tokenBegin_p) + 1);</li>
<li>strcpy(Token_p-&gt;string_p, tokenBegin_p);</li>
<li></li>
<li>*bytes_p = tmp;</li>
<li>-SM_END(bytes_p) -}</li>
<li>-static void sm_getTokens(</li>
<li>sm_Token *Tokens_p, SM_BYTE *bytes_p, unsigned int *tokens_p) -{ -SM_BEGIN()</li>
<li></li>
<li>unsigned int tokens = 0;</li>
<li></li>
<li>while (bytes_p)</li>
<li>{</li>
<li>sm_Token Token;</li>
<li>bytes_p = sm_getToken(&amp;Token, bytes_p);</li>
<li>if (Tokens_p) {Tokens_p[tokens] = Token;}</li>
<li>tokens++;</li>
<li>}</li>
<li></li>
<li>if (Tokens_p) {</li>
<li>Tokens_p[tokens - 1].type = SM_TOKEN_EOF; <br  />
</li>
<li>}</li>
<li></li>
<li>if (tokens_p) {*tokens_p = tokens;}</li>
<li>-SM_SILENT_END() -}</li>
<li>-SM_RESULT sm_tokenizeFile(</li>
<li>sm_Tokenizer *Tokenizer_p, sm_File *File_p) -{ -SM_BEGIN()</li>
<li></li>
<li>SM_BYTE *bytes_p = malloc(strlen(File_p-&gt;data_p) + 1);</li>
<li>SM_CHECK_NULL(bytes_p)</li>
<li>strcpy(bytes_p, File_p-&gt;data_p);</li>
<li></li>
<li>unsigned int tokens = 0;</li>
<li>sm_getTokens(NULL, bytes_p, &amp;tokens);</li>
<li></li>
<li>free(bytes_p);</li>
<li>bytes_p = NULL;</li>
<li></li>
<li>bytes_p = malloc(strlen(File_p-&gt;data_p) + 1);</li>
<li>SM_CHECK_NULL(bytes_p)</li>
<li>strcpy(bytes_p, File_p-&gt;data_p);</li>
<li></li>
<li>sm_Token *Tokens_p = malloc(sizeof(sm_Token) * tokens);</li>
<li>for (int i = 0; i &lt; tokens; ++i) {</li>
<li>Tokens_p[i].string_p = NULL;</li>
<li>}</li>
<li>sm_getTokens(Tokens_p, bytes_p, NULL);</li>
<li></li>
<li>free(bytes_p);</li>
<li></li>
<li>Tokenizer_p-&gt;tokens = tokens;</li>
<li>Tokenizer_p-&gt;Tokens_p = Tokens_p;</li>
<li>-SM_END(SM_SUCCESS) -}</li>
<li>-// INIT ============================================================================================</li>
<li>-sm_Tokenizer sm_initTokenizer() -{ -SM_BEGIN()</li>
<li></li>
<li>sm_Tokenizer Tokenizer;</li>
<li>Tokenizer.tokens = 0;</li>
<li>Tokenizer.Tokens_p = NULL;</li>
<li>-SM_END(Tokenizer) -}</li>
<li>diff &ndash;git a/external/selfmake/src/lib/Parser/Tokenizer.h b/external/selfmake/src/lib/Parser/Tokenizer.h deleted file mode 100644 index 0348f8c..0000000 &mdash; a/external/selfmake/src/lib/Parser/Tokenizer.h +++ /dev/null @ -1,48 +0,0 @ -#ifndef SM_TOKENIZER_H -#define SM_TOKENIZER_H</li>
<li>-#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-#include "../Common/Types.h" -#include "../Common/Result.h"</li>
<li>-#include "../Core/File.h"</li>
<li>-#endif</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>typedef struct sm_Token {</li>
<li>SM_TOKEN type;</li>
<li>SM_BYTE *string_p;</li>
<li>} sm_Token;</li>
<li></li>
<li>typedef struct sm_Tokenizer {</li>
<li>unsigned int tokens;</li>
<li>sm_Token *Tokens_p;</li>
<li>} sm_Tokenizer;</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
<li>-#endif diff &ndash;git a/external/selfmake/src/lib/Parser/Variables.h b/external/selfmake/src/lib/Parser/Variables.h deleted file mode 100644 index 975c510..0000000 &mdash; a/external/selfmake/src/lib/Parser/Variables.h +++ /dev/null @ -1,60 +0,0 @ -#ifndef SM_VARIABLES_H -#define SM_VARIABLES_H</li>
<li>-#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-#include "../Common/Types.h" -#include "../Common/Result.h"</li>
<li>-#endif</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>typedef struct sm_Variable {</li>
<li>SM_BYTE *name_p;</li>
<li>int valueCount;</li>
<li>SM_BYTE <b>values_pp;</b></li>
<li><b> } sm_Variable;</b></li>
<li><b></b></li>
<li><b> typedef struct sm_VariableArray {</b></li>
<li><b> int length;</b></li>
<li><b> sm_Variable *Variables_p;</b></li>
<li><b> } sm_VariableArray;</b></li>
<li><p class="startli"><b>-/</b></p>
<p class="startli">*/</p>
</li>
<li>-#endif diff &ndash;git a/external/selfmake/src/lib/Test/Process.c b/external/selfmake/src/lib/Test/Process.c deleted file mode 100644 index e75e9fa..0000000 &mdash; a/external/selfmake/src/lib/Test/Process.c +++ /dev/null @ -1,158 +0,0 @ -// LICENSE NOTICE ==================================================================================</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-// INCLUDE =========================================================================================</li>
<li>-#include "Process.h" -#include "Channel.h"</li>
<li>-#include "../Common/Types.h" -#include "../Common/Macros/Macros.h" -#include SM_FLOW -#include SM_DEFAULT_CHECK</li>
<li>-#include &lt;stdlib.h&gt; -#include &lt;stdio.h&gt; -#include &lt;unistd.h&gt; -#include &lt;errno.h&gt; -#include &lt;string.h&gt;</li>
<li>-#if defined(<b>linux</b>) || defined(<b>APPLE</b>)</li>
<li>#include &lt;sys/wait.h&gt;</li>
<li>#include &lt;signal.h&gt; -#endif</li>
<li>-// FORK ============================================================================================</li>
<li>-static sm_Process sm_initProcess() -{ -SM_BEGIN()</li>
<li></li>
<li>sm_Process Process;</li>
<li>Process.id = 0;</li>
<li></li>
<li>sm_initChannel(&amp;Process.IPC.In);</li>
<li>sm_initChannel(&amp;Process.IPC.Out);</li>
<li>-SM_END(Process) -}</li>
<li>-sm_Process sm_fork() -{ -SM_BEGIN()</li>
<li>-#include SM_CUSTOM_CHECK</li>
<li></li>
<li>sm_Process Fork = sm_initProcess();</li>
<li></li>
<li>sm_openChannel(&amp;Fork.IPC.In);</li>
<li>sm_openChannel(&amp;Fork.IPC.Out);</li>
<li></li>
<li>Fork.id = fork();</li>
<li></li>
<li>if (Fork.id == 0) { // child</li>
<li>sm_closeChannelWriteAccess(&amp;Fork.IPC.In);</li>
<li>sm_closeChannelReadAccess(&amp;Fork.IPC.Out);</li>
<li>SM_END(Fork)</li>
<li>}</li>
<li></li>
<li>sm_closeChannelReadAccess(&amp;Fork.IPC.In);</li>
<li>sm_closeChannelWriteAccess(&amp;Fork.IPC.Out);</li>
<li>-#include SM_DEFAULT_CHECK</li>
<li>-SM_END(Fork) -}</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>-// TODO ============================================================================</li>
<li>-static SM_RESULT sm_unregisterFork(</li>
<li>sm_Process *Fork_p) -{ -SM_BEGIN()</li>
<li></li>
<li>if (Fork_p-&gt;id == 0) {SM_DIAGNOSTIC_END(SM_ERROR_BAD_STATE)}</li>
<li></li>
<li>sm_closeChannelWriteAccess(&amp;Fork_p-&gt;IPC.In);</li>
<li>sm_closeChannelReadAccess(&amp;Fork_p-&gt;IPC.Out);</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-void sm_checkForks() -{ -SM_BEGIN()</li>
<li>-// if (init == SM_FALSE) {SM_SILENT_END()} -// -// for (int i = 0; i &lt; SM_MAX_FORKS; ++i) { -// sm_Process *Proc_p = &amp;SM_PROCESS_POOL.Forks_p[i]; -// if (Proc_p-&gt;id != 0) { -// int status; -//#if defined(<b>linux</b>) || defined(<b>APPLE</b>) -// int result = waitpid(Proc_p-&gt;id, &amp;status, WNOHANG); -// if (result == -1) { -// printf("sm_checkForks %s\n", strerror(errno)); -// } -// if (result == -1 || WIFEXITED(status)) { -// sm_unregisterFork(&amp;SM_PROCESS_POOL.Forks_p[i]); -// } -//#endif -// } -// }</li>
<li>-SM_SILENT_END() -}</li>
<li>-void sm_killFork(</li>
<li>sm_Process *Fork_p) -{ -SM_BEGIN()</li>
<li></li>
<li>kill(Fork_p-&gt;id, SIGTERM);</li>
<li>sm_unregisterFork(Fork_p);</li>
<li>-SM_SILENT_END() -}</li>
<li>-// WRITE ===========================================================================================</li>
<li>-SM_BYTE *_sm_writeToProcess(</li>
<li>sm_Process *Proc_p, SM_BYTE *write_p, int writeLen, SM_BOOL getResponse) -{</li>
<li>sm_writeToChannel(&amp;Proc_p-&gt;IPC.In, write_p, writeLen);</li>
<li></li>
<li>while (getResponse)</li>
<li>{</li>
<li>SM_BYTE *response_p = sm_readFromChannel(&amp;Proc_p-&gt;IPC.Out, NULL);</li>
<li>if (response_p != NULL) {</li>
<li>return response_p;</li>
<li>}</li>
<li>}</li>
<li></li>
<li>return NULL; -}</li>
<li>-SM_BYTE *sm_writeToProcess(</li>
<li>sm_Process *Proc_p, SM_BYTE *write_p, int writeLen, SM_BOOL getResponse) -{ -SM_BEGIN() -SM_END(_sm_writeToProcess(Proc_p, write_p, writeLen, getResponse)) -}</li>
<li>diff &ndash;git a/external/selfmake/src/lib/Test/Process.h b/external/selfmake/src/lib/Test/Process.h deleted file mode 100644 index 0b87c9b..0000000 &mdash; a/external/selfmake/src/lib/Test/Process.h +++ /dev/null @ -1,50 +0,0 @ -#ifndef SM_PROCESS_H -#define SM_PROCESS_H</li>
<li>-#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-#include "Channel.h"</li>
<li>-#include "../Common/Result.h" -#include "../Common/Types.h"</li>
<li>-#include &lt;sys/types.h&gt;</li>
<li>-#endif</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li>-#if defined(<b>unix</b>) || defined(<b>APPLE</b>)</li>
<li>typedef pid_t SM_PROCESS; -#endif</li>
<li></li>
<li>typedef struct sm_ProcessIPC {</li>
<li>sm_Channel In;</li>
<li>sm_Channel Out;</li>
<li>} sm_ProcessIPC;</li>
<li></li>
<li>typedef struct sm_Process {</li>
<li>SM_PROCESS id;</li>
<li>sm_ProcessIPC IPC;</li>
<li>} sm_Process;</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
<li>-#endif diff &ndash;git a/external/selfmake/src/lib/Test/Test.c b/external/selfmake/src/lib/Test/Test.c deleted file mode 100644 index d440c76..0000000 &mdash; a/external/selfmake/src/lib/Test/Test.c +++ /dev/null @ -1,316 +0,0 @ -// LICENSE NOTICE ==================================================================================</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-// INCLUDE =========================================================================================</li>
<li>-#include "Test.h" -#include "Channel.h" -#include "Process.h" -#include "Library.h"</li>
<li>-#include "../Core/Runtime.h" -#include "../Parser/Variables.h"</li>
<li>-#include "../Common/Types.h" -#include "../Common/Macros/Macros.h" -#include SM_FLOW -#include SM_DEFAULT_CHECK</li>
<li>-#include &lt;stdlib.h&gt; -#include &lt;stdio.h&gt; -#include &lt;unistd.h&gt; -#include &lt;errno.h&gt; -#include &lt;string.h&gt;</li>
<li>-#if defined(<b>linux</b>) || defined(<b>APPLE</b>)</li>
<li>#include &lt;sys/wait.h&gt; -#endif</li>
<li>-// TEST ============================================================================================</li>
<li>-typedef int (*sm_initializer_f)(); -typedef void *(*sm_customLoader_f)(SM_BYTE *libraryName_p, SM_BYTE *functionName_p); -typedef int (*sm_test_f)(int arguments, sm_TestArgument *Arguments_p, SM_BYTE *output_p, int maxOutputLength);</li>
<li>-static SM_RESULT sm_runTests(</li>
<li>sm_TestEnvironment *TestEnvironment_p) -{ -SM_BEGIN()</li>
<li></li>
<li>void *initLib_p = NULL;</li>
<li>void *loadLib_p = NULL;</li>
<li></li>
<li>if (TestEnvironment_p-&gt;Initializer_p)</li>
<li>{</li>
<li>initLib_p = sm_openLibrary(TestEnvironment_p-&gt;Initializer_p-&gt;libraryName_p);</li>
<li>SM_CHECK_NULL(initLib_p)</li>
<li></li>
<li>sm_initializer_f initializer_f = sm_loadSymbol(initLib_p, TestEnvironment_p-&gt;Initializer_p-&gt;functionName_p);</li>
<li>SM_CHECK_NULL(initializer_f)</li>
<li></li>
<li>// run custom initializer</li>
<li>if (initializer_f()) {SM_END(SM_ERROR_BAD_STATE)}</li>
<li>}</li>
<li></li>
<li>sm_customLoader_f customLoader_f = NULL;</li>
<li></li>
<li>if (TestEnvironment_p-&gt;Loader_p)</li>
<li>{</li>
<li>loadLib_p = sm_openLibrary(TestEnvironment_p-&gt;Loader_p-&gt;libraryName_p);</li>
<li>SM_CHECK_NULL(loadLib_p)</li>
<li></li>
<li>customLoader_f = sm_loadSymbol(loadLib_p, TestEnvironment_p-&gt;Loader_p-&gt;functionName_p);</li>
<li>SM_CHECK_NULL(customLoader_f)</li>
<li>}</li>
<li></li>
<li>SM_BOOL match = SM_FALSE;</li>
<li></li>
<li>for (int i = 0; i &lt; TestEnvironment_p-&gt;TestArray_p-&gt;length; ++i)</li>
<li>{</li>
<li>sm_Test *Test_p = &amp;TestEnvironment_p-&gt;TestArray_p-&gt;Tests_p[i];</li>
<li>sm_test_f test_f = NULL;</li>
<li></li>
<li>if (strcmp(Test_p-&gt;Context_p-&gt;name_p, TestEnvironment_p-&gt;target_p)) {continue;}</li>
<li></li>
<li>if (customLoader_f) {</li>
<li>test_f = customLoader_f(Test_p-&gt;Context_p-&gt;name_p, Test_p-&gt;name_p);</li>
<li>}</li>
<li>else {</li>
<li>Test_p-&gt;dl_p = sm_openLibrary(Test_p-&gt;Context_p-&gt;name_p);</li>
<li>SM_CHECK_NULL(Test_p-&gt;dl_p)</li>
<li>test_f = sm_loadSymbol(Test_p-&gt;dl_p, Test_p-&gt;name_p);</li>
<li>}</li>
<li></li>
<li>SM_CHECK_NULL(test_f)</li>
<li></li>
<li>SM_BYTE result_p[1024];</li>
<li>memset(result_p, 0, 1024);</li>
<li></li>
<li>// perform the test</li>
<li>int result = test_f(Test_p-&gt;arguments, Test_p-&gt;Arguments_p, result_p, 1024);</li>
<li></li>
<li>sm_messagef("%d: %s", result, result_p);</li>
<li></li>
<li>match = SM_TRUE;</li>
<li>}</li>
<li></li>
<li>if (match) {</li>
<li>sm_messagef("");</li>
<li>}</li>
<li>-SM_END(SM_SUCCESS) -}</li>
<li>-static sm_TestEnvironment sm_initializeTestEnvironment(</li>
<li>sm_Runtime *Runtime_p, sm_ExternalFunction *Initializer_p, sm_ExternalFunction *Loader_p,</li>
<li>SM_BYTE *target_p) -{ -SM_BEGIN()</li>
<li></li>
<li>sm_TestEnvironment TestEnvironment;</li>
<li>TestEnvironment.target_p = target_p;</li>
<li></li>
<li>sm_Variable *InitLibrary_p = sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "TEST_INITIALIZER_SOURCE");</li>
<li>sm_Variable *InitFunction_p = sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "TEST_INITIALIZER");</li>
<li></li>
<li>if (InitLibrary_p &amp;&amp; InitFunction_p) {</li>
<li>Initializer_p-&gt;libraryName_p = InitLibrary_p-&gt;values_pp[0];</li>
<li>Initializer_p-&gt;functionName_p = InitFunction_p-&gt;values_pp[0];</li>
<li>TestEnvironment.Initializer_p = Initializer_p;</li>
<li>}</li>
<li>else {TestEnvironment.Initializer_p = NULL;}</li>
<li><br  />
</li>
<li>sm_Variable *LoadLibrary_p = sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "TEST_LOADER_SOURCE");</li>
<li>sm_Variable *LoadFunction_p = sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "TEST_LOADER");</li>
<li></li>
<li>if (LoadLibrary_p &amp;&amp; LoadFunction_p) {</li>
<li>Loader_p-&gt;libraryName_p = LoadLibrary_p-&gt;values_pp[0];</li>
<li>Loader_p-&gt;functionName_p = LoadFunction_p-&gt;values_pp[0];</li>
<li>TestEnvironment.Loader_p = Loader_p;</li>
<li>}</li>
<li>else {TestEnvironment.Loader_p = NULL;}</li>
<li>-SM_END(TestEnvironment) -}</li>
<li>-static SM_RESULT sm_runTestEnvironment(</li>
<li>sm_TestEnvironment *TestEnvironment_p, sm_TestArray *TestArray_p) -{ -SM_BEGIN()</li>
<li></li>
<li>TestEnvironment_p-&gt;Process = sm_fork();</li>
<li>TestEnvironment_p-&gt;TestArray_p = TestArray_p;</li>
<li></li>
<li>if (TestEnvironment_p-&gt;Process.id == 0) {</li>
<li>exit(sm_runTests(TestEnvironment_p));</li>
<li>}</li>
<li></li>
<li>pid_t w;</li>
<li>int wstatus;</li>
<li></li>
<li>do {</li>
<li>w = waitpid(TestEnvironment_p-&gt;Process.id, &amp;wstatus, WUNTRACED | WCONTINUED);</li>
<li>if (w == -1) {</li>
<li>perror("waitpid");</li>
<li>exit(EXIT_FAILURE);</li>
<li>} -// if (WIFEXITED(wstatus)) { -// printf("exited, status=%d\n", WEXITSTATUS(wstatus)); -// } else if (WIFSIGNALED(wstatus)) { -// printf("killed by signal %d\n", WTERMSIG(wstatus)); -// } else if (WIFSTOPPED(wstatus)) { -// printf("stopped by signal %d\n", WSTOPSIG(wstatus)); -// } else if (WIFCONTINUED(wstatus)) { -// printf("continued\n"); -// }</li>
<li>} while (!WIFEXITED(wstatus) &amp;&amp; !WIFSIGNALED(wstatus));</li>
<li>-SM_END(SM_SUCCESS) -}</li>
<li>-SM_RESULT sm_test(</li>
<li>sm_Runtime *Runtime_p, SM_BYTE *name_p) -{ -SM_BEGIN()</li>
<li></li>
<li>sm_ExternalFunction Initializer;</li>
<li>sm_ExternalFunction Loader;</li>
<li></li>
<li>sm_TestEnvironment TestEnvironment =</li>
<li>sm_initializeTestEnvironment(Runtime_p, &amp;Initializer, &amp;Loader, name_p);</li>
<li></li>
<li>SM_CHECK(sm_runTestEnvironment(&amp;TestEnvironment, &amp;Runtime_p-&gt;TestArray))</li>
<li>-SM_END(SM_SUCCESS) -}</li>
<li>-//SM_BYTE *sm_getTestResult( -// sm_Process *Fork_p) -//{ -//SM_BEGIN() -// -// if (Fork_p-&gt;id != 0) { -// SM_BYTE *receive_p = sm_readFromChannel(&amp;Fork_p-&gt;IPC.Out, NULL); -// if (receive_p != NULL) { -// SM_CHECK(sm_handleIPCReceive(receive_p)) -// } -//// TODO free? -// } -// -//SM_END(SM_SIGNAL_OK) -//} -// -//SM_RESULT sm_destroyTestEnvironment( -// sm_TestEnvironment *TestEnvironment_p) -//{ -//SM_BEGIN() -// -//SM_END(SM_SUCCESS) -//}</li>
<li></li>
<li>-// TEST ARRAY ======================================================================================</li>
<li>-void sm_initTestArray(</li>
<li>sm_TestArray *Array_p) -{ -SM_BEGIN()</li>
<li></li>
<li>Array_p-&gt;length = 0;</li>
<li>Array_p-&gt;Tests_p = NULL;</li>
<li>-SM_SILENT_END() -}</li>
<li>-static sm_Test sm_initTest() -{ -SM_BEGIN()</li>
<li></li>
<li>sm_Test Test;</li>
<li>Test.Context_p = NULL;</li>
<li>Test.name_p = NULL;</li>
<li>Test.dl_p = NULL;</li>
<li>Test.arguments = 0;</li>
<li>Test.Arguments_p = NULL;</li>
<li>-SM_END(Test) -}</li>
<li>-SM_RESULT sm_addTest(</li>
<li>sm_SourceContextArray *ContextArray_p, sm_TestArray *TestArray_p, sm_Function *Function_p) -{ -SM_BEGIN()</li>
<li></li>
<li>sm_SourceContext *Context_p = NULL;</li>
<li>sm_Test *Test_p = NULL;</li>
<li></li>
<li>for (int i = 0; i &lt; Function_p-&gt;arguments; ++i)</li>
<li>{</li>
<li>if (Function_p-&gt;argumentTypes_p[i] == SM_TOKEN_IDENTIFIER) {</li>
<li>for (int j = 0; j &lt; ContextArray_p-&gt;length; ++j) {</li>
<li>if (!strcmp(ContextArray_p-&gt;SourceContexts_p[j].name_p, Function_p-&gt;arguments_pp[i])) {</li>
<li>Context_p = &amp;ContextArray_p-&gt;SourceContexts_p[j];</li>
<li>}</li>
<li>}</li>
<li>}</li>
<li>else {</li>
<li></li>
<li>if (!Context_p) {</li>
<li>SM_DIAGNOSTIC_END(SM_ERROR_BAD_STATE)</li>
<li>}</li>
<li></li>
<li>if (!Test_p)</li>
<li>{</li>
<li>if (!TestArray_p-&gt;Tests_p) {</li>
<li>TestArray_p-&gt;Tests_p = malloc(sizeof(sm_Test));</li>
<li>SM_CHECK_NULL(TestArray_p-&gt;Tests_p)</li>
<li>}</li>
<li>else {</li>
<li>TestArray_p-&gt;Tests_p = realloc(TestArray_p-&gt;Tests_p, sizeof(sm_Test) * (TestArray_p-&gt;length + 1));</li>
<li>SM_CHECK_NULL(TestArray_p-&gt;Tests_p)</li>
<li>}</li>
<li><br  />
</li>
<li>Test_p = &amp;TestArray_p-&gt;Tests_p[TestArray_p-&gt;length];</li>
<li>*Test_p = sm_initTest();</li>
<li></li>
<li>Test_p-&gt;Context_p = Context_p;</li>
<li>Test_p-&gt;name_p = malloc(strlen(Function_p-&gt;arguments_pp[i]) + 1);</li>
<li>SM_CHECK_NULL(Test_p-&gt;name_p)</li>
<li>sprintf(Test_p-&gt;name_p, Function_p-&gt;arguments_pp[i]);</li>
<li><br  />
</li>
<li>TestArray_p-&gt;length++;</li>
<li><br  />
</li>
<li>SM_BYTE offset_p[64];</li>
<li>sm_getIndentAfterSourceContext(Context_p-&gt;name_p, offset_p, 64, ContextArray_p);</li>
<li>sm_messagef("[%s]%s Add test \"%s\"", Context_p-&gt;name_p, offset_p, Test_p-&gt;name_p);</li>
<li>}</li>
<li>else</li>
<li>{</li>
<li>if (!Test_p-&gt;Arguments_p) {</li>
<li>Test_p-&gt;Arguments_p = malloc(sizeof(sm_TestArgument));</li>
<li>SM_CHECK_NULL(Test_p-&gt;Arguments_p)</li>
<li>}</li>
<li>else {</li>
<li>Test_p-&gt;Arguments_p = realloc(Test_p-&gt;Arguments_p, sizeof(sm_TestArgument) * (Test_p-&gt;arguments + 1));</li>
<li>SM_CHECK_NULL(Test_p-&gt;Arguments_p)</li>
<li>}</li>
<li><br  />
</li>
<li>sm_TestArgument *TestArgument_p = &amp;Test_p-&gt;Arguments_p[Test_p-&gt;arguments];</li>
<li></li>
<li>TestArgument_p-&gt;p = malloc(strlen(Function_p-&gt;arguments_pp[i]) + 1);</li>
<li>SM_CHECK_NULL(TestArgument_p-&gt;p)</li>
<li>sprintf(TestArgument_p-&gt;p, Function_p-&gt;arguments_pp[i]);</li>
<li><br  />
</li>
<li>Test_p-&gt;arguments++;</li>
<li>}</li>
<li>}</li>
<li>}</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>diff &ndash;git a/external/selfmake/src/lib/Test/Test.h b/external/selfmake/src/lib/Test/Test.h deleted file mode 100644 index 3844f3a..0000000 &mdash; a/external/selfmake/src/lib/Test/Test.h +++ /dev/null @ -1,69 +0,0 @ -#ifndef SM_TEST_H -#define SM_TEST_H</li>
<li>-#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-#include "Process.h"</li>
<li>-#include "../Common/Result.h" -#include "../Common/Types.h"</li>
<li>-#endif</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>typedef struct sm_ExternalFunction {</li>
<li>SM_BYTE *libraryName_p;</li>
<li>SM_BYTE *functionName_p;</li>
<li>} sm_ExternalFunction;</li>
<li></li>
<li>typedef struct sm_Test {</li>
<li>sm_SourceContext *Context_p;</li>
<li>SM_BYTE *name_p;</li>
<li>void *dl_p;</li>
<li>int arguments;</li>
<li>sm_TestArgument *Arguments_p;</li>
<li>} sm_Test;</li>
<li></li>
<li>typedef struct sm_TestArray {</li>
<li>int length;</li>
<li>sm_Test *Tests_p;</li>
<li>} sm_TestArray;</li>
<li></li>
<li>typedef struct sm_TestEnvironment {</li>
<li>sm_Process Process;</li>
<li>sm_ExternalFunction *Initializer_p;</li>
<li>sm_ExternalFunction *Loader_p;</li>
<li>sm_TestArray *TestArray_p;</li>
<li>SM_BYTE *target_p;</li>
<li>} sm_TestEnvironment;</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
<li><p class="startli">+#endif diff &ndash;git a/external/selfmake/src/lib/UI/X11.c b/src/lib/nhmake/UI/X11.c similarity index 86% rename from external/selfmake/src/lib/UI/X11.c rename to src/lib/nhmake/UI/X11.c index f626cba..2ee56e5 100644 &mdash; a/external/selfmake/src/lib/UI/X11.c +++ b/src/lib/nhmake/UI/X11.c @ -1,8 +1,8 @ // LICENSE NOTICE ==================================================================================</p>
<p class="startli">/**</p>
</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors<ul>
<li>Published under MIT */</li>
</ul>
</li>
</ul>
<p >@ -14,8 +14,8 @ #include "../Main/Util.h" #include "../Common/Macro.h"</p>
<p >-#include SM_FLOW -#include SM_DEFAULT_CHECK +#include NH_MAKE_FLOW +#include NH_MAKE_DEFAULT_CHECK</p>
<p >#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; @ -29,7 +29,7 @</p>
<p >// DATA ============================================================================================</p>
<p >-static sm_X11 Data; +static nh_make_X11 Data;</p>
<p >// FOR SOFTWARE RENDERING : // @ -75,24 +75,24 @ static sm_X11 Data;</p>
<p >// CREATE WINDOW ===================================================================================</p>
<p >-static SM_RESULT sm_connectToDisplay() +static NH_MAKE_RESULT nh_make_connectToDisplay() { -SM_BEGIN() +NH_MAKE_BEGIN() </p><pre class="fragment"> Data.Display_p = XOpenDisplay(NULL);
</pre><ul>
<li>SM_CHECK_NULL(Data.Display_p)</li>
<li>NH_MAKE_CHECK_NULL(Data.Display_p) Data.screen = DefaultScreen(Data.Display_p); Data.Root = RootWindow(Data.Display_p, Data.screen); Data.white = WhitePixel(Data.Display_p, Data.screen); Data.black = BlackPixel(Data.Display_p, Data.screen);</li>
</ul>
<p >-SM_END(SM_SUCCESS) +NH_MAKE_END(NH_MAKE_SUCCESS) }</p>
<p >-static SM_RESULT sm_createSimpleWindow( +static NH_MAKE_RESULT nh_make_createSimpleWindow(
     int width, int height) { -SM_BEGIN() +NH_MAKE_BEGIN() </p><pre class="fragment"> Data.Window = XCreateSimpleWindow (
     Data.Display_p, Data.Root, 1, 1, width, height, 0, Data.black, Data.white 
</pre><p> @ -105,17 +105,17 @ SM_BEGIN() </p><pre class="fragment"> XMapWindow(Data.Display_p, Data.Window);
</pre><p> -SM_END(SM_SUCCESS) +NH_MAKE_END(NH_MAKE_SUCCESS) }</p>
<p >-static void sm_createGraphicsContext() +static void nh_make_createGraphicsContext() { Data.Gfx = XCreateGC(Data.Display_p, Data.Window, 0, 0); XSetBackground(Data.Display_p, Data.Gfx, Data.white); XSetForeground(Data.Display_p, Data.Gfx, Data.black); }</p>
<p >-static void sm_createFont() +static void nh_make_createFont() { const char <em>fontname_p = "-&lt;/em&gt;-helvetica-*-r-*-*-14-*-*-*-*-*-*-*"; Data.Font_p = XLoadQueryFont(Data.Display_p, fontname_p); @ -127,14 +127,14 @ static void sm_createFont() XSetFont(Data.Display_p, Data.Gfx, Data.Font_p-&gt;fid); }</em></p>
<p ><em>-SM_RESULT sm_X11_createWindow( +NH_MAKE_RESULT nh_make_X11_createWindow(
     char *title_p, int width, int height) { -SM_BEGIN() +NH_MAKE_BEGIN()</em></p>
<p ><em> #ifdef <b>unix</b></em></p>
<p ><em></p><ul>
<li>SM_CHECK(sm_connectToDisplay())</li>
<li><p class="startli">NH_MAKE_CHECK(nh_make_connectToDisplay())</p>
<p class="startli">// keyboard Data.Connection_p = XGetXCBConnection(Data.Display_p); @ -155,9 +155,9 @ SM_BEGIN() );</p>
<p class="startli">// create window</p>
</li>
<li>sm_createSimpleWindow(width, height);</li>
<li>sm_createGraphicsContext();</li>
<li>sm_createFont();</li>
<li>nh_make_createSimpleWindow(width, height);</li>
<li>nh_make_createGraphicsContext();</li>
<li><p class="startli">nh_make_createFont();</p>
<p class="startli">// window delete protocol Data.DeleteAtom = XInternAtom(Data.Display_p, "WM_DELETE_WINDOW", 0); @ -179,18 +179,18 @ SM_BEGIN() XMoveWindow(Data.Display_p, Data.Window, (int)(Screen_p-&gt;width/2) - (int)(width/2), (int)(Screen_p-&gt;height/2) - (int)(height/2)); XSync(Data.Display_p, 0);</p>
</li>
<li>SM_DIAGNOSTIC_END(SM_SUCCESS)</li>
<li><p class="startli">NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS)</p>
<p class="startli">#endif</p>
</li>
</ul>
<p></em></p>
<p ><em>-SM_DIAGNOSTIC_END(SM_ERROR_BAD_STATE) +NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_BAD_STATE) }</em></p>
<p ><em> // DESTROY WINDOW ==================================================================================</em></p>
<p ><em>-SM_RESULT sm_X11_destroyWindow() +NH_MAKE_RESULT nh_make_X11_destroyWindow() { -SM_BEGIN() +NH_MAKE_BEGIN()</em></p>
<p ><em> #ifdef <b>unix</b></em></p>
<p ><em>@ -200,18 +200,18 @ SM_BEGIN() xkb_keymap_unref(Data.Keymap_p); xkb_context_unref(Data.Context_p);</em></p>
<p ><em></p><ul>
<li>SM_DIAGNOSTIC_END(SM_SUCCESS)</li>
<li><p class="startli">NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS)</p>
<p class="startli">#endif</p>
</li>
</ul>
<p></em></p>
<p ><em>-SM_DIAGNOSTIC_END(SM_ERROR_BAD_STATE) +NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_BAD_STATE) }</em></p>
<p ><em> // INPUT ===========================================================================================</em></p>
<p ><em>-SM_RESULT sm_X11_getInput() +NH_MAKE_RESULT nh_make_X11_getInput() { -SM_BEGIN() +NH_MAKE_BEGIN()</em></p>
<p ><em> #ifdef <b>unix</b></em></p>
<p ><em>@ -238,7 +238,7 @ SM_BEGIN() </p><pre class="fragment">     if (Event.type == ClientMessage)
     {   
</pre><ul>
<li>if (Event.xclient.data.l[0] == Data.DeleteAtom) {sm_handleGUIExit();}</li>
<li><p class="startli">if (Event.xclient.data.l[0] == Data.DeleteAtom) {nh_make_handleGUIExit();} else if (Event.type == Expose) {} else if (Event.xclient.message_type == XdndEnter) { @ -308,43 +308,43 @ SM_BEGIN() }</p>
<p class="startli">else if (Event.type == Expose) {</p>
</li>
<li>SM_CHECK(sm_handleGUIExpose())</li>
<li>NH_MAKE_CHECK(nh_make_handleGUIExpose()) } }</li>
<li>SM_DIAGNOSTIC_END(SM_SUCCESS)</li>
<li><p class="startli">NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS)</p>
<p class="startli">#endif</p>
</li>
</ul>
<p></em></p>
<p ><em>-SM_DIAGNOSTIC_END(SM_ERROR_BAD_STATE) +NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_BAD_STATE) }</em></p>
<p ><em> // DRAW ============================================================================================</em></p>
<p ><em>-void sm_X11_drawLine( +void nh_make_X11_drawLine(
     int x1, int y1, int x2, int y2) { -SM_BEGIN() +NH_MAKE_BEGIN() </p><pre class="fragment"> XDrawLine(Data.Display_p, Data.Window, Data.Gfx, x1, y1, x2, y2);
</pre><p> -SM_SILENT_END() +NH_MAKE_SILENT_END() }</em></p>
<p ><em>-void sm_X11_fillRectangle( +void nh_make_X11_fillRectangle(
    int x, int y, int width, int height) { -SM_BEGIN() +NH_MAKE_BEGIN() </p><pre class="fragment"> XFillRectangle(Data.Display_p, Data.Window, Data.Gfx, x, y, width, height);
</pre><p> -SM_SILENT_END() +NH_MAKE_SILENT_END() }</em></p>
<p ><em>-void sm_X11_drawTextLine( +void nh_make_X11_drawTextLine(
     int x, int y, char *text_p) { -SM_BEGIN() +NH_MAKE_BEGIN() </p><pre class="fragment"> int direction;
 int ascent;
</pre><p> @ -377,17 +377,17 @ SM_BEGIN() y += ascent;</em></p>
<p ><em> XDrawString(Data.Display_p, Data.Window, Data.Gfx, x, y, text_p, strlen(text_p));</p><ul>
<li>if (count != 0) {sm_X11_drawTextLine(x, y + descent, text_p + count);}</li>
<li>if (count != 0) {nh_make_X11_drawTextLine(x, y + descent, text_p + count);}</li>
</ul>
<p></em></p>
<p ><em>-SM_SILENT_END() +NH_MAKE_SILENT_END() }</em></p>
<p ><em>-void sm_X11_clearWindow() +void nh_make_X11_clearWindow() { -SM_BEGIN() +NH_MAKE_BEGIN() </p><pre class="fragment"> XClearWindow(Data.Display_p, Data.Window);
</pre><p> -SM_SILENT_END() +NH_MAKE_SILENT_END() }</em></p>
<p ><em>diff &ndash;git a/external/selfmake/src/lib/UI/X11.h b/src/lib/nhmake/UI/X11.h similarity index 66% rename from external/selfmake/src/lib/UI/X11.h rename to src/lib/nhmake/UI/X11.h index 2f4d7da..b4af280 100644 &mdash; a/external/selfmake/src/lib/UI/X11.h +++ b/src/lib/nhmake/UI/X11.h @ -1,11 +1,11 @ -#ifndef SM_X11_H -#define SM_X11_H +#ifndef NH_MAKE_X11_H +#define NH_MAKE_X11_H</em></p>
<p ><em> #ifndef DOXYGEN_SHOULD_SKIP_THIS</em></p>
<p ><em> /**</p><ul>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors<ul>
<li>Published under MIT */</li>
</ul>
</li>
</ul>
<p></em></p>
<p ><em>@ -22,11 +22,11 @</em></p>
<p ><em> #endif</em></p>
<p ><em>-/** +/** </em></p>
</div><!-- contents -->
</div><!-- doc-content -->
  <!-- HTML footer for doxygen 1.8.15-->
  <!-- start footer part -->
  <div id="nav-path" class="navpath">
    <!--  -->
    <!-- <li class="footer">Generated by -->
    <!-- <a href="http://www.doxygen.org/index.html"> -->
    <!-- <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li> -->
    <div id="foot"> 
      <div style="color:#24bbc4;text-align:center;margin:auto;font-size:16px;">
        <b>
[
<!-- NH_MAKE_INSERT_STAGE_BEGIN -->
prototype.1
<!-- NH_MAKE_INSERT_STAGE_END -->
]
[
<!-- NH_MAKE_INSERT_API_VER_BEGIN -->
api.0.2.2.0
<!-- NH_MAKE_INSERT_API_VER_END -->
]
[
<!-- NH_MAKE_INSERT_ACC_VER_BEGIN -->
ver.0.8.23.10
<!-- NH_MAKE_INSERT_ACC_VER_END -->
]
          </b>
        </div>
      </div>
    </div>
  </body>
  <style>
    #foot {display: flex; padding-top:13px; padding-bottom:14px; background: #151515; border-top: 3px solid #24bbc4; justify-content: space-between;}
  </style>
</html>
