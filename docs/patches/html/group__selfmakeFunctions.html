<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.9.2"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Netzhaut | Web Browser Engine | Patches</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="resize.js"></script>
    <script type="text/javascript" src="navtreedata.js"></script>
    <script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/searchdata.js"></script>
    <script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript">
    /* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
      $(document).ready(function() { init_search(); });
    /* @license-end */
    </script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link rel="icon" href="../../logo/favicon.png">
    <link href="../../theme/custom.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>  
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
       <div style="height: 56px;">
        <div style="left:10px;top:5px;position:absolute;">
          <b>Netzhaut</b>
          <br>
          <b>Web Browser Engine</b>
        </div>
        <div style="height:56px;right:10px;top:0px;position:absolute;background-color:#151515;"><a href="https://netzwerkz.org"><img alt="netzwerkz logo" style="height:56px;" src="../../logo/netzwerkz.png"/></a></div>
        <div id="projectlogo"><img alt="netzhaut logo" src="../../logo/netzhaut.png"/></div>
       </div>
      </div>
      <div id="titlearea">
        <div class="topnav">
          <a href="../../index.html">Home</a>
          <a href="../../guides/html/index.html">Guides</a>
          <a href="../../general/html/index.html">General</a>
          <a href="../../architecture/html/index.html">Architecture</a>
          <a href="../../design/html/index.html">Design</a>
          <a href="../../internals/html/index.html">Internals</a>
          <a href="../../api/html/index.html">API</a>
          <a href="../../changelogs/html/index.html">Changelogs</a>
          <a class="active" href="../../patches/html/index.html">Patches</a>
        </div>
       </div>
      </div>
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__selfmakeFunctions.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Functions<div class="ingroups"><a class="el" href="group__selfmake.html">selfmake internal</a></div></div></div>
</div><!--header-->
<div class="contents">
<ul>
<li><p class="startli">* +/**</p>
<p class="startli">*/</p>
</li>
<li>-#endif diff --git a/external/selfmake/src/bin/smmake/Main.c b/external/selfmake/src/bin/smmake/Main.c deleted file mode 100644 index 07010e2..0000000 --- a/external/selfmake/src/bin/smmake/Main.c +++ /dev/null @ -1,85 +0,0 @ -// LICENSE NOTICE ==================================================================================</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-// INCLUDE =========================================================================================</li>
<li>-#include "Version.h" -#include "Documents.h"</li>
<li>-#include "../../../include/selfmake/selfmake.h"</li>
<li>-#include &amp;ltstdio.h&gt; -#include &amp;ltstring.h&gt; -#include &amp;ltstdlib.h&gt; -#include &amp;ltctype.h&gt;</li>
<li>-// MAIN ============================================================================================</li>
<li>-static SM_RESULT sourceContextCallback(</li>
<li>sm_Runtime *Runtime_p, sm_SourceContext *SourceContext_p) -{</li>
<li>if (!strcmp(SourceContext_p-&gt;name_p, "selfmake"))</li>
<li>{</li>
<li>int versionNums_p[4];</li>
<li>long versionDates_pp[4][3];</li>
<li>getVersionData(versionNums_p, versionDates_pp);</li>
<li>SourceContext_p-&gt;api = versionNums_p[0];</li>
<li>SourceContext_p-&gt;major = versionNums_p[1];</li>
<li>SourceContext_p-&gt;minor = versionNums_p[2];</li>
<li>SourceContext_p-&gt;patch = versionNums_p[3];</li>
<li>}</li>
<li></li>
<li>return SM_SUCCESS; -}</li>
<li>-static SM_RESULT functionCallback(</li>
<li>sm_Runtime *Runtime_p, sm_Function *Function_p) -{</li>
<li>if (!strcmp(Function_p-&gt;name_p, "generateFooter")) {</li>
<li>generateFooter(Runtime_p);</li>
<li>}</li>
<li>else if (!strcmp(Function_p-&gt;name_p, "generateHomepage")) {</li>
<li>generateHomepage(Runtime_p);</li>
<li>}</li>
<li></li>
<li>return SM_SUCCESS; -}</li>
<li>-int main(</li>
<li>int argc, char **argv_pp) -{</li>
<li>sm_initialize();</li>
<li></li>
<li>sm_Runtime *Runtime_p = sm_createRuntime("smmake");</li>
<li>if (!Runtime_p) {return 1;}</li>
<li></li>
<li>SM_BYTE *wrkDir_p = malloc(255);</li>
<li>if (!wrkDir_p) {return 1;}</li>
<li>SM_BYTE *version_p = malloc(255);</li>
<li>if (!version_p) {return 1;}</li>
<li></li>
<li>sprintf(wrkDir_p, "%s/..", sm_getProcessDirectory());</li>
<li>getProjectVersion(Runtime_p, version_p);</li>
<li></li>
<li>sm_setVariable(Runtime_p, "PROJ_REV", &amp;version_p, 1);</li>
<li>sm_setVariable(Runtime_p, "WRK_DIR", &amp;wrkDir_p, 1);</li>
<li></li>
<li>sm_addFile(Runtime_p, "build/.sm/smmake.sm");</li>
<li>sm_setFunctionCallback(Runtime_p, functionCallback);</li>
<li>sm_setSourceContextCallback(Runtime_p, sourceContextCallback);</li>
<li></li>
<li>if (sm_run(Runtime_p, argc - 1, argv_pp + 1)) {return 1;}</li>
<li></li>
<li>while (sm_isRunning()) {sm_sleepMs(100);}</li>
<li></li>
<li>sm_destroyRuntime(Runtime_p);</li>
<li>sm_terminate();</li>
<li></li>
<li>return 0; -}</li>
<li>diff --git a/external/selfmake/src/bin/smmake/Version.c b/external/selfmake/src/bin/smmake/Version.c deleted file mode 100644 index 047e85d..0000000 --- a/external/selfmake/src/bin/smmake/Version.c +++ /dev/null @ -1,112 +0,0 @ -// LICENSE NOTICE ==================================================================================</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-// INCLUDE =========================================================================================</li>
<li>-#include "Version.h"</li>
<li>-#include &amp;ltstdio.h&gt; -#include &amp;ltstring.h&gt; -#include &amp;ltstdlib.h&gt; -#include &amp;ltctype.h&gt;</li>
<li>-// VERSION =========================================================================================</li>
<li>-static long getVersion(</li>
<li>SM_BYTE *data_p, SM_BYTE *macro_p) -{</li>
<li>SM_BYTE *p = strstr(data_p, macro_p);</li>
<li>if (!p) {return 0;}</li>
<li>p += strlen(macro_p);</li>
<li>long val = strtol(p, &amp;p, 10);</li>
<li></li>
<li>return val; -}</li>
<li>-static void getVersionDate(</li>
<li>SM_BYTE *data_p, SM_BYTE *macro_p, long date_p[3]) -{</li>
<li>date_p[0] = 0;</li>
<li>date_p[1] = 0;</li>
<li>date_p[2] = 0;</li>
<li></li>
<li>SM_BYTE *p = strstr(data_p, macro_p);</li>
<li>if (!p) {return;}</li>
<li></li>
<li>while (p[0] != '/' || p[1] != '*' || p[2] != '*') {p--;}</li>
<li>while (*p &amp;&amp; !isdigit(*p++)) {}</li>
<li>if (!*p) {return;}</li>
<li></li>
<li>p--;</li>
<li></li>
<li>date_p[0] = strtol(p, &amp;p, 10);</li>
<li>p++;</li>
<li>date_p[1] = strtol(p, &amp;p, 10);</li>
<li>p++;</li>
<li>date_p[2] = strtol(p, &amp;p, 10);</li>
<li>p++; -}</li>
<li>-SM_RESULT getVersionData(</li>
<li>int version_p[4], long versionDates_pp[4][3]) -{</li>
<li>SM_BYTE *api_p = "SM_API_VERSION";</li>
<li>SM_BYTE *major_p = "SM_MAJOR_VERSION";</li>
<li>SM_BYTE *minor_p = "SM_MINOR_VERSION";</li>
<li>SM_BYTE *patch_p = "SM_PATCH_VERSION";</li>
<li></li>
<li>SM_BYTE path_p[512];</li>
<li>sprintf(path_p, "src/lib/Common/About.h");</li>
<li></li>
<li>SM_BYTE *data_p = sm_getFileData(path_p, NULL);</li>
<li>if (!data_p) {return SM_ERROR_BAD_STATE;}</li>
<li></li>
<li>version_p[0] = getVersion(data_p, api_p);</li>
<li>version_p[1] = getVersion(data_p, major_p);</li>
<li>version_p[2] = getVersion(data_p, minor_p);</li>
<li>version_p[3] = getVersion(data_p, patch_p);</li>
<li></li>
<li>getVersionDate(data_p, api_p, versionDates_pp[0]);</li>
<li>getVersionDate(data_p, major_p, versionDates_pp[1]);</li>
<li>getVersionDate(data_p, minor_p, versionDates_pp[2]);</li>
<li>getVersionDate(data_p, patch_p, versionDates_pp[3]);</li>
<li></li>
<li>free(data_p);</li>
<li></li>
<li>return SM_SUCCESS; -}</li>
<li>-void getProjectVersion(</li>
<li>sm_Runtime *Runtime_p, SM_BYTE *version_p) -{</li>
<li>sm_ValueArray Stage = sm_getVariableValues(Runtime_p, "PROJ_STAGE");</li>
<li></li>
<li>int versionNums_p[4];</li>
<li>long versionDates_pp[4][3];</li>
<li>getVersionData(versionNums_p, versionDates_pp);</li>
<li></li>
<li>sm_ValueArray LangVer = sm_getVariableValues(Runtime_p, "LANG_VER");</li>
<li></li>
<li>if (LangVer.length &amp;&amp; Stage.length) {</li>
<li>sprintf(version_p, "v%d.%d.%d.%d-%s %s", versionNums_p[0], versionNums_p[1], versionNums_p[2],</li>
<li>versionNums_p[3], LangVer.values_pp[0], Stage.values_pp[0]);</li>
<li>}</li>
<li>else if (LangVer.length) {</li>
<li>sprintf(version_p, "v%d.%d.%d.%d-%s", versionNums_p[0], versionNums_p[1], versionNums_p[2],</li>
<li>versionNums_p[3], LangVer.values_pp[0]);</li>
<li>}</li>
<li>else if (Stage.length) {</li>
<li>sprintf(version_p, "v%d.%d.%d.%d %s", versionNums_p[0], versionNums_p[1], versionNums_p[2],</li>
<li>versionNums_p[3], Stage.values_pp[0]);</li>
<li>}</li>
<li>else {</li>
<li>sprintf(version_p, "v%d.%d.%d.%d", versionNums_p[0], versionNums_p[1], versionNums_p[2],</li>
<li>versionNums_p[3]);</li>
<li>} -}</li>
<li>diff --git a/external/selfmake/src/bin/smmake/Version.h b/external/selfmake/src/bin/smmake/Version.h deleted file mode 100644 index d1743bd..0000000 --- a/external/selfmake/src/bin/smmake/Version.h +++ /dev/null @ -1,30 +0,0 @ -#ifndef VERSION_H -#define VERSION_H</li>
<li>-#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-#include "../../../include/selfmake/selfmake.h"</li>
<li>-#endif</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>SM_RESULT getVersionData(</li>
<li>int version_p[3], long versionDates_pp[3][3]</li>
<li>);</li>
<li></li>
<li>void getProjectVersion(</li>
<li>sm_Runtime *Runtime_p, SM_BYTE *version_p</li>
<li>);</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
<li>-#endif diff --git a/external/selfmake/src/lib/Core/Binaries.c b/external/selfmake/src/lib/Core/Binaries.c deleted file mode 100644 index b327a73..0000000 --- a/external/selfmake/src/lib/Core/Binaries.c +++ /dev/null @ -1,151 +0,0 @ -// LICENSE NOTICE ==================================================================================</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-// INCLUDE =========================================================================================</li>
<li>-#include "Binaries.h" -#include "Util.h" -#include "Main.h"</li>
<li>-#include "../Common/Macro.h"</li>
<li>-#include SM_FLOW -#include SM_CUSTOM_CHECK</li>
<li>-#include &amp;ltstdio.h&gt; -#include &amp;ltstdlib.h&gt; -#include &amp;ltstring.h&gt; -#include &amp;ltunistd.h&gt;</li>
<li>-// BUILD BINARY ====================================================================================</li>
<li>-SM_RESULT sm_buildnhterminal() -{ -SM_BEGIN()</li>
<li></li>
<li>char projDir_p[2048] = {'\0'};</li>
<li>SM_CHECK(SM_ERROR_GET_PROJECT_DIRECTORY, sm_getProjectDir(projDir_p, 2048))</li>
<li></li>
<li>// set -no-pie because of <a href="https://stackoverflow.com/questions/41398444/gcc-creates-mime-type-application-x-sharedlib-instead-of-application-x-applicati">https://stackoverflow.com/questions/41398444/gcc-creates-mime-type-application-x-sharedlib-instead-of-application-x-applicati</a></li>
<li>static char command_p[2048] = {'\0'};</li>
<li>sprintf(command_p, "gcc -std=gnu99 -Wl,-rpath=%s/lib:/usr/local/lib -o%s/bin/nhterminal -no-pie -L%s/lib -lnetzhaut %s/src/bin/nhterminal/Terminal.c", projDir_p, projDir_p, projDir_p, projDir_p);</li>
<li></li>
<li>int status = system(command_p);</li>
<li>if (WEXITSTATUS(status) || WIFSIGNALED(status)) {SM_DIAGNOSTIC_END(SM_ERROR_GCC_EXECUTION_FAILED)}</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-SM_RESULT sm_buildnhwebbrowser() -{ -SM_BEGIN()</li>
<li></li>
<li>char projDir_p[2048] = {'\0'};</li>
<li>SM_CHECK(SM_ERROR_GET_PROJECT_DIRECTORY, sm_getProjectDir(projDir_p, 2048))</li>
<li></li>
<li>// set -no-pie because of <a href="https://stackoverflow.com/questions/41398444/gcc-creates-mime-type-application-x-sharedlib-instead-of-application-x-applicati">https://stackoverflow.com/questions/41398444/gcc-creates-mime-type-application-x-sharedlib-instead-of-application-x-applicati</a></li>
<li>static char command_p[2048] = {'\0'};</li>
<li>sprintf(command_p, "gcc -std=gnu99 -Wl,-rpath=%s/lib:/usr/local/lib -o%s/bin/nhwebbrowser -no-pie -L%s/lib -lnetzhaut %s/src/bin/nhwebbrowser/WebBrowser.c", projDir_p, projDir_p, projDir_p, projDir_p);</li>
<li></li>
<li>int status = system(command_p);</li>
<li>if (WEXITSTATUS(status) || WIFSIGNALED(status)) {SM_DIAGNOSTIC_END(SM_ERROR_GCC_EXECUTION_FAILED)}</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-// INSTALL BINARY ==================================================================================</li>
<li>-SM_RESULT sm_installnhterminal() -{ -SM_BEGIN()</li>
<li></li>
<li>char wrkDir_p[2048] = {'\0'};</li>
<li>SM_CHECK_NULL(SM_ERROR_GET_WORK_DIRECTORY, getcwd(wrkDir_p, 2048))</li>
<li></li>
<li>char projDir_p[2048] = {'\0'};</li>
<li>SM_CHECK(SM_ERROR_GET_PROJECT_DIRECTORY, sm_getProjectDir(projDir_p, 2048))</li>
<li></li>
<li>chdir(projDir_p);</li>
<li></li>
<li>const char *homedir_p = sm_getHomeDir();</li>
<li>char dest_p[512] = {'\0'};</li>
<li></li>
<li>sprintf(dest_p, "%s/.local/share/applications/", homedir_p);</li>
<li>SM_CHECK(SM_ERROR_COPY_FAILED, sm_copy("src/bin/nhterminal/Common/Data/nhterminal.desktop", dest_p, SM_FALSE, SM_FALSE))</li>
<li>SM_CHECK(SM_ERROR_COPY_FAILED, sm_copy("bin/nhterminal", "/usr/local/bin", SM_FALSE, SM_TRUE))</li>
<li></li>
<li>chdir(wrkDir_p);</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-SM_RESULT sm_installnhwebbrowser() -{ -SM_BEGIN()</li>
<li></li>
<li>char wrkDir_p[2048] = {'\0'};</li>
<li>SM_CHECK_NULL(SM_ERROR_GET_WORK_DIRECTORY, getcwd(wrkDir_p, 2048))</li>
<li></li>
<li>char projDir_p[2048] = {'\0'};</li>
<li>SM_CHECK(SM_ERROR_GET_PROJECT_DIRECTORY, sm_getProjectDir(projDir_p, 2048))</li>
<li></li>
<li>chdir(projDir_p);</li>
<li></li>
<li>const char *homedir_p = sm_getHomeDir();</li>
<li>char dest_p[512] = {'\0'};</li>
<li></li>
<li>sprintf(dest_p, "%s/.local/share/applications/", homedir_p);</li>
<li>SM_CHECK(SM_ERROR_COPY_FAILED, sm_copy("src/bin/nhwebbrowser/Common/Data/nhwebbrowser.desktop", dest_p, SM_FALSE, SM_FALSE))</li>
<li>SM_CHECK(SM_ERROR_COPY_FAILED, sm_copy("bin/nhwebbrowser", "/usr/local/bin", SM_FALSE, SM_TRUE))</li>
<li></li>
<li>chdir(wrkDir_p);</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-// INSTALL LOGO ====================================================================================</li>
<li>-SM_RESULT sm_installLogo() -{ -SM_BEGIN()</li>
<li></li>
<li>char wrkDir_p[2048] = {'\0'};</li>
<li>SM_CHECK_NULL(SM_ERROR_GET_WORK_DIRECTORY, getcwd(wrkDir_p, 2048))</li>
<li></li>
<li>char projDir_p[2048] = {'\0'};</li>
<li>SM_CHECK(SM_ERROR_GET_PROJECT_DIRECTORY, sm_getProjectDir(projDir_p, 2048))</li>
<li></li>
<li>chdir(projDir_p);</li>
<li></li>
<li>const char *homedir_p = sm_getHomeDir();</li>
<li>char dest_p[512] = {'\0'};</li>
<li></li>
<li>sprintf(dest_p, "%s/.local/share/icons/hicolor/32x32/apps", homedir_p);</li>
<li>SM_CHECK(SM_ERROR_COPY_FAILED, sm_copy("docs/Logo/32x32/netzhaut.png", dest_p, SM_FALSE, SM_TRUE))</li>
<li></li>
<li>memset(dest_p, '\0', sizeof(char) * 512);</li>
<li>sprintf(dest_p, "%s/.local/share/icons/hicolor/64x64/apps", homedir_p);</li>
<li>SM_CHECK(SM_ERROR_COPY_FAILED, sm_copy("docs/Logo/64x64/netzhaut.png", dest_p, SM_FALSE, SM_TRUE))</li>
<li></li>
<li>memset(dest_p, '\0', sizeof(char) * 512);</li>
<li>sprintf(dest_p, "%s/.local/share/icons/hicolor/128x128/apps", homedir_p);</li>
<li>SM_CHECK(SM_ERROR_COPY_FAILED, sm_copy("docs/Logo/128x128/netzhaut.png", dest_p, SM_FALSE, SM_TRUE))</li>
<li></li>
<li>memset(dest_p, '\0', sizeof(char) * 512);</li>
<li>sprintf(dest_p, "%s/.local/share/icons/hicolor/256x256/apps", homedir_p);</li>
<li>SM_CHECK(SM_ERROR_COPY_FAILED, sm_copy("docs/Logo/256x256/netzhaut.png", dest_p, SM_FALSE, SM_TRUE))</li>
<li></li>
<li>memset(dest_p, '\0', sizeof(char) * 512);</li>
<li>sprintf(dest_p, "%s/.local/share/icons/hicolor/512x512/apps", homedir_p);</li>
<li>SM_CHECK(SM_ERROR_COPY_FAILED, sm_copy("docs/Logo/512x512/netzhaut.png", dest_p, SM_FALSE, SM_TRUE))</li>
<li></li>
<li>chdir(wrkDir_p);</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>diff --git a/external/selfmake/src/lib/Core/Build.c b/external/selfmake/src/lib/Core/Build.c deleted file mode 100644 index 079b940..0000000 --- a/external/selfmake/src/lib/Core/Build.c +++ /dev/null @ -1,345 +0,0 @ -// LICENSE NOTICE ==================================================================================</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-// INCLUDE =========================================================================================</li>
<li>-#include "Build.h" -#include "Utils.h"</li>
<li>-#include "../UI/Message.h" -#include "../Common/Macros/Macros.h"</li>
<li>-#include SM_FLOW -#include SM_DEFAULT_CHECK</li>
<li>-#include &amp;ltstdio.h&gt; -#include &amp;ltstdlib.h&gt; -#include &amp;ltstring.h&gt; -#include &amp;ltunistd.h&gt; -#include &amp;ltpthread.h&gt; -#include &amp;ltdirent.h&gt; -#include &amp;lterrno.h&gt;</li>
<li>-// CREATE BINARY ===================================================================================</li>
<li>-static SM_RESULT sm_createBinary(</li>
<li>sm_Runtime *Runtime_p, sm_SourceContext *SourceContext_p) -{ -SM_BEGIN()</li>
<li></li>
<li>chdir(SourceContext_p-&gt;path_p);</li>
<li></li>
<li>SM_BYTE binPath_p[256] = {'\0'};</li>
<li>sprintf(binPath_p, "%s/%s", sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "BIN_DEST")-&gt;values_pp[0], SourceContext_p-&gt;name_p);</li>
<li>if (SourceContext_p-&gt;outputPath_p) {</li>
<li>sprintf(binPath_p, "%s/%s", SourceContext_p-&gt;outputPath_p, SourceContext_p-&gt;name_p);</li>
<li>}</li>
<li></li>
<li>int length = 0;</li>
<li>for (int i = 0; i &amp;lt Runtime_p-&gt;SourceArray.length; ++i) {</li>
<li>sm_Source *Source_p = &amp;Runtime_p-&gt;SourceArray.Sources_p[i];</li>
<li>if (Source_p-&gt;Context_p == SourceContext_p) {</li>
<li>length += strlen(Source_p-&gt;path_p) + 1;</li>
<li>}</li>
<li>}</li>
<li></li>
<li>SM_BYTE *sources_p = malloc(length + 1);</li>
<li>SM_CHECK_NULL(sources_p)</li>
<li>memset(sources_p, 0, length + 1);</li>
<li></li>
<li>int offset = 0;</li>
<li>for (int i = 0; i &amp;lt Runtime_p-&gt;SourceArray.length; ++i) {</li>
<li>sm_Source *Source_p = &amp;Runtime_p-&gt;SourceArray.Sources_p[i];</li>
<li>if (Source_p-&gt;Context_p == SourceContext_p) {</li>
<li>sprintf(sources_p + strlen(sources_p), "%s ", Source_p-&gt;path_p);</li>
<li>}</li>
<li>}</li>
<li></li>
<li>int compileArgsLength = SourceContext_p-&gt;compileArgs_p ? strlen(SourceContext_p-&gt;compileArgs_p) : 0;</li>
<li>int linkArgsLength = SourceContext_p-&gt;linkArgs_p ? strlen(SourceContext_p-&gt;linkArgs_p) : 0;</li>
<li>int commandLength = strlen(sources_p) + compileArgsLength + linkArgsLength + strlen(binPath_p) + 128;</li>
<li>SM_BYTE *command_p = malloc(commandLength);</li>
<li>SM_CHECK_NULL(command_p)</li>
<li>memset(command_p, 0, commandLength);</li>
<li></li>
<li>SM_BYTE empty = 0;</li>
<li>SM_BYTE *linkArgs_p = SourceContext_p-&gt;linkArgs_p ? SourceContext_p-&gt;linkArgs_p : &empty;</li>
<li>SM_BYTE *compileArgs_p = SourceContext_p-&gt;compileArgs_p ? SourceContext_p-&gt;compileArgs_p : &empty;</li>
<li></li>
<li>// set -no-pie because of <a href="https://stackoverflow.com/questions/41398444/gcc-creates-mime-type-application-x-sharedlib-instead-of-application-x-applicati">https://stackoverflow.com/questions/41398444/gcc-creates-mime-type-application-x-sharedlib-instead-of-application-x-applicati</a></li>
<li>sprintf(command_p, "gcc %s -o%s -no-pie %s %s", compileArgs_p, binPath_p, linkArgs_p, sources_p);</li>
<li>sm_messagef(command_p);</li>
<li></li>
<li>int status = system(command_p);</li>
<li>if (WEXITSTATUS(status) || WIFSIGNALED(status)) {SM_DIAGNOSTIC_END(SM_ERROR_GCC_EXECUTION_FAILED)}</li>
<li></li>
<li>chdir(sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "WRK_DIR")-&gt;values_pp[0]);</li>
<li></li>
<li>free(command_p);</li>
<li>free(sources_p);</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-// CREATE LIBRARY ==================================================================================</li>
<li>-static SM_RESULT sm_createSharedLibraryUsingGCC(</li>
<li>const SM_BYTE *objects_p, const SM_BYTE *out_p, SM_BYTE *compile_p, const SM_BYTE *link_p) -{ -SM_BEGIN()</li>
<li></li>
<li>static SM_BYTE command_p[16384] = {'\0'};</li>
<li></li>
<li>sprintf(command_p, "gcc -shared %s %s %s -o %s", objects_p, compile_p, link_p, out_p);</li>
<li>sm_messagef(command_p);</li>
<li></li>
<li>int status = system(command_p);</li>
<li>if (WEXITSTATUS(status) || WIFSIGNALED(status)) {SM_DIAGNOSTIC_END(SM_ERROR_GCC_EXECUTION_FAILED)}</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-static SM_RESULT sm_createLibrary(</li>
<li>sm_Runtime *Runtime_p, sm_SourceContext *Context_p) -{ -SM_BEGIN()</li>
<li></li>
<li>SM_BYTE empty = 0;</li>
<li>SM_BYTE *libName_p = Context_p-&gt;name_p;</li>
<li>SM_BYTE *linkArgs_p = Context_p-&gt;linkArgs_p ? Context_p-&gt;linkArgs_p : &empty;</li>
<li>SM_BYTE *compileArgs_p = Context_p-&gt;compileArgs_p ? Context_p-&gt;compileArgs_p : &empty;</li>
<li></li>
<li>int api = Context_p-&gt;api;</li>
<li>int major = Context_p-&gt;major;</li>
<li>int minor = Context_p-&gt;minor;</li>
<li>int patch = Context_p-&gt;patch;</li>
<li></li>
<li>SM_BYTE tmp_p[255] = {0};</li>
<li>sprintf(tmp_p, "/tmp/%s", sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "NAME")-&gt;values_pp[0]);</li>
<li>chdir(tmp_p);</li>
<li>-#if defined(__linux__) || defined(__APPLE__)</li>
<li></li>
<li>int index = 0;</li>
<li>SM_BYTE objects_p[16384] = {'\0'};</li>
<li></li>
<li>DIR *dir;</li>
<li>struct dirent *ent;</li>
<li></li>
<li>if ((dir = opendir(tmp_p)) != NULL)</li>
<li>{</li>
<li>while ((ent = readdir(dir)) != NULL) {</li>
<li>for (int i = 0; ent-&gt;d_name[i] != '\0' &amp;&amp; ent-&gt;d_name[0] != '.'; ++i) {</li>
<li>objects_p[index++] = ent-&gt;d_name[i];</li>
<li>}</li>
<li>objects_p[index++] = ' ';</li>
<li>}</li>
<li>closedir(dir);</li>
<li>}</li>
<li>else {SM_DIAGNOSTIC_END(SM_ERROR_CANT_OPEN_DIR)}</li>
<li></li>
<li>SM_BYTE *dest_p = sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "LIB_DEST")-&gt;values_pp[0];</li>
<li>if (Context_p-&gt;outputPath_p) {dest_p = Context_p-&gt;outputPath_p;}</li>
<li></li>
<li>SM_BYTE libPath_p[256] = {'\0'};</li>
<li>sprintf(libPath_p, "%s/lib%s.so.%d.%d.%d.%d", dest_p, libName_p, api, major, minor, patch);</li>
<li>SM_BYTE symPath1_p[256] = {'\0'};</li>
<li>sprintf(symPath1_p, "%s/lib%s.so.%d", dest_p, libName_p, api);</li>
<li>SM_BYTE symPath2_p[256] = {'\0'};</li>
<li>sprintf(symPath2_p, "%s/lib%s.so", dest_p, libName_p);</li>
<li></li>
<li>SM_CHECK(sm_createSharedLibraryUsingGCC(objects_p, libPath_p, compileArgs_p, linkArgs_p))</li>
<li></li>
<li>memset(libPath_p, 0, 256);</li>
<li>sprintf(libPath_p, "lib%s.so.%d.%d.%d.%d", libName_p, api, major, minor, patch);</li>
<li>sm_createSymLink(libPath_p, symPath1_p, SM_FALSE);</li>
<li>sm_createSymLink(libPath_p, symPath2_p, SM_FALSE);</li>
<li>-#endif</li>
<li></li>
<li>chdir(sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "WRK_DIR")-&gt;values_pp[0]);</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-// COMPILE =========================================================================================</li>
<li>-static void sm_getObjectFileName(</li>
<li>sm_Source *Source_p, SM_BYTE *name_p) -{ -SM_BEGIN()</li>
<li></li>
<li>SM_BYTE path_p[255] = {0};</li>
<li>strcpy(path_p, Source_p-&gt;path_p);</li>
<li></li>
<li>int index = strlen(path_p) - 1;</li>
<li>while (path_p[index] != '/' &amp;&amp; index) {index--;}</li>
<li></li>
<li>SM_BYTE fileName_p[255] = {0};</li>
<li>strcpy(fileName_p, index ? path_p + index + 1 : path_p);</li>
<li></li>
<li>int tmp = index ? index - 1 : 0;</li>
<li>while (path_p[tmp] != '/' &amp;&amp; tmp) {tmp--;}</li>
<li></li>
<li>if (index) {</li>
<li>path_p[index] = '\0';</li>
<li>sprintf(name_p, "%s%s.o", path_p + tmp, fileName_p);</li>
<li>}</li>
<li>else {</li>
<li>sprintf(name_p, "%s.o", fileName_p);</li>
<li>}</li>
<li>-SM_SILENT_END() -}</li>
<li>-static SM_RESULT sm_createPICObjectFileUsingGCC(</li>
<li>const SM_BYTE *in_p, const SM_BYTE *out_p, SM_BYTE *compileArgs_p) -{ -SM_BEGIN()</li>
<li></li>
<li>SM_BYTE realout_p[1024] = {'\0'};</li>
<li>realpath(out_p, realout_p);</li>
<li></li>
<li>SM_BYTE command_p[1024] = {'\0'};</li>
<li></li>
<li>if (compileArgs_p != NULL) {sprintf(command_p, "gcc -fPIC %s -c %s -o %s", compileArgs_p, in_p, out_p);}</li>
<li>else {sprintf(command_p, "gcc -fPIC -c %s -o %s", in_p, out_p);}</li>
<li></li>
<li>sm_messagef(command_p);</li>
<li></li>
<li>int status = system(command_p);</li>
<li>if (WEXITSTATUS(status) || WIFSIGNALED(status)) {SM_DIAGNOSTIC_END(SM_ERROR_GCC_EXECUTION_FAILED)}</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-static SM_RESULT sm_compileFiles(</li>
<li>sm_Runtime *Runtime_p, sm_SourceContext *Context_p) -{ -SM_BEGIN()</li>
<li></li>
<li>chdir(Context_p-&gt;path_p);</li>
<li></li>
<li>for (int i = 0; i &amp;lt Runtime_p-&gt;SourceArray.length; ++i)</li>
<li>{</li>
<li>sm_Source *Source_p = &amp;Runtime_p-&gt;SourceArray.Sources_p[i];</li>
<li></li>
<li>if (Source_p-&gt;Context_p == Context_p)</li>
<li>{</li>
<li>SM_BYTE tmp_p[255] = {0};</li>
<li>SM_BYTE fileName_p[255] = {0};</li>
<li>sm_getObjectFileName(Source_p, fileName_p);</li>
<li></li>
<li>sprintf(tmp_p, "/tmp/%s/%s", sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "NAME")-&gt;values_pp[0], fileName_p);</li>
<li>SM_BYTE empty = 0;</li>
<li></li>
<li>if (Context_p-&gt;type == SM_SOURCE_CONTEXT_SHARED_LIBRARY) {</li>
<li>SM_CHECK(sm_createPICObjectFileUsingGCC(</li>
<li>Source_p-&gt;path_p, tmp_p, Context_p-&gt;compileArgs_p ? Context_p-&gt;compileArgs_p : &amp;empty</li>
<li>))</li>
<li>}</li>
<li>}</li>
<li>}</li>
<li></li>
<li>chdir(sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "WRK_DIR")-&gt;values_pp[0]);</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-// INSTALL =========================================================================================</li>
<li>-//static SM_RESULT sm_installLibrary( -// SM_BYTE *libName_p, int major, int minor, int patch) -//{ -//SM_BEGIN() -// -// SM_BYTE wrkDir_p[2048] = {'\0'}; -// SM_CHECK_NULL(SM_ERROR_GET_WORK_DIRECTORY, getcwd(wrkDir_p, 2048)) -// -// SM_BYTE projDir_p[2048] = {'\0'}; -// SM_CHECK(SM_ERROR_GET_PROJECT_DIRECTORY, sm_getProjectDir(projDir_p, 2048)) -// -// chdir(projDir_p); -// -// SM_BYTE libPath_p[512] = {'\0'}; -// sprintf(libPath_p, "lib/lib%s.so.%d.%d.%d", libName_p, major, minor, patch); -// -// SM_CHECK(SM_ERROR_COPY_FAILED, sm_copy(libPath_p, "/usr/local/lib", SM_FALSE, SM_TRUE)) -// -// chdir("/usr/local/lib"); -// -// SM_BYTE cpyPath_p[256] = {'\0'}; -// sprintf(cpyPath_p, "lib%s.so.%d.%d.%d", libName_p, major, minor, patch); -// SM_BYTE symPath1_p[256] = {'\0'}; -// sprintf(symPath1_p, "lib%s.so.%d", libName_p, major); -// SM_BYTE symPath2_p[256] = {'\0'}; -// sprintf(symPath2_p, "lib%s.so", libName_p); -// -// sm_createSymLink(cpyPath_p, symPath1_p, SM_TRUE); -// sm_createSymLink(cpyPath_p, symPath2_p, SM_TRUE); -// -// chdir(wrkDir_p); -// -//SM_DIAGNOSTIC_END(SM_SUCCESS) -//}</li>
<li>-// BUILD ===========================================================================================</li>
<li>-static SM_RESULT sm_buildSourceContext(</li>
<li>sm_Runtime *Runtime_p, sm_SourceContext *Context_p) -{ -SM_BEGIN()</li>
<li></li>
<li>SM_BYTE empty = 0;</li>
<li>SM_BYTE tmp_p[255];</li>
<li>sprintf(tmp_p, "/tmp/%s", sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "NAME")-&gt;values_pp[0]);</li>
<li></li>
<li>SM_CHECK(sm_createDir(tmp_p))</li>
<li></li>
<li>if (Runtime_p-&gt;beforeBuildCallback_f) {</li>
<li>SM_CHECK(Runtime_p-&gt;beforeBuildCallback_f(Runtime_p, Context_p))</li>
<li>}</li>
<li></li>
<li>if (Context_p-&gt;type == SM_SOURCE_CONTEXT_BINARY) {</li>
<li>SM_CHECK(sm_createBinary(Runtime_p, Context_p))</li>
<li>}</li>
<li>else {</li>
<li>SM_CHECK(sm_compileFiles(Runtime_p, Context_p))</li>
<li>SM_CHECK(sm_createLibrary(Runtime_p, Context_p))</li>
<li>}</li>
<li></li>
<li>if (Runtime_p-&gt;afterBuildCallback_f) {</li>
<li>SM_CHECK(Runtime_p-&gt;afterBuildCallback_f(Runtime_p, Context_p))</li>
<li>}</li>
<li>-// if (install) { -// SM_CHECK(SM_ERROR_BAD_STATE, sm_installLibrary( -// Library_p-&gt;name_p, 0, 0, 0 -// )) -// }</li>
<li></li>
<li>SM_CHECK(sm_removeDir(tmp_p))</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-SM_RESULT sm_build(</li>
<li>sm_Runtime *Runtime_p, SM_BYTE *name_p) -{ -SM_BEGIN()</li>
<li></li>
<li>for (int i = 0; i &amp;lt Runtime_p-&gt;SourceContextArray.length; ++i) {</li>
<li>sm_SourceContext *SourceContext_p = &amp;Runtime_p-&gt;SourceContextArray.SourceContexts_p[i];</li>
<li>if (!strcmp(SourceContext_p-&gt;name_p, name_p)) {</li>
<li>SM_CHECK(sm_buildSourceContext(Runtime_p, SourceContext_p))</li>
<li>}</li>
<li>}</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>diff --git a/external/selfmake/src/lib/Core/Build.h b/external/selfmake/src/lib/Core/Build.h deleted file mode 100644 index c54b5cf..0000000 --- a/external/selfmake/src/lib/Core/Build.h +++ /dev/null @ -1,28 +0,0 @ -#ifndef SM_BUILD_H -#define SM_BUILD_H</li>
<li>-#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-#include "../Parser/Functions.h" -#include "../Common/Result.h" -#include "../Common/Types.h"</li>
<li>-#endif</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>SM_RESULT sm_build(</li>
<li>sm_Runtime *Runtime_p, SM_BYTE *name_p</li>
<li>);</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>SM_RESULT sm_executeRuntime(</li>
<li>sm_Runtime *Runtime_p, SM_BYTE **args_pp, int args</li>
<li>);</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>SM_BOOL sm_canFindSharedLib(</li>
<li>const SM_BYTE *lib_p</li>
<li>);</li>
<li></li>
<li>SM_RESULT sm_copy(</li>
<li>sm_VariableArray *Array_p, SM_BYTE *in_p, SM_BYTE *out_p, SM_BOOL recursive, SM_BOOL sudo</li>
<li>);</li>
<li></li>
<li>SM_RESULT sm_createSymLink(</li>
<li>SM_BYTE *filePath_p, SM_BYTE *symLinkPath_p, SM_BOOL sudo</li>
<li>);</li>
<li></li>
<li>SM_BOOL sm_fileExists(</li>
<li>SM_BYTE *filename_p</li>
<li>);</li>
<li></li>
<li>void sm_initFileArray(</li>
<li>sm_FileArray *Array_p</li>
<li>);</li>
<li></li>
<li>SM_RESULT sm_appendFile(</li>
<li>sm_FileArray *Array_p, SM_BYTE *path_p</li>
<li>);</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
<li>-#endif diff --git a/external/selfmake/src/lib/Core/Options.c b/external/selfmake/src/lib/Core/Options.c deleted file mode 100644 index 7b25535..0000000 --- a/external/selfmake/src/lib/Core/Options.c +++ /dev/null @ -1,469 +0,0 @ -// LICENSE NOTICE ==================================================================================</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-// INCLUDE =========================================================================================</li>
<li>-#include "Options.h" -#include "Thread.h" -#include "File.h" -#include "Build.h"</li>
<li>-#include "../Parser/Functions.h" -#include "../Parser/Variables.h"</li>
<li>-#include "../Common/Functions.h" -#include "../Common/Macros/Macros.h" -#include SM_FLOW -#include SM_DEFAULT_CHECK</li>
<li>-#include &amp;ltstdio.h&gt; -#include &amp;ltstring.h&gt; -#include &amp;ltstdlib.h&gt; -#include &amp;ltctype.h&gt;</li>
<li>-// HELPER ==========================================================================================</li>
<li>-static SM_BYTE *sm_offsetBuildArgumentPrefix(</li>
<li>sm_Runtime *Runtime_p, SM_BYTE *name_p) -{ -SM_BEGIN()</li>
<li></li>
<li>sm_Variable *Prefix_p = sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "PREFIX");</li>
<li></li>
<li>if (Prefix_p) {</li>
<li>int offset = 0;</li>
<li>for (offset = 0; offset &amp;lt strlen(Prefix_p-&gt;values_pp[0]) &amp;&amp; offset &amp;lt strlen(name_p)</li>
<li>&amp;&amp; Prefix_p-&gt;values_pp[0][offset] == name_p[offset]; ++offset) {};</li>
<li>if (offset == strlen(Prefix_p-&gt;values_pp[0])) {</li>
<li>SM_END(name_p + offset)</li>
<li>}</li>
<li>}</li>
<li>-SM_END(name_p) -}</li>
<li>-// GET OPTION ======================================================================================</li>
<li>-static sm_Option *sm_getOptionFromBlock(</li>
<li>sm_Runtime *Runtime_p, sm_Block *Block_p, SM_BYTE *name_p, SM_BYTE **argv_pp, int args) -{ -SM_BEGIN()</li>
<li></li>
<li>for (int d = 0; d &amp;lt Block_p-&gt;definitions; ++d)</li>
<li>{</li>
<li>switch (Block_p-&gt;Definitions_p[d].type)</li>
<li>{</li>
<li>case SM_DEFINITION_IF :</li>
<li>if (sm_compareIf(Runtime_p, &amp;Block_p-&gt;Definitions_p[d].If, SM_TRUE)) {</li>
<li>sm_Option *Option_p = sm_getOptionFromBlock(Runtime_p, &amp;Block_p-&gt;Definitions_p[d].If.Block_p-&gt;Block, name_p, argv_pp, args);</li>
<li>if (Option_p) {SM_END(Option_p)}</li>
<li>}</li>
<li>break;</li>
<li></li>
<li>case SM_DEFINITION_OPTION :</li>
<li>if (!strcmp(Block_p-&gt;Definitions_p[d].Option.name_p, name_p)</li>
<li>&amp;&amp; Block_p-&gt;Definitions_p[d].Option.arguments == args) {</li>
<li>SM_BOOL sameArguments = SM_TRUE;</li>
<li>for (int i = 0; i &amp;lt args; ++i) {</li>
<li>SM_BYTE *argument_p = Block_p-&gt;Definitions_p[d].Option.arguments_pp[i];</li>
<li>SM_BYTE *offsetArgument_p = argument_p;</li>
<li>if (Block_p-&gt;Definitions_p[d].Option.name_p[0] == 'b' || Block_p-&gt;Definitions_p[d].Option.name_p[0] == 't') {</li>
<li>offsetArgument_p = sm_offsetBuildArgumentPrefix(Runtime_p, argument_p);</li>
<li>}</li>
<li>if (strcmp(argument_p, argv_pp[i]) &amp;&amp; strcmp(offsetArgument_p, argv_pp[i])) {</li>
<li>sameArguments = SM_FALSE;</li>
<li>break;</li>
<li>}</li>
<li>}</li>
<li>if (sameArguments) {</li>
<li>SM_END(&amp;Block_p-&gt;Definitions_p[d].Option)</li>
<li>}</li>
<li>}</li>
<li>break;</li>
<li>}</li>
<li>}</li>
<li>-SM_END(NULL) -}</li>
<li>-static sm_Option *sm_getOptionFromParser(</li>
<li>sm_Runtime *Runtime_p, sm_Parser *Parser_p, SM_BYTE *name_p, SM_BYTE **argv_pp, int args) -{ -SM_BEGIN()</li>
<li></li>
<li>sm_Block Block;</li>
<li>Block.definitions = Parser_p-&gt;definitions;</li>
<li>Block.Definitions_p = Parser_p-&gt;Definitions_p;</li>
<li>-SM_END(sm_getOptionFromBlock(Runtime_p, &amp;Block, name_p, argv_pp, args)) -}</li>
<li>-static sm_Option *sm_getShortOptions(</li>
<li>sm_Runtime *Runtime_p, SM_BYTE *name_p, SM_BYTE **argv_pp, int args, int *options_p) -{ -SM_BEGIN()</li>
<li></li>
<li>*options_p = 0;</li>
<li></li>
<li>sm_Option *Options_p = NULL;</li>
<li>SM_BYTE c = 0;</li>
<li></li>
<li>for (int i = 0; i &amp;lt strlen(name_p); ++i)</li>
<li>{</li>
<li>if (i + 1 &amp;lt strlen(name_p)) {</li>
<li>c = name_p[i+1];</li>
<li>name_p[i+1] = 0;</li>
<li>}</li>
<li></li>
<li>sm_Option *Option_p = NULL;</li>
<li>for (int j = 0; j &amp;lt Runtime_p-&gt;ParserArray.length; ++j) {</li>
<li>sm_Parser *Parser_p = &amp;Runtime_p-&gt;ParserArray.Parsers_p[j];</li>
<li>Option_p = sm_getOptionFromParser(Runtime_p, Parser_p, name_p+i, argv_pp, args);</li>
<li>if (Option_p) {break;}</li>
<li>}</li>
<li></li>
<li>if (Option_p) {</li>
<li>if (*options_p == 0) {</li>
<li>Options_p = Option_p;</li>
<li>}</li>
<li>else if (*options_p == 1) {</li>
<li>sm_Option *Tmp_p = malloc(sizeof(sm_Option)*2);</li>
<li>Tmp_p[0] = *Options_p;</li>
<li>Tmp_p[1] = *Option_p;</li>
<li>Options_p = Tmp_p;</li>
<li>}</li>
<li>else {</li>
<li>Options_p = realloc(Options_p, sizeof(sm_Option)*(*options_p+1));</li>
<li>Options_p[*options_p] = *Option_p;</li>
<li>}</li>
<li>*options_p += 1;</li>
<li>}</li>
<li></li>
<li>if (c != 0) {</li>
<li>name_p[i+1] = c;</li>
<li>c = 0;</li>
<li>}</li>
<li>}</li>
<li>-SM_END(Options_p) -}</li>
<li>-static sm_Option *sm_getOption(</li>
<li>sm_Runtime *Runtime_p, SM_BYTE *name_p, SM_BYTE **argv_pp, int args) -{ -SM_BEGIN()</li>
<li></li>
<li>sm_Option *Option_p = NULL;</li>
<li></li>
<li>for (int j = 0; j &amp;lt Runtime_p-&gt;ParserArray.length; ++j) {</li>
<li>sm_Parser *Parser_p = &amp;Runtime_p-&gt;ParserArray.Parsers_p[j];</li>
<li>Option_p = sm_getOptionFromParser(Runtime_p, Parser_p, name_p, argv_pp, args);</li>
<li>if (Option_p) {break;}</li>
<li>}</li>
<li>-SM_END(Option_p) -}</li>
<li>-// OPTION NAME =====================================================================================</li>
<li>-static SM_BOOL sm_optionNameExistsInBlock(</li>
<li>sm_Runtime *Runtime_p, sm_Block *Block_p, SM_BYTE *name_p) -{ -SM_BEGIN()</li>
<li></li>
<li>for (int d = 0; d &amp;lt Block_p-&gt;definitions; ++d) {</li>
<li>switch (Block_p-&gt;Definitions_p[d].type) {</li>
<li>case SM_DEFINITION_OPTION :</li>
<li>if (!strcmp(Block_p-&gt;Definitions_p[d].Option.name_p, name_p)) {</li>
<li>SM_END(SM_TRUE)</li>
<li>}</li>
<li>break;</li>
<li>case SM_DEFINITION_IF :</li>
<li>if (sm_compareIf(Runtime_p, &amp;Block_p-&gt;Definitions_p[d].If, SM_TRUE)) {</li>
<li>if (sm_optionNameExistsInBlock(Runtime_p, &amp;Block_p-&gt;Definitions_p[d].If.Block_p-&gt;Block, name_p)) {</li>
<li>SM_END(SM_TRUE)</li>
<li>}</li>
<li>}</li>
<li>break;</li>
<li>}</li>
<li></li>
<li>}</li>
<li>-SM_END(SM_FALSE) -}</li>
<li>-static SM_BOOL sm_optionNameExists(</li>
<li>sm_Runtime *Runtime_p, SM_BYTE *name_p) -{ -SM_BEGIN()</li>
<li></li>
<li>for (int i = 0; i &amp;lt Runtime_p-&gt;ParserArray.length; ++i) {</li>
<li>sm_Parser *Parser_p = &amp;Runtime_p-&gt;ParserArray.Parsers_p[i];</li>
<li>sm_Block Block;</li>
<li>Block.definitions = Parser_p-&gt;definitions;</li>
<li>Block.Definitions_p = Parser_p-&gt;Definitions_p;</li>
<li>if (sm_optionNameExistsInBlock(Runtime_p, &amp;Block, name_p)) {</li>
<li>SM_END(SM_TRUE)</li>
<li>}</li>
<li>}</li>
<li>-SM_END(SM_FALSE) -}</li>
<li>-// EXECUTE OPTION ==================================================================================</li>
<li>-static SM_RESULT sm_printOption(</li>
<li>sm_Option *Option_p) -{ -SM_BEGIN()</li>
<li></li>
<li>SM_BYTE args_p[1024]; // TODO malloc</li>
<li>memset(args_p, 0, 1024);</li>
<li>for (int i = 0; i &amp;lt Option_p-&gt;arguments; ++i) {</li>
<li>sprintf(args_p + strlen(args_p), "%s ", Option_p-&gt;arguments_pp[i]);</li>
<li>}</li>
<li></li>
<li>sm_operationf(Option_p-&gt;longOption ? "--%s %s'%s'" : "-%s %s'%s'", Option_p-&gt;name_p, args_p, Option_p-&gt;description_p);</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-static SM_RESULT sm_executeOption(</li>
<li>sm_Runtime *Runtime_p, sm_Option *Option_p) -{ -SM_BEGIN()</li>
<li></li>
<li>SM_CHECK(sm_printOption(Option_p))</li>
<li></li>
<li>if (!Option_p-&gt;Block_p) {</li>
<li>if (!strcmp(Option_p-&gt;name_p, "b")) {</li>
<li>SM_CHECK(sm_build(Runtime_p, Option_p-&gt;arguments_pp[0]))</li>
<li>}</li>
<li>else if (!strcmp(Option_p-&gt;name_p, "i")) {</li>
<li>}</li>
<li>else if (!strcmp(Option_p-&gt;name_p, "t")) {</li>
<li>SM_CHECK(sm_test(Runtime_p, Option_p-&gt;arguments_pp[0]))</li>
<li>}</li>
<li>else {SM_DIAGNOSTIC_END(SM_ERROR_BAD_STATE)}</li>
<li>}</li>
<li>else {</li>
<li>SM_CHECK(sm_executeBlock(Runtime_p, &amp;Option_p-&gt;Block_p-&gt;Block))</li>
<li>}</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-// BUILD OPTIONS ===================================================================================</li>
<li>-static SM_BOOL sm_buildOptionOverride(</li>
<li>sm_Runtime *Runtime_p, SM_BYTE *name_p) -{ -SM_BEGIN()</li>
<li></li>
<li>for (int j = 0; j &amp;lt Runtime_p-&gt;ParserArray.length; ++j)</li>
<li>{</li>
<li>sm_Parser *Parser_p = &amp;Runtime_p-&gt;ParserArray.Parsers_p[j];</li>
<li></li>
<li>for (int i = 0; i &amp;lt Parser_p-&gt;definitions; ++i)</li>
<li>{</li>
<li>sm_Definition *Definition_p = &amp;Parser_p-&gt;Definitions_p[i];</li>
<li></li>
<li>if (Definition_p-&gt;type == SM_DEFINITION_OPTION</li>
<li>&amp;&amp; !Definition_p-&gt;Option.longOption</li>
<li>&amp;&amp; !strcmp(Definition_p-&gt;Option.name_p, "b")</li>
<li>&amp;&amp; Definition_p-&gt;Option.arguments == 1</li>
<li>&amp;&amp; (!strcmp(Definition_p-&gt;Option.arguments_pp[0], name_p) || !strcmp(sm_offsetBuildArgumentPrefix(Runtime_p, Definition_p-&gt;Option.arguments_pp[0]), name_p))) {</li>
<li>SM_END(SM_TRUE)</li>
<li>}</li>
<li>}</li>
<li>}</li>
<li>-SM_END(SM_FALSE) -}</li>
<li>-SM_RESULT sm_addBuildOption(</li>
<li>sm_Runtime *Runtime_p, SM_BYTE *name_p) -{ -SM_BEGIN()</li>
<li></li>
<li>if (sm_buildOptionOverride(Runtime_p, name_p)) {SM_DIAGNOSTIC_END(SM_SUCCESS)}</li>
<li></li>
<li>static SM_BYTE *option_p = "b";</li>
<li></li>
<li>sm_Parser *Parser_p = &amp;Runtime_p-&gt;ParserArray.Parsers_p[0];</li>
<li></li>
<li>Parser_p-&gt;Definitions_p = realloc(Parser_p-&gt;Definitions_p, sizeof(sm_Definition) * (Parser_p-&gt;definitions + 1));</li>
<li>SM_CHECK_NULL(Parser_p-&gt;Definitions_p)</li>
<li></li>
<li>sm_Definition *Definition_p = &amp;Parser_p-&gt;Definitions_p[Parser_p-&gt;definitions++];</li>
<li></li>
<li>SM_BYTE *description_p = malloc(strlen(name_p) + 7);</li>
<li>SM_CHECK_NULL(description_p)</li>
<li>sprintf(description_p, "build %s", name_p);</li>
<li></li>
<li>SM_BYTE *argument_p = malloc(strlen(name_p) + 1);</li>
<li>SM_CHECK_NULL(argument_p)</li>
<li>strcpy(argument_p, name_p);</li>
<li></li>
<li>SM_BYTE **arguments_pp = malloc(sizeof(SM_BYTE*));</li>
<li>SM_CHECK_NULL(arguments_pp)</li>
<li>arguments_pp[0] = argument_p;</li>
<li></li>
<li>Definition_p-&gt;type = SM_DEFINITION_OPTION;</li>
<li>Definition_p-&gt;Option.arguments = 1;</li>
<li>Definition_p-&gt;Option.arguments_pp = arguments_pp;</li>
<li>Definition_p-&gt;Option.longOption = SM_FALSE;</li>
<li>Definition_p-&gt;Option.name_p = option_p;</li>
<li>Definition_p-&gt;Option.description_p = description_p;</li>
<li>Definition_p-&gt;Option.Block_p = NULL;</li>
<li></li>
<li>sm_messagef("Generate Option '-b %s'", name_p);</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-SM_RESULT sm_addTestOption(</li>
<li>sm_Runtime *Runtime_p, SM_BYTE *name_p) -{ -SM_BEGIN()</li>
<li></li>
<li>static SM_BYTE *option_p = "t";</li>
<li></li>
<li>sm_Parser *Parser_p = &amp;Runtime_p-&gt;ParserArray.Parsers_p[0];</li>
<li></li>
<li>Parser_p-&gt;Definitions_p = realloc(Parser_p-&gt;Definitions_p, sizeof(sm_Definition) * (Parser_p-&gt;definitions + 1));</li>
<li>SM_CHECK_NULL(Parser_p-&gt;Definitions_p)</li>
<li></li>
<li>sm_Definition *Definition_p = &amp;Parser_p-&gt;Definitions_p[Parser_p-&gt;definitions++];</li>
<li></li>
<li>SM_BYTE *description_p = malloc(strlen(name_p) + 7);</li>
<li>SM_CHECK_NULL(description_p)</li>
<li>sprintf(description_p, "test %s", name_p);</li>
<li></li>
<li>SM_BYTE *argument_p = malloc(strlen(name_p) + 1);</li>
<li>SM_CHECK_NULL(argument_p)</li>
<li>strcpy(argument_p, name_p);</li>
<li></li>
<li>SM_BYTE **arguments_pp = malloc(sizeof(SM_BYTE*));</li>
<li>SM_CHECK_NULL(arguments_pp)</li>
<li>arguments_pp[0] = argument_p;</li>
<li></li>
<li>Definition_p-&gt;type = SM_DEFINITION_OPTION;</li>
<li>Definition_p-&gt;Option.arguments = 1;</li>
<li>Definition_p-&gt;Option.arguments_pp = arguments_pp;</li>
<li>Definition_p-&gt;Option.longOption = SM_FALSE;</li>
<li>Definition_p-&gt;Option.name_p = option_p;</li>
<li>Definition_p-&gt;Option.description_p = description_p;</li>
<li>Definition_p-&gt;Option.Block_p = NULL;</li>
<li></li>
<li>sm_messagef("Generate Option '-t %s'", name_p);</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-// PARSE ===========================================================================================</li>
<li>-static SM_RESULT sm_parseShortOption(</li>
<li>sm_Runtime *Runtime_p, int argc, SM_BYTE **argv_pp, int *advance_p) -{ -SM_BEGIN()</li>
<li></li>
<li>SM_BOOL match = SM_FALSE;</li>
<li>int options = 0;</li>
<li>sm_Option *Options_p = NULL;</li>
<li></li>
<li>*advance_p = 1;</li>
<li></li>
<li>for (int i = 1; i &amp;lt argc; ++i)</li>
<li>{</li>
<li>if (argv_pp[i][0] == '-') {</li>
<li>break;</li>
<li>}</li>
<li></li>
<li>Options_p = sm_getShortOptions(Runtime_p, &amp;argv_pp[0][1], &amp;argv_pp[i], 1, &amp;options);</li>
<li>if (Options_p) {</li>
<li>for (int j = 0; j &amp;lt options; ++j) {</li>
<li>SM_CHECK(sm_executeOption(Runtime_p, Options_p+j))</li>
<li>}</li>
<li>if (options &gt; 1) {free(Options_p);}</li>
<li>Options_p = NULL;</li>
<li>match = SM_TRUE;</li>
<li>}</li>
<li></li>
<li>*advance_p += 1;</li>
<li>}</li>
<li></li>
<li>if (Options_p) {</li>
<li>for (int i = 0; i &amp;lt options; ++i) {</li>
<li>SM_CHECK(sm_executeOption(Runtime_p, Options_p+i))</li>
<li>}</li>
<li>if (options &gt; 1) {free(Options_p);}</li>
<li>}</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-static SM_RESULT sm_parseLongOption(</li>
<li>sm_Runtime *Runtime_p, int argc, SM_BYTE **argv_pp, int *advance_p) -{ -SM_BEGIN()</li>
<li></li>
<li>SM_BOOL match = SM_FALSE;</li>
<li>sm_Option *Option_p = NULL;</li>
<li></li>
<li>for (int i = 0; i &amp;lt argc; ++i)</li>
<li>{</li>
<li>if (i &gt; 0 &amp;&amp; argv_pp[i][0] == '-') {</li>
<li>break;</li>
<li>}</li>
<li></li>
<li>sm_Option *NewOption_p =</li>
<li>sm_getOption(Runtime_p, &amp;argv_pp[0][2], i == 0 ? NULL : &amp;argv_pp[1], *advance_p);</li>
<li></li>
<li>if (NewOption_p) {</li>
<li>Option_p = NewOption_p;</li>
<li>}</li>
<li>else {</li>
<li>sm_noticef("Invalid option \"%s\"", argv_pp[i]);</li>
<li>SM_DIAGNOSTIC_END(SM_ERROR_INVALID_OPTION)</li>
<li>}</li>
<li></li>
<li>*advance_p += 1;</li>
<li>}</li>
<li></li>
<li>if (Option_p) {</li>
<li>SM_CHECK(sm_executeOption(Runtime_p, Option_p))</li>
<li>}</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-SM_RESULT sm_parseOption(</li>
<li>sm_Runtime *Runtime_p, int argc, SM_BYTE **argv_pp, int *advance_p) -{ -SM_BEGIN()</li>
<li></li>
<li>int advance = 0;</li>
<li></li>
<li>for (int i = 0; i &amp;lt argc; i += advance)</li>
<li>{</li>
<li>advance = 0;</li>
<li></li>
<li>if (argv_pp[i][0] == '-' &amp;&amp; argv_pp[i][1] != '-') {</li>
<li>SM_CHECK(sm_parseShortOption(Runtime_p, argc-i, &amp;argv_pp[i], &amp;advance))</li>
<li>}</li>
<li>else if (argv_pp[i][0] == '-' &amp;&amp; argv_pp[i][1] == '-') {</li>
<li>SM_CHECK(sm_parseLongOption(Runtime_p, argc-i, &amp;argv_pp[i], &amp;advance))</li>
<li>}</li>
<li></li>
<li>*advance_p += advance;</li>
<li>}</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>diff --git a/external/selfmake/src/lib/Core/Options.h b/external/selfmake/src/lib/Core/Options.h deleted file mode 100644 index 170aa88..0000000 --- a/external/selfmake/src/lib/Core/Options.h +++ /dev/null @ -1,40 +0,0 @ -#ifndef SM_OPTIONS_H -#define SM_OPTIONS_H</li>
<li>-#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-#include "Source.h"</li>
<li>-#include "../Common/Result.h" -#include "../Common/Types.h"</li>
<li>-#include "../Parser/Parser.h" -#include "../Parser/Variables.h"</li>
<li>-#endif</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>SM_RESULT sm_addBuildOption(</li>
<li>sm_Runtime *Runtime_p, SM_BYTE *name_p</li>
<li>);</li>
<li></li>
<li>SM_RESULT sm_addTestOption(</li>
<li>sm_Runtime *Runtime_p, SM_BYTE *name_p</li>
<li>);</li>
<li></li>
<li>SM_RESULT sm_parseOption(</li>
<li>sm_Runtime *Runtime_p, int argc, SM_BYTE **argv_pp, int *advance_p</li>
<li>);</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>void sm_initSourceArray(</li>
<li>sm_SourceArray *Array_p</li>
<li>);</li>
<li></li>
<li>SM_RESULT sm_addSource(</li>
<li>sm_SourceContextArray *ContextArray_p, sm_SourceArray *SourceArray_p, sm_Function *Function_p,</li>
<li>SM_SOURCE_CONTEXT type</li>
<li>);</li>
<li></li>
<li>void sm_initSourceContextArray(</li>
<li>sm_SourceContextArray *Array_p</li>
<li>);</li>
<li></li>
<li>void sm_getIndentAfterSourceContext(</li>
<li>SM_BYTE *name_p, SM_BYTE *buffer_p, int size, sm_SourceContextArray *Array_p</li>
<li>);</li>
<li></li>
<li>SM_RESULT sm_addSourceContext(</li>
<li>sm_Runtime *Runtime_p, sm_Function *Function_p, SM_SOURCE_CONTEXT type, int offset</li>
<li>);</li>
<li></li>
<li>SM_RESULT sm_addCompileArguments(</li>
<li>sm_SourceContextArray *ContextArray_p, sm_Function *Function_p, SM_SOURCE_CONTEXT type</li>
<li>);</li>
<li></li>
<li>SM_RESULT sm_addLinkArguments(</li>
<li>sm_SourceContextArray *Array_p, sm_Function *Function_p, SM_SOURCE_CONTEXT type</li>
<li>);</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>void sm_initThreadPool(</li>
<li>);</li>
<li></li>
<li>SM_RESULT sm_runThread(</li>
<li>sm_Runtime *Runtime_p, SM_BYTE **args_pp, int args</li>
<li>);</li>
<li></li>
<li>sm_Thread *_sm_getThread(</li>
<li>);</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
<li>-#endif diff --git a/external/selfmake/src/lib/Core/Utils.h b/external/selfmake/src/lib/Core/Utils.h deleted file mode 100644 index 69d34b2..0000000 --- a/external/selfmake/src/lib/Core/Utils.h +++ /dev/null @ -1,40 +0,0 @ -#ifndef SM_UTILS_H -#define SM_UTILS_H</li>
<li>-#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-#include "../Common/Result.h" -#include "../Common/Types.h"</li>
<li>-#include &amp;ltstddef.h&gt;</li>
<li>-#endif</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>const SM_BYTE *sm_getHomeDir(</li>
<li>);</li>
<li></li>
<li>SM_RESULT sm_createDir(</li>
<li>SM_BYTE *path_p</li>
<li>);</li>
<li></li>
<li>SM_RESULT sm_removeDir(</li>
<li>SM_BYTE *path_p</li>
<li>);</li>
<li></li>
<li>SM_BOOL sm_canRunCommand(</li>
<li>const SM_BYTE *cmd</li>
<li>);</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
<li>-#endif diff --git a/external/selfmake/src/lib/Parser/Functions.c b/external/selfmake/src/lib/Parser/Functions.c deleted file mode 100644 index 5bc130f..0000000 --- a/external/selfmake/src/lib/Parser/Functions.c +++ /dev/null @ -1,275 +0,0 @ -// LICENSE NOTICE ==================================================================================</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-// INCLUDE =========================================================================================</li>
<li>-#include "Functions.h" -#include "Variables.h"</li>
<li>-#include "../Core/Build.h" -#include "../Core/Utils.h" -#include "../UI/Message.h" -#include "../Common/Macros/Macros.h" -#include SM_FLOW -#include SM_DEFAULT_CHECK</li>
<li>-#include &amp;ltstdio.h&gt; -#include &amp;ltstdlib.h&gt; -#include &amp;ltstring.h&gt; -#include &amp;ltunistd.h&gt; -#include &amp;ltctype.h&gt;</li>
<li>-#include &amp;ltsys/types.h&gt; -#include &amp;ltsys/stat.h&gt;</li>
<li>-// HELPER ==========================================================================================</li>
<li>-static SM_BOOL sm_caseInsensitiveMatch(</li>
<li>SM_BYTE *str1_p, SM_BYTE *str2_p) -{ -SM_BEGIN()</li>
<li></li>
<li>if (strlen(str1_p) != strlen(str2_p)) {SM_END(SM_FALSE)}</li>
<li></li>
<li>for (int i = 0; i &amp;lt strlen(str1_p); ++i) {</li>
<li>int d = tolower((unsigned char)str1_p[i]) - tolower((unsigned char)str2_p[i]);</li>
<li>if (d != 0) {</li>
<li>SM_END(SM_FALSE)</li>
<li>}</li>
<li>}</li>
<li>-SM_END(SM_TRUE) -}</li>
<li>-// EXECUTE =========================================================================================</li>
<li>-static SM_RESULT sm_executeCopyFunction(</li>
<li>sm_Runtime *Runtime_p, sm_Function *Function_p) -{ -SM_BEGIN()</li>
<li></li>
<li>if (Function_p-&gt;arguments &amp;lt= 0 || Function_p-&gt;arguments &gt; 4) {SM_DIAGNOSTIC_END(SM_ERROR_BAD_STATE)}</li>
<li></li>
<li>switch(Function_p-&gt;arguments)</li>
<li>{</li>
<li>case 2 :</li>
<li>sm_copy(&amp;Runtime_p-&gt;VariableArray, Function_p-&gt;arguments_pp[0], Function_p-&gt;arguments_pp[1], SM_FALSE, SM_FALSE);</li>
<li>break;</li>
<li>case 3 :</li>
<li>sm_copy(&amp;Runtime_p-&gt;VariableArray, Function_p-&gt;arguments_pp[0], Function_p-&gt;arguments_pp[1], !strcmp(Function_p-&gt;arguments_pp[2], "true") ? SM_TRUE : SM_FALSE, SM_FALSE);</li>
<li>break;</li>
<li>case 4 :</li>
<li>sm_copy(&amp;Runtime_p-&gt;VariableArray, Function_p-&gt;arguments_pp[0], Function_p-&gt;arguments_pp[1], !strcmp(Function_p-&gt;arguments_pp[2], "true") ? SM_TRUE : SM_FALSE, !strcmp(Function_p-&gt;arguments_pp[3], "true") ? SM_TRUE : SM_FALSE);</li>
<li>break;</li>
<li>}</li>
<li>-SM_END(SM_SUCCESS) -}</li>
<li>-static SM_RESULT sm_executeChdirFunction(</li>
<li>sm_Runtime *Runtime_p, sm_Function *Function_p) -{ -SM_BEGIN()</li>
<li></li>
<li>if (Function_p-&gt;arguments == 0) {</li>
<li>sm_updateVariable(&amp;Runtime_p-&gt;VariableArray, "WRK_DIR", sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "PROJ_DIR")-&gt;values_pp, 1);</li>
<li>}</li>
<li>else {</li>
<li>sm_updateVariable(&amp;Runtime_p-&gt;VariableArray, "WRK_DIR", Function_p-&gt;arguments_pp, 1);</li>
<li>}</li>
<li></li>
<li>sm_messagef("chdir %s", sm_getVariable(&amp;Runtime_p-&gt;VariableArray, "WRK_DIR")-&gt;values_pp[0]);</li>
<li>-SM_END(SM_SUCCESS) -}</li>
<li>-static SM_RESULT sm_executeMkdirFunction(</li>
<li>sm_Function *Function_p) -{ -SM_BEGIN()</li>
<li></li>
<li>if (Function_p-&gt;arguments != 1) {SM_DIAGNOSTIC_END(SM_SUCCESS)}</li>
<li></li>
<li>struct stat st = {0};</li>
<li>if (stat(Function_p-&gt;arguments_pp[0], &amp;st) == -1) {</li>
<li>int err = mkdir(Function_p-&gt;arguments_pp[0], 0755); // 0755 -&gt; drwxr-xr-x</li>
<li>if (err != 0) {</li>
<li>SM_DIAGNOSTIC_END(SM_ERROR_CANT_CREATE_DIRECTORY)</li>
<li>}</li>
<li>}</li>
<li></li>
<li>sm_messagef("mkdir %s", Function_p-&gt;arguments_pp[0]);</li>
<li>-SM_END(SM_SUCCESS) -}</li>
<li>-static SM_RESULT sm_executeSystemFunction(</li>
<li>sm_Function *Function_p) -{ -SM_BEGIN()</li>
<li></li>
<li>if (Function_p-&gt;arguments != 1) {SM_DIAGNOSTIC_END(SM_ERROR_BAD_STATE)}</li>
<li>sm_messagef("system %s", Function_p-&gt;arguments_pp[0]);</li>
<li>system(Function_p-&gt;arguments_pp[0]);</li>
<li>-SM_END(SM_SUCCESS) -}</li>
<li>-SM_RESULT sm_executeFunction(</li>
<li>sm_Runtime *Runtime_p, sm_Function *Function_p) -{ -SM_BEGIN()</li>
<li></li>
<li>SM_BYTE **arguments_pp = malloc(sizeof(SM_BYTE*) * Function_p-&gt;arguments);</li>
<li>memcpy(arguments_pp, Function_p-&gt;arguments_pp, sizeof(SM_BYTE*) * Function_p-&gt;arguments);</li>
<li></li>
<li>for (int i = 0; i &amp;lt Function_p-&gt;arguments; ++i) {</li>
<li>Function_p-&gt;arguments_pp[i] = sm_substituteVariables(&amp;Runtime_p-&gt;VariableArray, arguments_pp[i]);</li>
<li>SM_CHECK_NULL(Function_p-&gt;arguments_pp[i])</li>
<li>}</li>
<li>SM_RESULT result = SM_SUCCESS;</li>
<li></li>
<li>if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "lib")) {</li>
<li>if (!strcmp(Function_p-&gt;arguments_pp[0], "SHARED")) {</li>
<li>result = sm_addSourceContext(Runtime_p, Function_p, SM_SOURCE_CONTEXT_SHARED_LIBRARY, 1);</li>
<li>}</li>
<li>else if (!strcmp(Function_p-&gt;arguments_pp[0], "STATIC")) {</li>
<li>result = sm_addSourceContext(Runtime_p, Function_p, SM_SOURCE_CONTEXT_STATIC_LIBRARY, 1);</li>
<li>}</li>
<li>else {</li>
<li>result = sm_addSourceContext(Runtime_p, Function_p, SM_SOURCE_CONTEXT_SHARED_LIBRARY, 0);</li>
<li>}</li>
<li>if (!result &amp;&amp; Runtime_p-&gt;sourceContextCallback_f) {</li>
<li>result = Runtime_p-&gt;sourceContextCallback_f(</li>
<li>Runtime_p, &amp;Runtime_p-&gt;SourceContextArray.SourceContexts_p[Runtime_p-&gt;SourceContextArray.length - 1]</li>
<li>);</li>
<li>}</li>
<li>}</li>
<li>else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "bin")) {</li>
<li>result = sm_addSourceContext(Runtime_p, Function_p, SM_SOURCE_CONTEXT_BINARY, 0);</li>
<li>if (!result &amp;&amp; Runtime_p-&gt;sourceContextCallback_f) {</li>
<li>result = Runtime_p-&gt;sourceContextCallback_f(</li>
<li>Runtime_p, &amp;Runtime_p-&gt;SourceContextArray.SourceContexts_p[Runtime_p-&gt;SourceContextArray.length - 1]</li>
<li>);</li>
<li>}</li>
<li>}</li>
<li>else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "compile")) {</li>
<li>result = sm_addCompileArguments(&amp;Runtime_p-&gt;SourceContextArray, Function_p, SM_SOURCE_CONTEXT_UNDEFINED);</li>
<li>}</li>
<li>else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "compile_lib")) {</li>
<li>result = sm_addCompileArguments(&amp;Runtime_p-&gt;SourceContextArray, Function_p, SM_SOURCE_CONTEXT_SHARED_LIBRARY);</li>
<li>}</li>
<li>else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "compile_bin")) {</li>
<li>result = sm_addCompileArguments(&amp;Runtime_p-&gt;SourceContextArray, Function_p, SM_SOURCE_CONTEXT_BINARY);</li>
<li>}</li>
<li>else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "link")) {</li>
<li>result = sm_addLinkArguments(&amp;Runtime_p-&gt;SourceContextArray, Function_p, SM_SOURCE_CONTEXT_UNDEFINED);</li>
<li>}</li>
<li>else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "link_lib")) {</li>
<li>result = sm_addLinkArguments(&amp;Runtime_p-&gt;SourceContextArray, Function_p, SM_SOURCE_CONTEXT_SHARED_LIBRARY);</li>
<li>}</li>
<li>else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "link_bin")) {</li>
<li>result = sm_addLinkArguments(&amp;Runtime_p-&gt;SourceContextArray, Function_p, SM_SOURCE_CONTEXT_BINARY);</li>
<li>}</li>
<li>else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "source")) {</li>
<li>result = sm_addSource(&amp;Runtime_p-&gt;SourceContextArray, &amp;Runtime_p-&gt;SourceArray, Function_p, SM_SOURCE_CONTEXT_UNDEFINED);</li>
<li>}</li>
<li>else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "source_lib")) {</li>
<li>result = sm_addSource(&amp;Runtime_p-&gt;SourceContextArray, &amp;Runtime_p-&gt;SourceArray, Function_p, SM_SOURCE_CONTEXT_SHARED_LIBRARY);</li>
<li>}</li>
<li>else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "source_bin")) {</li>
<li>result = sm_addSource(&amp;Runtime_p-&gt;SourceContextArray, &amp;Runtime_p-&gt;SourceArray, Function_p, SM_SOURCE_CONTEXT_BINARY);</li>
<li>}</li>
<li>else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "test")) {</li>
<li>result = sm_addTest(&amp;Runtime_p-&gt;SourceContextArray, &amp;Runtime_p-&gt;TestArray, Function_p);</li>
<li>}</li>
<li>else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "copy")) {</li>
<li>result = sm_executeCopyFunction(Runtime_p, Function_p);</li>
<li>}</li>
<li>else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "build")) {</li>
<li>result = sm_build(Runtime_p, Function_p-&gt;arguments_pp[0]);</li>
<li>}</li>
<li>else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "chdir")) {</li>
<li>result = sm_executeChdirFunction(Runtime_p, Function_p);</li>
<li>}</li>
<li>else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "mkdir")) {</li>
<li>result = sm_executeMkdirFunction(Function_p);</li>
<li>}</li>
<li>else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "system")) {</li>
<li>result = sm_executeSystemFunction(Function_p);</li>
<li>}</li>
<li>else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "system")) {</li>
<li>result = sm_executeSystemFunction(Function_p);</li>
<li>}</li>
<li>else if (sm_caseInsensitiveMatch(Function_p-&gt;name_p, "set")) {</li>
<li>result = sm_updateVariable(</li>
<li>&amp;Runtime_p-&gt;VariableArray, Function_p-&gt;arguments_pp[0], Function_p-&gt;arguments_pp + 1,</li>
<li>Function_p-&gt;arguments - 1</li>
<li>);</li>
<li>}</li>
<li></li>
<li>if (!result &amp;&amp; Runtime_p-&gt;functionCallback_f) {</li>
<li>result = Runtime_p-&gt;functionCallback_f(Runtime_p, Function_p);</li>
<li>}</li>
<li></li>
<li>for (int i = 0; i &amp;lt Function_p-&gt;arguments; ++i) {</li>
<li>free(Function_p-&gt;arguments_pp[i]);</li>
<li>}</li>
<li></li>
<li>memcpy(Function_p-&gt;arguments_pp, arguments_pp, sizeof(SM_BYTE*) * Function_p-&gt;arguments);</li>
<li>free(arguments_pp);</li>
<li>-SM_DIAGNOSTIC_END(result) -}</li>
<li>-SM_BOOL sm_compareIf(</li>
<li>sm_Runtime *Runtime_p, sm_If *If_p, SM_BOOL b) -{ -SM_BEGIN()</li>
<li></li>
<li>sm_Variable *Var_p = sm_getVariable(&amp;Runtime_p-&gt;VariableArray, If_p-&gt;string_p);</li>
<li>if (Var_p &amp;&amp; Var_p-&gt;valueCount &gt; 0) {</li>
<li>if (!strcmp(*Var_p-&gt;values_pp, "true") &amp;&amp; b == SM_TRUE) {SM_END(SM_TRUE)}</li>
<li>if (!strcmp(*Var_p-&gt;values_pp, "false") &amp;&amp; b == SM_FALSE) {SM_END(SM_TRUE)}</li>
<li>}</li>
<li>-SM_END(SM_FALSE) -}</li>
<li>-SM_RESULT sm_executeIf(</li>
<li>sm_Runtime *Runtime_p, sm_If *If_p) -{ -SM_BEGIN()</li>
<li></li>
<li>sm_Variable *Var_p = sm_getVariable(&amp;Runtime_p-&gt;VariableArray, If_p-&gt;string_p);</li>
<li>if (Var_p &amp;&amp; Var_p-&gt;valueCount &gt; 0 &amp;&amp; !strcmp(*Var_p-&gt;values_pp, "true")) {</li>
<li>SM_CHECK(sm_executeBlock(Runtime_p, &amp;If_p-&gt;Block_p-&gt;Block))</li>
<li>}</li>
<li>-SM_DIAGNOSTIC_END(SM_SUCCESS) -}</li>
<li>-// EXECUTE BLOCK ===================================================================================</li>
<li>-SM_RESULT sm_executeBlock(</li>
<li>sm_Runtime *Runtime_p, sm_Block *Block_p) -{ -SM_BEGIN()</li>
<li></li>
<li>for (int d = 0; d &amp;lt Block_p-&gt;definitions; ++d) {</li>
<li>switch (Block_p-&gt;Definitions_p[d].type) {</li>
<li>case SM_DEFINITION_FUNCTION :</li>
<li>SM_CHECK(sm_executeFunction(Runtime_p, &amp;Block_p-&gt;Definitions_p[d].Function))</li>
<li>case SM_DEFINITION_IF :</li>
<li>SM_CHECK(sm_executeIf(Runtime_p, &amp;Block_p-&gt;Definitions_p[d].If))</li>
<li>}</li>
<li>}</li>
<li>-SM_END(SM_SUCCESS) -}</li>
<li>diff --git a/external/selfmake/src/lib/Parser/Functions.h b/external/selfmake/src/lib/Parser/Functions.h deleted file mode 100644 index 8dc85f9..0000000 --- a/external/selfmake/src/lib/Parser/Functions.h +++ /dev/null @ -1,39 +0,0 @ -#ifndef SM_FUNCTIONS_H -#define SM_FUNCTIONS_H</li>
<li>-#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-#include "Parser.h"</li>
<li>-#include "../Core/Runtime.h"</li>
<li>-#include "../Common/Types.h" -#include "../Common/Result.h"</li>
<li>-#endif</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>SM_RESULT sm_executeFunction(</li>
<li>sm_Runtime *Runtime_p, sm_Function *Function_p</li>
<li>);</li>
<li></li>
<li>SM_RESULT sm_executeBlock(</li>
<li>sm_Runtime *Runtime_p, sm_Block *Block_p</li>
<li>);</li>
<li></li>
<li>SM_BOOL sm_compareIf(</li>
<li>sm_Runtime *Runtime_p, sm_If *If_p, SM_BOOL b</li>
<li>);</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>void sm_initParserArray(</li>
<li>sm_ParserArray *Array_p</li>
<li>);</li>
<li></li>
<li>SM_RESULT sm_appendParser(</li>
<li>sm_ParserArray *Array_p, sm_File *File_p, SM_BOOL showParseTree</li>
<li>);</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>sm_Tokenizer sm_initTokenizer(</li>
<li>);</li>
<li></li>
<li>SM_RESULT sm_tokenizeFile(</li>
<li>sm_Tokenizer *Tokenizer_p, sm_File *File_p</li>
<li>);</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>void sm_initVariableArray(</li>
<li>sm_VariableArray *Array_p</li>
<li>);</li>
<li></li>
<li>sm_Variable *sm_getVariable(</li>
<li>sm_VariableArray *Array_p, SM_BYTE *name_p</li>
<li>);</li>
<li></li>
<li>SM_RESULT sm_appendToVariable(</li>
<li>sm_VariableArray *Array_p, SM_BYTE *variable_p, SM_BYTE **values_pp, int valueCount</li>
<li>);</li>
<li></li>
<li>SM_RESULT sm_updateVariable(</li>
<li>sm_VariableArray *Array_p, SM_BYTE *variable_p, SM_BYTE **values_pp, int valueCount</li>
<li>);</li>
<li></li>
<li>SM_BYTE *sm_substituteVariables(</li>
<li>sm_VariableArray *Array_p, SM_BYTE *string_p</li>
<li>);</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
<li>-#endif diff --git a/external/selfmake/src/lib/Test/Library.h b/external/selfmake/src/lib/Test/Library.h deleted file mode 100644 index 808ed3f..0000000 --- a/external/selfmake/src/lib/Test/Library.h +++ /dev/null @ -1,41 +0,0 @ -#ifndef SM_LIBRARY_H -#define SM_LIBRARY_H</li>
<li>-#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-#include "../Common/Result.h" -#include "../Common/Types.h"</li>
<li>-#include &amp;ltstddef.h&gt;</li>
<li>-#endif</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>void *sm_openLibrary(</li>
<li>SM_BYTE *path_p</li>
<li>);</li>
<li></li>
<li>void sm_closeLibrary(</li>
<li>void *lib_p</li>
<li>);</li>
<li></li>
<li>SM_RESULT sm_getExeDir(</li>
<li>SM_BYTE *buffer_p, size_t size</li>
<li>);</li>
<li></li>
<li>void *sm_loadSymbol(</li>
<li>void *lib_p, const SM_BYTE *name_p</li>
<li>);</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>sm_Process sm_fork(</li>
<li>);</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>void sm_initTestArray(</li>
<li>sm_TestArray *Array_p</li>
<li>);</li>
<li></li>
<li>SM_RESULT sm_addTest(</li>
<li>sm_SourceContextArray *ContextArray_p, sm_TestArray *TestArray_p, sm_Function *Function_p</li>
<li>);</li>
<li></li>
<li>SM_RESULT sm_test(</li>
<li>sm_Runtime *Runtime_p, SM_BYTE *name_p</li>
<li>);</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>SM_RESULT sm_runGUI(</li>
<li>);</li>
<li></li>
<li>SM_RESULT sm_handleGUIExpose(</li>
<li>);</li>
<li></li>
<li>void sm_handleGUIExit(</li>
<li>);</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
<li>-#endif diff --git a/external/selfmake/src/lib/UI/Message.h b/external/selfmake/src/lib/UI/Message.h deleted file mode 100644 index 9fc4b52..0000000 --- a/external/selfmake/src/lib/UI/Message.h +++ /dev/null @ -1,43 +0,0 @ -#ifndef SM_MESSAGE_H -#define SM_MESSAGE_H</li>
<li>-#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>-/**</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>-#include "../Common/Result.h" -#include "../Common/Types.h"</li>
<li>-#endif</li>
<li>-/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>SM_RESULT sm_operationf(</li>
<li>SM_BYTE *format_p, ...</li>
<li>);</li>
<li></li>
<li>SM_RESULT sm_messagef(</li>
<li>SM_BYTE *format_p, ...</li>
<li>);</li>
<li></li>
<li>SM_RESULT sm_noticef(</li>
<li>SM_BYTE *format_p, ...</li>
<li>);</li>
<li></li>
<li>SM_RESULT sm_externalMessage(</li>
<li>SM_BYTE *prepend_p, SM_BYTE *message_p</li>
<li>);</li>
<li></li>
<li>SM_RESULT sm_exitMessage(</li>
<li>SM_RESULT result</li>
<li>);</li>
<li><p class="startli">-/**</p>
<p class="startli">*/</p>
</li>
</ul>
<p >-/** +/** </p>
</div><!-- contents -->
</div><!-- doc-content -->
  <!-- HTML footer for doxygen 1.8.15-->
  <!-- start footer part -->
  <div id="nav-path" class="navpath">
    <!--  -->
    <!-- <li class="footer">Generated by -->
    <!-- <a href="http://www.doxygen.org/index.html"> -->
    <!-- <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li> -->
    <div id="foot"> 
      <div style="color:#24bbc4;text-align:center;margin:auto;font-size:16px;">
        <b>
<!-- NH_MAKE_INSERT_STAGE_BEGIN -->
prototype.1
<!-- NH_MAKE_INSERT_STAGE_END -->
-
<!-- NH_MAKE_INSERT_API_VERSION_BEGIN -->
ver.0.2.3.0
<!-- NH_MAKE_INSERT_API_VERSION_END -->
-
<!-- NH_MAKE_INSERT_REVISION_BEGIN -->
rev.08400
<!-- NH_MAKE_INSERT_REVISION_END -->
          </b>
        </div>
      </div>
    </div>
  </body>
  <style>
    #foot {display: flex; padding-top:13px; padding-bottom:14px; background: #151515; border-top: 3px solid #24bbc4; justify-content: space-between;}
  </style>
</html>
