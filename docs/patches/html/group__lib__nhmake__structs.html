<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.9.2"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Netzhaut | Web Browser Engine | Patches</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="resize.js"></script>
    <script type="text/javascript" src="navtreedata.js"></script>
    <script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/searchdata.js"></script>
    <script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript">
    /* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
      $(document).ready(function() { init_search(); });
    /* @license-end */
    </script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link rel="icon" href="../../logo/favicon.png">
    <link href="../../theme/custom.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>  
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
       <div style="height: 56px;">
        <div style="left:10px;top:5px;position:absolute;">
          <b>Netzhaut</b>
          <br>
          <b>Web Browser Engine</b>
        </div>
        <div style="height:56px;right:10px;top:0px;position:absolute;background-color:#151515;"><a href="https://netzwerkz.org"><img alt="netzwerkz logo" style="height:56px;" src="../../logo/netzwerkz.png"/></a></div>
        <div id="projectlogo"><img alt="netzhaut logo" src="../../logo/netzhaut.png"/></div>
       </div>
      </div>
      <div id="titlearea">
        <div class="topnav">
          <a href="../../index.html">Home</a>
          <a href="../../guides/html/index.html">Guides</a>
          <a href="../../general/html/index.html">General</a>
          <a href="../../architecture/html/index.html">Architecture</a>
          <a href="../../design/html/index.html">Design</a>
          <a href="../../internals/html/index.html">Internals</a>
          <a href="../../api/html/index.html">API</a>
          <a href="../../changelogs/html/index.html">Changelogs</a>
          <a class="active" href="../../patches/html/index.html">Patches</a>
        </div>
       </div>
      </div>
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__lib__nhmake__structs.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Data Structures</div></div>
</div><!--header-->
<div class="contents">
<ul>
<li><p class="startli">* */ -/**</p>
<p class="startli">*/</p>
</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>typedef struct nh_make_Function {</li>
<li>NH_MAKE_DEFINITION type;</li>
<li>NH_BYTE *name_p;</li>
<li>unsigned int arguments;</li>
<li>NH_BYTE **arguments_pp;</li>
<li>NH_MAKE_TOKEN *argumentTypes_p;</li>
<li>} nh_make_Function;</li>
<li></li>
<li>typedef struct nh_make_Version {</li>
<li>long api, major, minor, patch;</li>
<li>long apiDate_p[3], majorDate_p[3], minorDate_p[3], patchDate_p[3];</li>
<li>} nh_make_Version;</li>
<li></li>
<li>typedef struct nh_make_SourceContext {</li>
<li>NH_MAKE_SOURCE_CONTEXT type;</li>
<li>NH_BYTE *path_p;</li>
<li>NH_BYTE *name_p;</li>
<li>NH_BYTE *compileArgs_p;</li>
<li>NH_BYTE *linkArgs_p;</li>
<li>NH_BYTE *outputPath_p;</li>
<li>nh_make_Version Version;</li>
<li>} nh_make_SourceContext;</li>
<li></li>
<li>typedef struct nh_make_SourceContextArray {</li>
<li>int length;</li>
<li>int maxNameLength;</li>
<li>nh_make_SourceContext *SourceContexts_p;</li>
<li>} nh_make_SourceContextArray;</li>
<li></li>
<li>typedef struct nh_make_ValueArray {</li>
<li>NH_BYTE **values_pp;</li>
<li>int length;</li>
<li>} nh_make_ValueArray;</li>
<li></li>
<li>typedef struct nh_make_TestArgument {</li>
<li>NH_BYTE *p;</li>
<li>} nh_make_TestArgument;</li>
<li></li>
<li>typedef struct nh_make_Author {</li>
<li>NH_BYTE *name_p;</li>
<li>NH_BYTE *contact_p;</li>
<li>NH_BYTE **messages_pp;</li>
<li>int messages;</li>
<li>} nh_make_Author;</li>
<li></li>
<li>typedef struct nh_make_Workload {</li>
<li>NH_BYTE **libs_pp;</li>
<li>int libs;</li>
<li>NH_BYTE **bins_pp;</li>
<li>int bins;</li>
<li>NH_BYTE *scope_p;</li>
<li>nh_make_Author *Authors_p;</li>
<li>int authors;</li>
<li>} nh_make_Workload;</li>
<li></li>
<li>typedef struct nh_make_Changes {</li>
<li>NH_BYTE *date_p;</li>
<li>NH_BYTE *id_p;</li>
<li>NH_BYTE *summary_p;</li>
<li>int workloads;</li>
<li>nh_make_Workload *Workloads_p;</li>
<li>} nh_make_Changes;</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li>+#endif diff --git a/src/lib/nhmake/Core/Changes.c b/src/lib/nhmake/Core/Changes.c new file mode 100644 index 0000000..89b0ef4 --- /dev/null +++ b/src/lib/nhmake/Core/Changes.c @ -0,0 +1,746 @ +// LICENSE NOTICE ==================================================================================</li>
<li>+/**</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>+// INCLUDE =========================================================================================</li>
<li>+#include "Changes.h" +#include "Configure.h"</li>
<li>+#include "../Parser/Tokenizer.h" +#include "../Core/File.h"</li>
<li>+#include "../Common/Macros/Macros.h" +#include NH_MAKE_FLOW +#include NH_MAKE_DEFAULT_CHECK</li>
<li>+#include &amp;ltstdio.h&gt; +#include &amp;ltstring.h&gt; +#include &amp;ltstdlib.h&gt; +#include &amp;ltctype.h&gt; +#include &amp;ltunistd.h&gt; +#include &amp;lttime.h&gt;</li>
<li></li>
<li>+// CREATE PARSE-TREE ===============================================================================</li>
<li>+typedef struct nh_make_ChangesParser {</li>
<li>nh_make_Token *Token_p;</li>
<li>nh_make_ChangesNode *Node_p; +} nh_make_ChangesParser;</li>
<li>+static NH_MAKE_RESULT nh_make_initChangesNode(</li>
<li>nh_make_ChangesNode *Node_p, NH_MAKE_CHANGES_NODE type, nh_make_ChangesNode *Parent_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>Node_p-&gt;type = type;</li>
<li>Node_p-&gt;text_p = NULL;</li>
<li>Node_p-&gt;length = 0;</li>
<li>Node_p-&gt;Children_pp = NULL;</li>
<li>Node_p-&gt;children = 0;</li>
<li>Node_p-&gt;Parent_p = Parent_p;</li>
<li>+NH_MAKE_END(NH_MAKE_SUCCESS) +}</li>
<li>+static nh_make_ChangesNode *nh_make_createChangesNode(</li>
<li>NH_MAKE_CHANGES_NODE type, nh_make_ChangesNode *Parent_p) +{ +NH_MAKE_BEGIN()</li>
<li>+#include NH_MAKE_CUSTOM_CHECK</li>
<li></li>
<li>nh_make_ChangesNode *Node_p = malloc(sizeof(nh_make_ChangesNode));</li>
<li>NH_MAKE_CHECK_NULL(NULL, Node_p)</li>
<li></li>
<li>nh_make_initChangesNode(Node_p, type, Parent_p);</li>
<li></li>
<li>if (!Parent_p) {NH_MAKE_END(Node_p)}</li>
<li></li>
<li>if (!Parent_p-&gt;Children_pp) {</li>
<li>Parent_p-&gt;Children_pp = malloc(sizeof(nh_make_ChangesNode*));</li>
<li>NH_MAKE_CHECK_NULL(NULL, Parent_p-&gt;Children_pp)</li>
<li>Parent_p-&gt;Children_pp[0] = Node_p;</li>
<li>Parent_p-&gt;children = 1;</li>
<li>}</li>
<li>else {</li>
<li>Parent_p-&gt;Children_pp =</li>
<li>realloc(Parent_p-&gt;Children_pp, sizeof(nh_make_ChangesNode*) * (Parent_p-&gt;children + 1));</li>
<li>NH_MAKE_CHECK_NULL(NULL, Parent_p-&gt;Children_pp)</li>
<li>Parent_p-&gt;Children_pp[Parent_p-&gt;children] = Node_p;</li>
<li>Parent_p-&gt;children++;</li>
<li>}</li>
<li>+#include NH_MAKE_DEFAULT_CHECK</li>
<li>+NH_MAKE_END(Node_p) +}</li>
<li>+static NH_MAKE_RESULT nh_make_parseChild(</li>
<li>nh_make_ChangesParser *Parser_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>if (!Parser_p-&gt;Token_p-&gt;string_p) {</li>
<li>NH_MAKE_END(NH_MAKE_ERROR_BAD_STATE)</li>
<li>}</li>
<li></li>
<li>NH_MAKE_CHANGES_NODE type = NH_MAKE_CHANGES_NODE_UNDEFINED;</li>
<li></li>
<li>if (!strcmp(Parser_p-&gt;Token_p-&gt;string_p, "summary")) {</li>
<li>type = NH_MAKE_CHANGES_NODE_SUMMARY;</li>
<li>}</li>
<li>else if (!strcmp(Parser_p-&gt;Token_p-&gt;string_p, "date")) {</li>
<li>type = NH_MAKE_CHANGES_NODE_DATE;</li>
<li>}</li>
<li>else if (!strcmp(Parser_p-&gt;Token_p-&gt;string_p, "id")) {</li>
<li>type = NH_MAKE_CHANGES_NODE_ID;</li>
<li>}</li>
<li>else if (!strcmp(Parser_p-&gt;Token_p-&gt;string_p, "bin")) {</li>
<li>type = NH_MAKE_CHANGES_NODE_WORKLOAD_BIN;</li>
<li>}</li>
<li>else if (!strcmp(Parser_p-&gt;Token_p-&gt;string_p, "lib")) {</li>
<li>type = NH_MAKE_CHANGES_NODE_WORKLOAD_LIB;</li>
<li>}</li>
<li>else if (!strcmp(Parser_p-&gt;Token_p-&gt;string_p, "scope")) {</li>
<li>type = NH_MAKE_CHANGES_NODE_WORKLOAD_SCOPE;</li>
<li>}</li>
<li>else if (!strcmp(Parser_p-&gt;Token_p-&gt;string_p, "contact")) {</li>
<li>type = NH_MAKE_CHANGES_NODE_AUTHOR_CONTACT;</li>
<li>}</li>
<li>else if (!strcmp(Parser_p-&gt;Token_p-&gt;string_p, "message")) {</li>
<li>type = NH_MAKE_CHANGES_NODE_AUTHOR_MESSAGE;</li>
<li>}</li>
<li>else if (!strcmp(Parser_p-&gt;Token_p-&gt;string_p, "name")) {</li>
<li>type = NH_MAKE_CHANGES_NODE_AUTHOR_NAME;</li>
<li>}</li>
<li></li>
<li>if (type == NH_MAKE_CHANGES_NODE_UNDEFINED) {</li>
<li>NH_MAKE_END(NH_MAKE_ERROR_BAD_STATE)</li>
<li>}</li>
<li></li>
<li>nh_make_ChangesNode *Node_p = nh_make_createChangesNode(type, Parser_p-&gt;Node_p);</li>
<li>NH_MAKE_CHECK_NULL(Node_p)</li>
<li></li>
<li>++(Parser_p-&gt;Token_p);</li>
<li>++(Parser_p-&gt;Token_p);</li>
<li></li>
<li>if (Parser_p-&gt;Token_p-&gt;type != NH_MAKE_TOKEN_STRING) {</li>
<li>NH_MAKE_END(NH_MAKE_ERROR_BAD_STATE)</li>
<li>}</li>
<li></li>
<li>Node_p-&gt;text_p = Parser_p-&gt;Token_p-&gt;string_p;</li>
<li></li>
<li>++(Parser_p-&gt;Token_p);</li>
<li></li>
<li>while (Parser_p-&gt;Token_p-&gt;type == NH_MAKE_TOKEN_COMMA) {</li>
<li>Node_p = nh_make_createChangesNode(type, Parser_p-&gt;Node_p);</li>
<li>NH_MAKE_CHECK_NULL(Node_p)</li>
<li>++(Parser_p-&gt;Token_p);</li>
<li>Node_p-&gt;text_p = Parser_p-&gt;Token_p-&gt;string_p;</li>
<li>++(Parser_p-&gt;Token_p);</li>
<li>}</li>
<li>+NH_MAKE_END(NH_MAKE_SUCCESS) +}</li>
<li>+static NH_MAKE_RESULT nh_make_parseToken(</li>
<li>nh_make_ChangesParser *Parser_p +);</li>
<li>+static NH_MAKE_RESULT nh_make_parseParent(</li>
<li>nh_make_ChangesParser *Parser_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>if (!Parser_p-&gt;Token_p-&gt;string_p) {</li>
<li>NH_MAKE_END(NH_MAKE_ERROR_BAD_STATE)</li>
<li>}</li>
<li></li>
<li>NH_MAKE_CHANGES_NODE type = NH_MAKE_CHANGES_NODE_UNDEFINED;</li>
<li></li>
<li>if (!strcmp(Parser_p-&gt;Token_p-&gt;string_p, "changes")) {</li>
<li>type = NH_MAKE_CHANGES_NODE_ROOT;</li>
<li>}</li>
<li>else if (!strcmp(Parser_p-&gt;Token_p-&gt;string_p, "workload")) {</li>
<li>type = NH_MAKE_CHANGES_NODE_WORKLOAD;</li>
<li>}</li>
<li>else if (!strcmp(Parser_p-&gt;Token_p-&gt;string_p, "author")) {</li>
<li>type = NH_MAKE_CHANGES_NODE_AUTHOR;</li>
<li>}</li>
<li></li>
<li>if (type == NH_MAKE_CHANGES_NODE_UNDEFINED) {</li>
<li>NH_MAKE_END(NH_MAKE_ERROR_BAD_STATE)</li>
<li>}</li>
<li></li>
<li>Parser_p-&gt;Node_p = nh_make_createChangesNode(type, Parser_p-&gt;Node_p);</li>
<li>NH_MAKE_CHECK_NULL(Parser_p-&gt;Node_p)</li>
<li></li>
<li>++(Parser_p-&gt;Token_p);</li>
<li>++(Parser_p-&gt;Token_p);</li>
<li></li>
<li>while (Parser_p-&gt;Token_p-&gt;type != NH_MAKE_TOKEN_CURLY_BRACKET_RIGHT) {</li>
<li>NH_MAKE_CHECK(nh_make_parseToken(Parser_p))</li>
<li>}</li>
<li></li>
<li>++(Parser_p-&gt;Token_p);</li>
<li></li>
<li>if (Parser_p-&gt;Node_p-&gt;Parent_p) {</li>
<li>Parser_p-&gt;Node_p = Parser_p-&gt;Node_p-&gt;Parent_p;</li>
<li>}</li>
<li>+NH_MAKE_END(NH_MAKE_SUCCESS) +}</li>
<li>+static NH_MAKE_RESULT nh_make_parseToken(</li>
<li>nh_make_ChangesParser *Parser_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>if (Parser_p-&gt;Token_p-&gt;type != NH_MAKE_TOKEN_IDENTIFIER) {</li>
<li>NH_MAKE_END(NH_MAKE_ERROR_BAD_STATE)</li>
<li>}</li>
<li></li>
<li>switch ((Parser_p-&gt;Token_p+1)-&gt;type) {</li>
<li>case NH_MAKE_TOKEN_CURLY_BRACKET_LEFT :</li>
<li>NH_MAKE_END(nh_make_parseParent(Parser_p))</li>
<li>case NH_MAKE_TOKEN_COLON :</li>
<li>NH_MAKE_END(nh_make_parseChild(Parser_p))</li>
<li>default :</li>
<li>NH_MAKE_END(NH_MAKE_ERROR_BAD_STATE)</li>
<li>}</li>
<li>+NH_MAKE_END(NH_MAKE_SUCCESS) +}</li>
<li>+nh_make_ChangesNode *nh_make_parseChangesFile(</li>
<li>NH_BYTE *path_p) +{ +NH_MAKE_BEGIN()</li>
<li>+#include NH_MAKE_CUSTOM_CHECK</li>
<li></li>
<li>nh_make_File File = nh_make_initFile();</li>
<li>NH_MAKE_CHECK(NULL, nh_make_setFileData(&amp;File, path_p))</li>
<li></li>
<li>nh_make_Tokenizer Tokenizer = nh_make_initTokenizer();</li>
<li>NH_MAKE_CHECK(NULL, nh_make_tokenizeFile(&amp;Tokenizer, &amp;File))</li>
<li></li>
<li>nh_make_ChangesParser Parser;</li>
<li>Parser.Token_p = Tokenizer.Tokens_p;</li>
<li>Parser.Node_p = malloc(sizeof(nh_make_ChangesNode));</li>
<li>NH_MAKE_CHECK_NULL(NULL, Parser.Node_p)</li>
<li></li>
<li>nh_make_initChangesNode(Parser.Node_p, NH_MAKE_CHANGES_NODE_UNDEFINED, NULL);</li>
<li></li>
<li>while (Parser.Token_p-&gt;type != NH_MAKE_TOKEN_EOF) {</li>
<li>NH_MAKE_CHECK(NULL, nh_make_parseToken(&amp;Parser))</li>
<li>}</li>
<li></li>
<li>nh_make_freeFileData(&amp;File);</li>
<li>+#include NH_MAKE_DEFAULT_CHECK</li>
<li>+NH_MAKE_END((nh_make_ChangesNode*)Parser.Node_p) +}</li>
<li>+// PARSE PARSE-TREE ================================================================================</li>
<li>+typedef struct nh_make_ChangesNodeArray {</li>
<li>nh_make_ChangesNode **Nodes_pp;</li>
<li>int nodes; +} nh_make_ChangesNodeArray;</li>
<li>+static nh_make_ChangesNodeArray nh_make_initChangesNodeArray() +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>nh_make_ChangesNodeArray Array;</li>
<li>Array.Nodes_pp = NULL;</li>
<li>Array.nodes = 0;</li>
<li>+NH_MAKE_END(Array) +}</li>
<li>+static NH_MAKE_RESULT nh_make_addToChangesNodeArray(</li>
<li>nh_make_ChangesNodeArray *Array_p, nh_make_ChangesNode *Node_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>if (!Array_p-&gt;Nodes_pp) {</li>
<li>Array_p-&gt;Nodes_pp = malloc(sizeof(nh_make_ChangesNode*));</li>
<li>NH_MAKE_CHECK_NULL(Array_p-&gt;Nodes_pp)</li>
<li>Array_p-&gt;Nodes_pp[0] = Node_p;</li>
<li>Array_p-&gt;nodes = 1;</li>
<li>}</li>
<li>else {</li>
<li>Array_p-&gt;Nodes_pp =</li>
<li>realloc(Array_p-&gt;Nodes_pp, sizeof(nh_make_ChangesNode*) * (Array_p-&gt;nodes + 1));</li>
<li>NH_MAKE_CHECK_NULL(Array_p-&gt;Nodes_pp)</li>
<li>Array_p-&gt;Nodes_pp[Array_p-&gt;nodes] = Node_p;</li>
<li>Array_p-&gt;nodes++;</li>
<li>}</li>
<li>+NH_MAKE_END(NH_MAKE_SUCCESS) +}</li>
<li>+static void nh_make_freeChangesNodeArray(</li>
<li>nh_make_ChangesNodeArray *Array_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>free(Array_p-&gt;Nodes_pp);</li>
<li>+NH_MAKE_SILENT_END() +}</li>
<li>+static NH_MAKE_RESULT nh_make_getChangesNode(</li>
<li>nh_make_ChangesNodeArray *Array_p, nh_make_ChangesNode *Node_p, NH_MAKE_CHANGES_NODE type) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>if (Node_p-&gt;type == type) {</li>
<li>NH_MAKE_CHECK(nh_make_addToChangesNodeArray(Array_p, Node_p))</li>
<li>}</li>
<li></li>
<li>for (int i = 0; i &amp;lt Node_p-&gt;children; ++i) {</li>
<li>nh_make_getChangesNode(Array_p, Node_p-&gt;Children_pp[i], type);</li>
<li>}</li>
<li>+NH_MAKE_END(NH_MAKE_SUCCESS) +}</li>
<li>+static NH_MAKE_RESULT nh_make_getChangesAuthor(</li>
<li>nh_make_Author *Author_p, nh_make_ChangesNode *Node_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>Author_p-&gt;name_p = NULL;</li>
<li>Author_p-&gt;contact_p = NULL;</li>
<li>Author_p-&gt;messages_pp = NULL;</li>
<li>Author_p-&gt;messages = 0;</li>
<li></li>
<li>int messages = 0;</li>
<li></li>
<li>for (int i = 0; i &amp;lt Node_p-&gt;children; ++i) {</li>
<li>nh_make_ChangesNode *Child_p = Node_p-&gt;Children_pp[i];</li>
<li>switch (Child_p-&gt;type) {</li>
<li>case NH_MAKE_CHANGES_NODE_AUTHOR_NAME :</li>
<li>Author_p-&gt;name_p = Child_p-&gt;text_p;</li>
<li>break;</li>
<li>case NH_MAKE_CHANGES_NODE_AUTHOR_CONTACT :</li>
<li>Author_p-&gt;contact_p = Child_p-&gt;text_p;</li>
<li>break;</li>
<li>case NH_MAKE_CHANGES_NODE_AUTHOR_MESSAGE :</li>
<li>++messages;</li>
<li>break;</li>
<li>}</li>
<li>}</li>
<li></li>
<li>Author_p-&gt;messages_pp = malloc(sizeof(NH_BYTE*)*messages);</li>
<li>NH_MAKE_CHECK_NULL(Author_p-&gt;messages_pp)</li>
<li></li>
<li>for (int i = 0, j = 0; i &amp;lt Node_p-&gt;children; ++i) {</li>
<li>if (Node_p-&gt;Children_pp[i]-&gt;type == NH_MAKE_CHANGES_NODE_AUTHOR_MESSAGE) {</li>
<li>Author_p-&gt;messages_pp[j++] = Node_p-&gt;Children_pp[i]-&gt;text_p;</li>
<li>}</li>
<li>}</li>
<li></li>
<li>Author_p-&gt;messages = messages;</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+static NH_MAKE_RESULT nh_make_getWorkload(</li>
<li>nh_make_Workload *Workload_p, nh_make_ChangesNode *Node_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>Workload_p-&gt;bins_pp = NULL;</li>
<li>Workload_p-&gt;bins = 0;</li>
<li>Workload_p-&gt;libs_pp = NULL;</li>
<li>Workload_p-&gt;libs = 0;</li>
<li>Workload_p-&gt;scope_p = NULL;</li>
<li>Workload_p-&gt;Authors_p = NULL;</li>
<li>Workload_p-&gt;authors = 0;</li>
<li></li>
<li>int authors = 0, bins = 0, libs = 0;</li>
<li></li>
<li>for (int i = 0; i &amp;lt Node_p-&gt;children; ++i) {</li>
<li>nh_make_ChangesNode *Child_p = Node_p-&gt;Children_pp[i];</li>
<li>switch (Child_p-&gt;type) {</li>
<li>case NH_MAKE_CHANGES_NODE_WORKLOAD_BIN :</li>
<li>++bins;</li>
<li>break;</li>
<li>case NH_MAKE_CHANGES_NODE_WORKLOAD_LIB :</li>
<li>++libs;</li>
<li>break;</li>
<li>case NH_MAKE_CHANGES_NODE_WORKLOAD_SCOPE :</li>
<li>Workload_p-&gt;scope_p = Child_p-&gt;text_p;</li>
<li>break;</li>
<li>case NH_MAKE_CHANGES_NODE_AUTHOR :</li>
<li>++authors;</li>
<li>break;</li>
<li>}</li>
<li>}</li>
<li></li>
<li>if (bins)</li>
<li>{</li>
<li>Workload_p-&gt;bins_pp = malloc(sizeof(NH_BYTE*)*bins);</li>
<li>NH_MAKE_CHECK_NULL(Workload_p-&gt;bins_pp)</li>
<li>for (int i = 0, j = 0; i &amp;lt Node_p-&gt;children; ++i) {</li>
<li>if (Node_p-&gt;Children_pp[i]-&gt;type == NH_MAKE_CHANGES_NODE_WORKLOAD_BIN) {</li>
<li>Workload_p-&gt;bins_pp[j++] = Node_p-&gt;Children_pp[i]-&gt;text_p;</li>
<li>}</li>
<li>}</li>
<li>Workload_p-&gt;bins = bins;</li>
<li>}</li>
<li></li>
<li>if (libs)</li>
<li>{</li>
<li>Workload_p-&gt;libs_pp = malloc(sizeof(NH_BYTE*)*libs);</li>
<li>NH_MAKE_CHECK_NULL(Workload_p-&gt;libs_pp)</li>
<li>for (int i = 0, j = 0; i &amp;lt Node_p-&gt;children; ++i) {</li>
<li>if (Node_p-&gt;Children_pp[i]-&gt;type == NH_MAKE_CHANGES_NODE_WORKLOAD_LIB) {</li>
<li>Workload_p-&gt;libs_pp[j++] = Node_p-&gt;Children_pp[i]-&gt;text_p;</li>
<li>}</li>
<li>}</li>
<li>Workload_p-&gt;libs = libs;</li>
<li>}</li>
<li></li>
<li>if (authors)</li>
<li>{</li>
<li>Workload_p-&gt;Authors_p = malloc(sizeof(nh_make_Author)*authors);</li>
<li>NH_MAKE_CHECK_NULL(Workload_p-&gt;Authors_p)</li>
<li>for (int i = 0, j = 0; i &amp;lt Node_p-&gt;children; ++i) {</li>
<li>if (Node_p-&gt;Children_pp[i]-&gt;type == NH_MAKE_CHANGES_NODE_AUTHOR) {</li>
<li>nh_make_getChangesAuthor(Workload_p-&gt;Authors_p+j, Node_p-&gt;Children_pp[i]);</li>
<li>j++;</li>
<li>}</li>
<li>}</li>
<li>Workload_p-&gt;authors = authors;</li>
<li>}</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+static void nh_make_initChanges(</li>
<li>nh_make_Changes *Changes_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>Changes_p-&gt;date_p = NULL;</li>
<li>Changes_p-&gt;id_p = NULL;</li>
<li>Changes_p-&gt;summary_p = NULL;</li>
<li>Changes_p-&gt;workloads = 0;</li>
<li>Changes_p-&gt;Workloads_p = NULL;</li>
<li>+NH_MAKE_SILENT_END() +}</li>
<li>+static NH_MAKE_RESULT nh_make_parseChangesNode(</li>
<li>nh_make_ChangesNode *Root_p, nh_make_Changes *Changes_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>nh_make_initChanges(Changes_p);</li>
<li></li>
<li>nh_make_ChangesNodeArray Array = nh_make_initChangesNodeArray();</li>
<li>NH_MAKE_CHECK(nh_make_getChangesNode(&amp;Array, Root_p, NH_MAKE_CHANGES_NODE_SUMMARY))</li>
<li></li>
<li>if (Array.nodes != 1) {NH_MAKE_END(NH_MAKE_ERROR_BAD_STATE)}</li>
<li></li>
<li>Changes_p-&gt;summary_p = Array.Nodes_pp[0]-&gt;text_p;</li>
<li></li>
<li>nh_make_freeChangesNodeArray(&amp;Array);</li>
<li></li>
<li>Array = nh_make_initChangesNodeArray();</li>
<li>NH_MAKE_CHECK(nh_make_getChangesNode(&amp;Array, Root_p, NH_MAKE_CHANGES_NODE_WORKLOAD))</li>
<li></li>
<li>if (Array.nodes == 0) {</li>
<li>NH_MAKE_END(NH_MAKE_ERROR_BAD_STATE)</li>
<li>}</li>
<li></li>
<li>Changes_p-&gt;Workloads_p = malloc(sizeof(nh_make_Workload)*Array.nodes);</li>
<li>NH_MAKE_CHECK_NULL(Changes_p-&gt;Workloads_p)</li>
<li></li>
<li>for (int i = 0; i &amp;lt Array.nodes; ++i) {</li>
<li>NH_MAKE_CHECK(nh_make_getWorkload(Changes_p-&gt;Workloads_p+i, Array.Nodes_pp[i]))</li>
<li>}</li>
<li></li>
<li>Changes_p-&gt;workloads = Array.nodes;</li>
<li></li>
<li>nh_make_freeChangesNodeArray(&amp;Array);</li>
<li>+NH_MAKE_END(NH_MAKE_SUCCESS) +}</li>
<li>+nh_make_Changes *nh_make_getChanges(</li>
<li>nh_make_ChangesNode *Root_p, int *changes_p) +{ +NH_MAKE_BEGIN()</li>
<li>+#include NH_MAKE_CUSTOM_CHECK</li>
<li></li>
<li>if (changes_p) {*changes_p = 0;}</li>
<li></li>
<li>nh_make_ChangesNodeArray Array = nh_make_initChangesNodeArray();</li>
<li>NH_MAKE_CHECK(NULL, nh_make_getChangesNode(&amp;Array, Root_p, NH_MAKE_CHANGES_NODE_ROOT))</li>
<li></li>
<li>if (Array.nodes &amp;lt= 0) {NH_MAKE_END(NULL)}</li>
<li></li>
<li>nh_make_Changes *Changes_p = malloc(sizeof(nh_make_Changes)*Array.nodes);</li>
<li>NH_MAKE_CHECK_NULL(NULL, Changes_p)</li>
<li></li>
<li>for (int i = 0; i &amp;lt Array.nodes; ++i) {</li>
<li>NH_MAKE_CHECK(NULL, nh_make_parseChangesNode(Array.Nodes_pp[i], Changes_p+i))</li>
<li>}</li>
<li>if (changes_p) {*changes_p = Array.nodes;}</li>
<li></li>
<li>nh_make_freeChangesNodeArray(&amp;Array);</li>
<li>+#include NH_MAKE_DEFAULT_CHECK</li>
<li>+NH_MAKE_END(Changes_p) +}</li>
<li>+// MESSAGE =========================================================================================</li>
<li>+static nh_make_SourceContext *nh_make_getSourceContextForChangesMessage(</li>
<li>nh_make_Runtime *Runtime_p, NH_BYTE *name_p, NH_BOOL bin) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>nh_make_SourceContextArray *Array_p = nh_make_getSourceContextArray(Runtime_p);</li>
<li></li>
<li>for (int i = 0; i &amp;lt Array_p-&gt;length; ++i) {</li>
<li>if ((bin &amp;&amp; Array_p-&gt;SourceContexts_p[i].type == NH_MAKE_SOURCE_CONTEXT_BINARY)</li>
<li>|| (!bin &amp;&amp; Array_p-&gt;SourceContexts_p[i].type != NH_MAKE_SOURCE_CONTEXT_BINARY)) {</li>
<li>if (!strcmp(Array_p-&gt;SourceContexts_p[i].name_p, name_p)) {</li>
<li>NH_MAKE_END(Array_p-&gt;SourceContexts_p+i);</li>
<li>}</li>
<li>}</li>
<li>}</li>
<li>+NH_MAKE_END(NULL) +}</li>
<li>+static NH_MAKE_RESULT nh_make_printChangesGit(</li>
<li>nh_make_Runtime *Runtime_p, nh_make_Changes *Changes_p) +{ +NH_MAKE_BEGIN()</li>
<li>+// NH_BYTE message_p[2048]; +// memset(message_p, 0, 2048); +// +// strcpy(message_p, "git commit -m \""); +// strcpy(message_p+strlen(message_p), Changes_p-&gt;summary_p); +// strcpy(message_p+strlen(message_p), "\""); +// +// for (int i = 0; i &amp;lt Changes_p-&gt;workloads; ++i) +// { +// nh_make_Workload *Workload_p = Changes_p-&gt;Workloads_p+i; +// strcpy(message_p+strlen(message_p), " -m \""); +// +// for (int j = 0; j &amp;lt Workload_p-&gt;libs; ++j) { +// if (j) { +// strcpy(message_p+strlen(message_p), ", "); +// } +// sprintf(message_p+strlen(message_p), "%s (lib) ", Workload_p-&gt;libs_pp[j]); +// nh_make_addScopeToMessage(Runtime_p, Workload_p-&gt;libs_pp[j], Workload_p-&gt;scope_p, NH_FALSE, message_p); +// } +// +// for (int j = 0; j &amp;lt Workload_p-&gt;bins; ++j) { +// if (j || Workload_p-&gt;libs) { +// strcpy(message_p+strlen(message_p), ", "); +// } +// sprintf(message_p+strlen(message_p), "%s (bin) ", Workload_p-&gt;bins_pp[j]); +// nh_make_addScopeToMessage(Runtime_p, Workload_p-&gt;bins_pp[j], Workload_p-&gt;scope_p, NH_TRUE, message_p); +// } +// +// strcpy(message_p+strlen(message_p), "\" -m \""); +// +// for (int j = 0; j &amp;lt Workload_p-&gt;authors; ++j) { +// if (j) { +// strcpy(message_p+strlen(message_p), " "); +// } +// NH_BYTE name_p[255]; +// memset(name_p, 0, 255); +// sprintf(name_p, "[%s] ", Workload_p-&gt;Authors_p[j].name_p); +// strcpy(message_p+strlen(message_p), name_p); +// for (int k = 0; k &amp;lt Workload_p-&gt;Authors_p[j].messages; ++k) { +// if (k) { +// strcpy(message_p+strlen(message_p), " "); +// } +// strcpy(message_p+strlen(message_p), Workload_p-&gt;Authors_p[j].messages_pp[k]); +// } +// } +// +// strcpy(message_p+strlen(message_p), "\""); +// } +// +// puts(message_p);</li>
<li>+NH_MAKE_END(NH_MAKE_SUCCESS) +}</li>
<li>+NH_MAKE_RESULT nh_make_printChangesDefault(</li>
<li>nh_make_Runtime *Runtime_p, nh_make_Changes *Changes_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>nh_make_messagef("%s", Changes_p-&gt;summary_p);</li>
<li></li>
<li>for (int i = 0; i &amp;lt Changes_p-&gt;workloads; ++i)</li>
<li>{</li>
<li>nh_make_Workload *Workload_p = Changes_p-&gt;Workloads_p+i;</li>
<li>nh_make_messagef("  [%s update]", Workload_p-&gt;scope_p);</li>
<li></li>
<li>for (int j = 0; j &amp;lt Workload_p-&gt;libs; ++j) {</li>
<li>nh_make_messagef("  lib: %s", Workload_p-&gt;libs_pp[j]);</li>
<li>}</li>
<li></li>
<li>for (int j = 0; j &amp;lt Workload_p-&gt;bins; ++j) {</li>
<li>nh_make_messagef("  bin: %s", Workload_p-&gt;bins_pp[j]);</li>
<li>}</li>
<li></li>
<li>for (int j = 0; j &amp;lt Workload_p-&gt;authors; ++j) {</li>
<li>nh_make_messagef("    author: %s", Workload_p-&gt;Authors_p[j].name_p);</li>
<li>for (int k = 0; k &amp;lt Workload_p-&gt;Authors_p[j].messages; ++k) {</li>
<li>nh_make_messagef("      message %d: %s", k, Workload_p-&gt;Authors_p[j].messages_pp[k]);</li>
<li>}</li>
<li>}</li>
<li>}</li>
<li>+NH_MAKE_END(NH_MAKE_SUCCESS) +}</li>
<li>+NH_MAKE_RESULT nh_make_printChanges(</li>
<li>nh_make_Runtime *Runtime_p, nh_make_Changes *Changes_p, NH_MAKE_PRINT_CHANGES type) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>switch (type)</li>
<li>{</li>
<li>case NH_MAKE_PRINT_CHANGES_GIT :</li>
<li>NH_MAKE_DIAGNOSTIC_END(nh_make_printChangesGit(Runtime_p, Changes_p))</li>
<li>default :</li>
<li>NH_MAKE_DIAGNOSTIC_END(nh_make_printChangesDefault(Runtime_p, Changes_p))</li>
<li>}</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_BAD_STATE) +}</li>
<li>+// NORMALIZE =======================================================================================</li>
<li>+static NH_MAKE_RESULT nh_make_normalizeAuthor(</li>
<li>nh_make_Author *Author_p, NH_BYTE *changes_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>sprintf(changes_p+strlen(changes_p), "author{name:\"%s\"contact:\"%s\"",</li>
<li>Author_p-&gt;name_p, Author_p-&gt;contact_p);</li>
<li></li>
<li>for (int i = 0; i &amp;lt Author_p-&gt;messages; ++i) {</li>
<li>if (i) {strcpy(changes_p+strlen(changes_p), ",");}</li>
<li>else {strcpy(changes_p+strlen(changes_p), "message:");}</li>
<li>sprintf(changes_p+strlen(changes_p), "\"%s\"", Author_p-&gt;messages_pp[i]);</li>
<li>}</li>
<li></li>
<li>strcpy(changes_p+strlen(changes_p), "}");</li>
<li>+NH_MAKE_END(NH_MAKE_SUCCESS) +}</li>
<li>+static NH_MAKE_RESULT nh_make_normalizeWorkload(</li>
<li>nh_make_Workload *Workload_p, NH_BYTE *changes_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>sprintf(changes_p+strlen(changes_p), "workload{scope:\"%s\"", Workload_p-&gt;scope_p);</li>
<li></li>
<li>for (int i = 0; i &amp;lt Workload_p-&gt;libs; ++i) {</li>
<li>if (i) {strcpy(changes_p+strlen(changes_p), ",");}</li>
<li>else {strcpy(changes_p+strlen(changes_p), "lib:");}</li>
<li>sprintf(changes_p+strlen(changes_p), "\"%s\"", Workload_p-&gt;libs_pp[i]);</li>
<li>}</li>
<li></li>
<li>for (int i = 0; i &amp;lt Workload_p-&gt;bins; ++i) {</li>
<li>if (i) {strcpy(changes_p+strlen(changes_p), ",");}</li>
<li>else {strcpy(changes_p+strlen(changes_p), "bin:");}</li>
<li>sprintf(changes_p+strlen(changes_p), "\"%s\"", Workload_p-&gt;bins_pp[i]);</li>
<li>}</li>
<li>for (int i = 0; i &amp;lt Workload_p-&gt;authors; ++i) {</li>
<li>NH_MAKE_CHECK(nh_make_normalizeAuthor(Workload_p-&gt;Authors_p+i, changes_p))</li>
<li>}</li>
<li></li>
<li>strcpy(changes_p+strlen(changes_p), "}");</li>
<li>+NH_MAKE_END(NH_MAKE_SUCCESS) +}</li>
<li>+NH_MAKE_RESULT nh_make_normalizeChanges(</li>
<li>nh_make_Changes *Changes_p, NH_BYTE *changes_p, int length) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>memset(changes_p, 0, length);</li>
<li></li>
<li>sprintf(changes_p, "changes{date:\"%s\"id:\"%s\"summary:\"%s\"",</li>
<li>Changes_p-&gt;date_p, Changes_p-&gt;id_p, Changes_p-&gt;summary_p);</li>
<li></li>
<li>for (int i = 0; i &amp;lt Changes_p-&gt;workloads; ++i) {</li>
<li>NH_MAKE_CHECK(nh_make_normalizeWorkload(Changes_p-&gt;Workloads_p+i, changes_p))</li>
<li>}</li>
<li></li>
<li>strcpy(changes_p+strlen(changes_p), "}");</li>
<li>+NH_MAKE_END(NH_MAKE_SUCCESS) +}</li>
<li>+// OTHER ===========================================================================================</li>
<li>+// TODO Fix memory leak. +NH_MAKE_RESULT nh_make_addDateAndIdToChanges(</li>
<li>nh_make_Changes *Changes_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>time_t t = time(NULL);</li>
<li>struct tm tm = *localtime(&amp;t);</li>
<li>NH_BYTE time_p[255];</li>
<li>memset(time_p, 0, 255);</li>
<li>sprintf(time_p, "%d-%02d-%02d,%02d:%02d:%02d", tm.tm_year+1900, tm.tm_mon+1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);</li>
<li></li>
<li>Changes_p-&gt;date_p = malloc(sizeof(NH_BYTE) * (strlen(time_p) + 1));</li>
<li>NH_MAKE_CHECK_NULL(Changes_p-&gt;date_p)</li>
<li>strcpy(Changes_p-&gt;date_p, time_p);</li>
<li></li>
<li>int length = 2047;</li>
<li>NH_BYTE normalized_p[length];</li>
<li>memset(normalized_p, 0, length);</li>
<li>nh_make_normalizeChanges(Changes_p, normalized_p, length);</li>
<li></li>
<li>NH_BYTE command_p[length];</li>
<li>memset(command_p, 0, length);</li>
<li>sprintf(command_p, "echo %s | sha1sum -z | head -c 40", normalized_p);</li>
<li></li>
<li>char id_p[1035];</li>
<li>FILE *Out_p = popen(command_p, "r");</li>
<li>NH_MAKE_CHECK_NULL(Out_p)</li>
<li></li>
<li>while (fgets(id_p, sizeof(id_p), Out_p) != NULL) {}</li>
<li>pclose(Out_p);</li>
<li></li>
<li>Changes_p-&gt;id_p = malloc(sizeof(NH_BYTE) * (strlen(id_p) + 1));</li>
<li>NH_MAKE_CHECK_NULL(Changes_p-&gt;id_p)</li>
<li>strcpy(Changes_p-&gt;id_p, id_p);</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>diff --git a/src/lib/nhmake/Core/Changes.h b/src/lib/nhmake/Core/Changes.h new file mode 100644 index 0000000..edc5b2d --- /dev/null +++ b/src/lib/nhmake/Core/Changes.h @ -0,0 +1,71 @ +#ifndef NH_MAKE_CHANGES_H +#define NH_MAKE_CHANGES_H</li>
<li>+#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>+/**</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>+#include "../Common/Types/Private.h"</li>
<li>+#endif</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>typedef struct nh_make_ChangesNode {</li>
<li>NH_MAKE_CHANGES_NODE type;</li>
<li>NH_BYTE *text_p;</li>
<li>int length;</li>
<li>struct nh_make_ChangesNode *Parent_p;</li>
<li>struct nh_make_ChangesNode **Children_pp;</li>
<li>int children;</li>
<li>} nh_make_ChangesNode;</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li>+#endif diff --git a/src/lib/nhmake/Core/File.c b/src/lib/nhmake/Core/File.c new file mode 100644 index 0000000..46994c8 --- /dev/null +++ b/src/lib/nhmake/Core/File.c @ -0,0 +1,236 @ +// LICENSE NOTICE ==================================================================================</li>
<li>+/**</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>+// INCLUDE =========================================================================================</li>
<li>+#include "File.h" +#include "Utils.h"</li>
<li>+#include "../UI/Message.h" +#include "../Common/Macros/Macros.h"</li>
<li>+#include NH_MAKE_FLOW +#include NH_MAKE_DEFAULT_CHECK</li>
<li>+#include &amp;ltunistd.h&gt; +#include &amp;ltstring.h&gt; +#include &amp;ltstdlib.h&gt; +#include &amp;ltdlfcn.h&gt; +#include &amp;ltstdio.h&gt; +#include &amp;ltpwd.h&gt;</li>
<li>+#if defined(__linux__) || defined(__APPLE__)</li>
<li>#include &amp;ltsys/stat.h&gt;</li>
<li>#include &amp;ltsys/types.h&gt; +#endif</li>
<li>+// GENERAL FILE RELATED OPERATIONS =================================================================</li>
<li>+NH_MAKE_BOOL nh_make_canFindSharedLib(</li>
<li>const NH_BYTE *lib_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>NH_BYTE path_p[1024] = {'\0'};</li>
<li>sprintf(path_p, "/usr/lib/lib%s.so", lib_p);</li>
<li></li>
<li>if(access(path_p, F_OK) != -1) {NH_MAKE_DIAGNOSTIC_END(NH_MAKE_TRUE)}</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_FALSE) +}</li>
<li>+NH_MAKE_RESULT nh_make_copy(</li>
<li>nh_make_VariableArray *Array_p, NH_BYTE *in_p, NH_BYTE *out_p, NH_MAKE_BOOL recursive, NH_MAKE_BOOL sudo) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>NH_BYTE realin_p[1024] = {'\0'}, realout_p[1024] = {'\0'};</li>
<li>realpath(out_p, realout_p);</li>
<li>realpath(in_p, realin_p);</li>
<li>nh_make_messagef(sudo ? "COPY %s TO %s \e[1;31mSUDO PREPENDED\e[0m" : "COPY %s TO %s", realin_p, realout_p);</li>
<li></li>
<li>if (!nh_make_canRunCommand("cp")) {NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_CP_NOT_FOUND)}</li>
<li>+#if defined(__linux__) || defined(__APPLE__)</li>
<li></li>
<li>NH_BYTE command_p[32] = {'\0'};</li>
<li>sprintf(command_p, sudo ? "sudo cp" : "cp");</li>
<li>NH_BYTE fullCommand_p[1024] = {'\0'};</li>
<li></li>
<li>if (out_p[0] != '/') {</li>
<li>sprintf(fullCommand_p, recursive ? "%s -rp %s %s" : "%s -p %s %s", command_p, in_p, out_p);</li>
<li>}</li>
<li>else {</li>
<li>sprintf(fullCommand_p, recursive ? "%s -rp %s %s" : "%s -p %s %s", command_p, in_p, out_p);</li>
<li>}</li>
<li></li>
<li>int status = system(fullCommand_p);</li>
<li>if (WEXITSTATUS(status) || WIFSIGNALED(status)) {NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_CP_EXECUTION_FAILED)}</li>
<li>+#elif defined(WIN_32)</li>
<li>+#endif</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+NH_MAKE_RESULT nh_make_createSymLink(</li>
<li>NH_BYTE *filePath_p, NH_BYTE *symLinkPath_p, NH_MAKE_BOOL sudo) +{ +NH_MAKE_BEGIN()</li>
<li>+#if defined(__linux__) || defined(__APPLE__)</li>
<li></li>
<li>if (!nh_make_canRunCommand("ln")) {NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_CP_NOT_FOUND)}</li>
<li></li>
<li>NH_BYTE command_p[64] = {'\0'};</li>
<li>sprintf(command_p, sudo ? "sudo ln -s" : "ln -s");</li>
<li></li>
<li>NH_BYTE fullCommand_p[1024] = {'\0'};</li>
<li>sprintf(fullCommand_p, "%s %s %s", command_p, filePath_p, symLinkPath_p);</li>
<li></li>
<li>int status = system(fullCommand_p);</li>
<li>if (WEXITSTATUS(status) || WIFSIGNALED(status)) {NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_CP_EXECUTION_FAILED)}</li>
<li>+#elif defined(WIN_32)</li>
<li>+#endif</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+NH_MAKE_BOOL nh_make_fileExists(</li>
<li>NH_BYTE *filename_p) +{ +NH_MAKE_BEGIN() +NH_MAKE_END(access(filename_p, F_OK) != -1 ? NH_MAKE_TRUE : NH_MAKE_FALSE) +}</li>
<li>+NH_MAKE_RESULT nh_make_writeBytesToFile(</li>
<li>NH_BYTE *filename_p, NH_BYTE *bytes_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>NH_MAKE_CHECK_NULL(bytes_p)</li>
<li>NH_MAKE_CHECK_NULL(filename_p)</li>
<li></li>
<li>FILE *f = fopen(filename_p, "w");</li>
<li>NH_MAKE_CHECK_NULL(f)</li>
<li></li>
<li>fprintf(f, "%s", bytes_p);</li>
<li>fclose(f);</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+// FILE STRUCTURE ==================================================================================</li>
<li>+nh_make_File nh_make_initFile() +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>nh_make_File File;</li>
<li>File.path_p = NULL;</li>
<li>File.data_p = NULL;</li>
<li>+NH_MAKE_END(File) +}</li>
<li>+void nh_make_freeFileData(</li>
<li>nh_make_File *File_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>free(File_p-&gt;path_p);</li>
<li>free(File_p-&gt;data_p);</li>
<li>+NH_MAKE_SILENT_END() +}</li>
<li>+NH_BYTE *nh_make_getFileData(</li>
<li>const NH_BYTE* path_p, long *size_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>FILE *fh = fopen(path_p, "rb");</li>
<li>if (fh == NULL) {NH_MAKE_END(NULL)}</li>
<li></li>
<li>if (fseek(fh, 0, SEEK_END) != 0) {NH_MAKE_END(NULL)}</li>
<li>long size = ftell(fh);</li>
<li>rewind(fh);</li>
<li></li>
<li>if(size &amp;lt= 0) {</li>
<li>fclose(fh);</li>
<li>NH_MAKE_END(NULL)</li>
<li>}</li>
<li></li>
<li>NH_BYTE *data_p = malloc(size+1);</li>
<li>if (data_p == NULL) {NH_MAKE_END(NULL)}</li>
<li></li>
<li>memset(data_p, 0, size+1);</li>
<li>fread(data_p, 1, size, fh);</li>
<li>fclose(fh);</li>
<li></li>
<li>data_p[size] = 0;</li>
<li>if (size_p != NULL) {*size_p = size;}</li>
<li>+NH_MAKE_END(data_p) +}</li>
<li>+NH_MAKE_RESULT nh_make_setFileData(</li>
<li>nh_make_File *File_p, NH_BYTE *path_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>if (!File_p || !path_p) {NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_BAD_STATE)}</li>
<li></li>
<li>File_p-&gt;data_p = nh_make_getFileData(path_p, NULL);</li>
<li>NH_MAKE_CHECK_NULL(File_p-&gt;data_p)</li>
<li></li>
<li>File_p-&gt;path_p = malloc(strlen(path_p) + 1);</li>
<li>NH_MAKE_CHECK_NULL(File_p-&gt;path_p)</li>
<li></li>
<li>strcpy(File_p-&gt;path_p, path_p);</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+// FILE STRUCTURE ARRAY ============================================================================</li>
<li>+void nh_make_initFileArray(</li>
<li>nh_make_FileArray *Array_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>Array_p-&gt;length = 0;</li>
<li>Array_p-&gt;Files_p = NULL;</li>
<li>+NH_MAKE_SILENT_END() +}</li>
<li>+NH_MAKE_RESULT nh_make_appendFile(</li>
<li>nh_make_FileArray *Array_p, NH_BYTE *path_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>if (!Array_p-&gt;length) {</li>
<li>Array_p-&gt;Files_p = malloc(sizeof(nh_make_File));</li>
<li>NH_MAKE_CHECK_NULL(Array_p-&gt;Files_p)</li>
<li>}</li>
<li>else {</li>
<li>Array_p-&gt;Files_p = realloc(Array_p-&gt;Files_p, sizeof(nh_make_File) * (Array_p-&gt;length + 1));</li>
<li>NH_MAKE_CHECK_NULL(Array_p-&gt;Files_p)</li>
<li>}</li>
<li></li>
<li>NH_MAKE_CHECK(nh_make_setFileData(Array_p-&gt;Files_p+Array_p-&gt;length, path_p))</li>
<li></li>
<li>Array_p-&gt;length++;</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>diff --git a/src/lib/nhmake/Core/File.h b/src/lib/nhmake/Core/File.h new file mode 100644 index 0000000..2e86e7c --- /dev/null +++ b/src/lib/nhmake/Core/File.h @ -0,0 +1,91 @ +#ifndef NH_MAKE_FILE_H +#define NH_MAKE_FILE_H</li>
<li>+#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>+/**</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>+#include "../Parser/Variables.h"</li>
<li>+#include "../Common/Types/Private.h"</li>
<li>+#include &amp;ltstddef.h&gt;</li>
<li>+#endif</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>typedef struct nh_make_File {</li>
<li>NH_BYTE *path_p;</li>
<li>NH_BYTE *data_p;</li>
<li>} nh_make_File;</li>
<li></li>
<li>typedef struct nh_make_FileArray {</li>
<li>int length;</li>
<li>nh_make_File *Files_p;</li>
<li>} nh_make_FileArray;</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li>+#endif diff --git a/src/lib/nhmake/Core/Runtime.c b/src/lib/nhmake/Core/Runtime.c new file mode 100644 index 0000000..4c25ab0 --- /dev/null +++ b/src/lib/nhmake/Core/Runtime.c @ -0,0 +1,288 @ +// LICENSE NOTICE ==================================================================================</li>
<li>+/**</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>+// INCLUDE =========================================================================================</li>
<li>+#include "Runtime.h" +#include "Thread.h" +#include "File.h" +#include "Build.h" +#include "Options.h" +#include "Utils.h"</li>
<li>+#include "../Parser/Functions.h" +#include "../Parser/Variables.h"</li>
<li>+#include "../Common/Macros/Macros.h" +#include NH_MAKE_FLOW +#include NH_MAKE_DEFAULT_CHECK</li>
<li>+#include &amp;ltstdio.h&gt; +#include &amp;ltstring.h&gt; +#include &amp;ltstdlib.h&gt; +#include &amp;ltctype.h&gt;</li>
<li>+// VARS ============================================================================================</li>
<li>+nh_make_Runtime NH_MAKE_DEFAULT_RUNTIME;</li>
<li>+// HELPER ==========================================================================================</li>
<li>+NH_MAKE_RESULT nh_make_stringifySourceContextNameAndVersion(</li>
<li>nh_make_SourceContext *SourceContext_p, NH_BYTE string_p[255]) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>memset(string_p, 0, 255);</li>
<li></li>
<li>sprintf(</li>
<li>string_p, "%s %s v.%d.%d.%d.%d",</li>
<li>SourceContext_p-&gt;type == NH_MAKE_SOURCE_CONTEXT_BINARY ? "bin" : "lib",</li>
<li>SourceContext_p-&gt;name_p,</li>
<li>SourceContext_p-&gt;Version.api, SourceContext_p-&gt;Version.major, SourceContext_p-&gt;Version.minor,</li>
<li>SourceContext_p-&gt;Version.patch</li>
<li>);</li>
<li>+NH_MAKE_END(NH_MAKE_SUCCESS) +}</li>
<li>+// PARSE ===========================================================================================</li>
<li>+static int nh_make_getOptionLength(</li>
<li>int argc, NH_BYTE **argv_pp) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>int length = 0;</li>
<li></li>
<li>for (int i = 0; i &amp;lt argc; ++i) {</li>
<li>if (i &amp;&amp; argv_pp[i][0] == '-') {break;}</li>
<li>length++;</li>
<li>}</li>
<li>+NH_MAKE_END(length) +}</li>
<li>+static NH_MAKE_RESULT nh_make_parseArguments(</li>
<li>nh_make_Runtime *Runtime_p, int argc, NH_BYTE **argv_pp) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>for (int i = 0; i &amp;lt argc;) {</li>
<li>int advance = 0;</li>
<li>int optionLength = nh_make_getOptionLength(argc-i, argv_pp+i);</li>
<li>NH_MAKE_CHECK(nh_make_parseOption(Runtime_p, optionLength, &amp;argv_pp[i], &amp;advance))</li>
<li>if (optionLength != advance) {</li>
<li>NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_BAD_STATE)</li>
<li>}</li>
<li>i += advance;</li>
<li>}</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+// RUN =============================================================================================</li>
<li>+NH_BYTE **nh_make_processArguments(</li>
<li>nh_make_VariableArray *Variables_p, NH_BYTE **args_pp, int args, int *processedArgCount_p) +{ +NH_MAKE_BEGIN()</li>
<li>+#include NH_MAKE_CUSTOM_CHECK</li>
<li></li>
<li>int processedArgCount = 0;</li>
<li>NH_BYTE **processedArgs_pp = malloc(sizeof(NH_BYTE*));</li>
<li>NH_MAKE_CHECK_NULL(NULL, processedArgs_pp)</li>
<li></li>
<li>for (int i = 0; i &amp;lt args; ++i)</li>
<li>{</li>
<li>nh_make_Variable *Variable_p = nh_make_getVariable(Variables_p, args_pp[i]);</li>
<li>if (Variable_p) {</li>
<li>for (int j = 0; j &amp;lt Variable_p-&gt;valueCount; ++j) {</li>
<li>processedArgs_pp[processedArgCount] = malloc(strlen(Variable_p-&gt;values_pp[j]) + 1);</li>
<li>NH_MAKE_CHECK_NULL(NULL, processedArgs_pp[processedArgCount])</li>
<li>strcpy(processedArgs_pp[processedArgCount++], Variable_p-&gt;values_pp[j]);</li>
<li>processedArgs_pp = realloc(processedArgs_pp, sizeof(NH_BYTE*) * (processedArgCount + 1));</li>
<li>NH_MAKE_CHECK_NULL(NULL, processedArgs_pp)</li>
<li>}</li>
<li>}</li>
<li>else {</li>
<li>processedArgs_pp[processedArgCount] = malloc(strlen(args_pp[i]) + 1);</li>
<li>NH_MAKE_CHECK_NULL(NULL, processedArgs_pp[processedArgCount])</li>
<li>strcpy(processedArgs_pp[processedArgCount++], args_pp[i]);</li>
<li>processedArgs_pp = realloc(processedArgs_pp, sizeof(NH_BYTE*) * (processedArgCount + 1));</li>
<li>NH_MAKE_CHECK_NULL(NULL, processedArgs_pp)</li>
<li>}</li>
<li>}</li>
<li>+#include NH_MAKE_DEFAULT_CHECK</li>
<li></li>
<li>*processedArgCount_p = processedArgCount;</li>
<li>+NH_MAKE_END(processedArgs_pp) +}</li>
<li>+static NH_MAKE_RESULT nh_make_executeGlobalFunctions(</li>
<li>nh_make_Runtime *Runtime_p, nh_make_Parser *Parser_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>if (Parser_p-&gt;executed) {NH_MAKE_END(NH_MAKE_SUCCESS)}</li>
<li></li>
<li>nh_make_Block Block;</li>
<li>Block.definitions = Parser_p-&gt;definitions;</li>
<li>Block.Definitions_p = Parser_p-&gt;Definitions_p;</li>
<li></li>
<li>NH_MAKE_CHECK(nh_make_executeBlock(Runtime_p, &amp;Block))</li>
<li></li>
<li>Parser_p-&gt;executed = NH_MAKE_TRUE;</li>
<li>+NH_MAKE_END(NH_MAKE_SUCCESS) +}</li>
<li>+NH_MAKE_RESULT nh_make_executeRuntime(</li>
<li>nh_make_Runtime *Runtime_p, NH_BYTE **args_pp, int args) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>for (int i = 0; i &amp;lt Runtime_p-&gt;FileArray.length; ++i)</li>
<li>{</li>
<li>NH_MAKE_CHECK(nh_make_appendParser(</li>
<li>&amp;Runtime_p-&gt;ParserArray, &amp;Runtime_p-&gt;FileArray.Files_p[i], Runtime_p-&gt;showParseTree</li>
<li>))</li>
<li></li>
<li>nh_make_operationf("Execute Global Functions");</li>
<li>nh_make_Parser *Parser_p = &amp;Runtime_p-&gt;ParserArray.Parsers_p[Runtime_p-&gt;ParserArray.length - 1];</li>
<li></li>
<li>if (Parser_p-&gt;executed) {continue;}</li>
<li>NH_MAKE_CHECK(nh_make_executeGlobalFunctions(Runtime_p, Parser_p))</li>
<li>Parser_p-&gt;executed = NH_MAKE_TRUE;</li>
<li></li>
<li>nh_make_Variable *All_p = nh_make_getVariable(&amp;Runtime_p-&gt;VariableArray, "ALL");</li>
<li>for (int j = 0; All_p &amp;&amp; j &amp;lt All_p-&gt;valueCount; ++j) {</li>
<li>NH_MAKE_CHECK(nh_make_addBuildOption(Runtime_p, All_p-&gt;values_pp[j]))</li>
<li>NH_MAKE_CHECK(nh_make_addTestOption(Runtime_p, All_p-&gt;values_pp[j]))</li>
<li>}</li>
<li>}</li>
<li></li>
<li>int processedArgs = 0;</li>
<li>NH_BYTE **processedArgs_pp = nh_make_processArguments(&amp;Runtime_p-&gt;VariableArray, args_pp, args, &amp;processedArgs);</li>
<li>NH_MAKE_CHECK_NULL(processedArgs_pp)</li>
<li></li>
<li>NH_MAKE_RESULT result = nh_make_parseArguments(Runtime_p, processedArgs, processedArgs_pp);</li>
<li></li>
<li>for (int i = 0; i &amp;lt processedArgs; ++i) {</li>
<li>free(processedArgs_pp[i]);</li>
<li>}</li>
<li>free(processedArgs_pp);</li>
<li></li>
<li>NH_MAKE_CHECK(nh_make_exitMessage(result))</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+NH_MAKE_RESULT nh_make_run(</li>
<li>nh_make_Runtime *Runtime_p, int argc, NH_BYTE **argv_pp) +{ +NH_MAKE_BEGIN() +NH_MAKE_DIAGNOSTIC_END(nh_make_runThread(Runtime_p, argv_pp, argc)) +}</li>
<li>+// CREATE ==========================================================================================</li>
<li>+static NH_MAKE_RESULT nh_make_initRuntime(</li>
<li>nh_make_Runtime *Runtime_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>Runtime_p-&gt;showParseTree = NH_MAKE_TRUE;</li>
<li>Runtime_p-&gt;GUI = NH_MAKE_FALSE;</li>
<li>Runtime_p-&gt;quiet = NH_MAKE_FALSE;</li>
<li></li>
<li>Runtime_p-&gt;functionCallback_f = NULL;</li>
<li>Runtime_p-&gt;sourceContextCallback_f = NULL;</li>
<li>Runtime_p-&gt;beforeBuildCallback_f = NULL;</li>
<li>Runtime_p-&gt;afterBuildCallback_f = NULL;</li>
<li></li>
<li>nh_make_initFileArray(&amp;Runtime_p-&gt;FileArray);</li>
<li>nh_make_initParserArray(&amp;Runtime_p-&gt;ParserArray);</li>
<li>nh_make_initTestArray(&amp;Runtime_p-&gt;TestArray);</li>
<li>nh_make_initSourceArray(&amp;Runtime_p-&gt;SourceArray);</li>
<li>nh_make_initSourceContextArray(&amp;Runtime_p-&gt;SourceContextArray);</li>
<li>nh_make_initVariableArray(&amp;Runtime_p-&gt;VariableArray);</li>
<li></li>
<li>NH_BYTE *wrk_p = nh_make_getWorkDirectory();</li>
<li></li>
<li>nh_make_updateVariable(&amp;Runtime_p-&gt;VariableArray, "WRK_DIR", &amp;wrk_p, 1);</li>
<li>nh_make_updateVariable(&amp;Runtime_p-&gt;VariableArray, "PROJ_DIR", &amp;wrk_p, 1);</li>
<li>nh_make_updateVariable(&amp;Runtime_p-&gt;VariableArray, "LIB_DEST", &amp;wrk_p, 1);</li>
<li>nh_make_updateVariable(&amp;Runtime_p-&gt;VariableArray, "BIN_DEST", &amp;wrk_p, 1);</li>
<li></li>
<li>NH_BYTE *true_p = "true";</li>
<li>+#ifdef __APPLE__</li>
<li>nh_make_updateVariable(&amp;Runtime_p-&gt;VariableArray, "MAC", &amp;true_p, 1); +#elif WIN32</li>
<li>nh_make_updateVariable(&amp;Runtime_p-&gt;VariableArray, "WINDOWS", &amp;true_p, 1); +#elif __linux__</li>
<li>nh_make_updateVariable(&amp;Runtime_p-&gt;VariableArray, "LINUX", &amp;true_p, 1); +#endif</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+nh_make_Runtime *nh_make_createRuntime(</li>
<li>NH_BYTE *name_p) +{ +NH_MAKE_BEGIN()</li>
<li>+#include NH_MAKE_CUSTOM_CHECK</li>
<li></li>
<li>NH_MAKE_CHECK_NULL(NULL, name_p)</li>
<li></li>
<li>nh_make_Runtime *Runtime_p = malloc(sizeof(nh_make_Runtime));</li>
<li>NH_MAKE_CHECK_NULL(NULL, Runtime_p)</li>
<li></li>
<li>NH_MAKE_CHECK(NULL, nh_make_initRuntime(Runtime_p))</li>
<li></li>
<li>nh_make_updateVariable(&amp;Runtime_p-&gt;VariableArray, "NAME", &amp;name_p, 1);</li>
<li>+#include NH_MAKE_DEFAULT_CHECK</li>
<li>+NH_MAKE_END(Runtime_p) +}</li>
<li>+void nh_make_destroyRuntime(</li>
<li>nh_make_Runtime *Runtime_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>// TODO Implement.</li>
<li>+NH_MAKE_SILENT_END() +}</li>
<li>+// INITIALIZE/TERMINATE ============================================================================</li>
<li>+NH_MAKE_RESULT nh_make_initialize() +{</li>
<li>nh_make_initThreadPool();</li>
<li>NH_MAKE_CHECK(nh_make_initRuntime(&amp;NH_MAKE_DEFAULT_RUNTIME))</li>
<li>NH_BYTE *name_p = "selfmake";</li>
<li>nh_make_updateVariable(&amp;NH_MAKE_DEFAULT_RUNTIME.VariableArray, "NAME", &amp;name_p, 1); +}</li>
<li>+void nh_make_terminate() +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>// TODO Implement.</li>
<li>+NH_MAKE_SILENT_END() +}</li>
<li>diff --git a/src/lib/nhmake/Core/Runtime.h b/src/lib/nhmake/Core/Runtime.h new file mode 100644 index 0000000..a4ff012 --- /dev/null +++ b/src/lib/nhmake/Core/Runtime.h @ -0,0 +1,92 @ +#ifndef NH_MAKE_RUNTIME_H +#define NH_MAKE_RUNTIME_H</li>
<li>+#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>+/**</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>+#include "Source.h"</li>
<li>+#include "../Parser/Parser.h" +#include "../Parser/Variables.h"</li>
<li>+#include "../Test/Test.h"</li>
<li>+#include "../Common/Types/Private.h"</li>
<li>+#endif</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>typedef struct nh_make_Runtime {</li>
<li>NH_MAKE_BOOL quiet;</li>
<li>NH_MAKE_BOOL GUI;</li>
<li>NH_MAKE_BOOL showParseTree;</li>
<li>NH_BYTE *prefix_p;</li>
<li>nh_make_ParserArray ParserArray;</li>
<li>nh_make_SourceArray SourceArray;</li>
<li>nh_make_TestArray TestArray;</li>
<li>nh_make_SourceContextArray SourceContextArray;</li>
<li>nh_make_VariableArray VariableArray;</li>
<li>nh_make_FileArray FileArray;</li>
<li>nh_make_functionCallback_f functionCallback_f;</li>
<li>nh_make_sourceContextCallback_f sourceContextCallback_f;</li>
<li>nh_make_sourceContextCallback_f beforeBuildCallback_f;</li>
<li>nh_make_sourceContextCallback_f afterBuildCallback_f;</li>
<li>} nh_make_Runtime;</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li>+#endif diff --git a/src/lib/nhmake/Core/Source.c b/src/lib/nhmake/Core/Source.c new file mode 100644 index 0000000..b3a45ce --- /dev/null +++ b/src/lib/nhmake/Core/Source.c @ -0,0 +1,313 @ +// LICENSE NOTICE ==================================================================================</li>
<li>+/**</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>+// INCLUDE =========================================================================================</li>
<li>+#include "Source.h" +#include "Runtime.h" +#include "Version.h"</li>
<li>+#include "../Common/Macros/Macros.h" +#include NH_MAKE_FLOW +#include NH_MAKE_DEFAULT_CHECK</li>
<li>+#include &amp;ltstdio.h&gt; +#include &amp;ltstdlib.h&gt; +#include &amp;ltstring.h&gt; +#include &amp;ltunistd.h&gt; +#include &amp;ltctype.h&gt;</li>
<li>+// INIT ============================================================================================</li>
<li>+void nh_make_initSourceContextArray(</li>
<li>nh_make_SourceContextArray *Array_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>Array_p-&gt;length = 0;</li>
<li>Array_p-&gt;maxNameLength = 0;</li>
<li>Array_p-&gt;SourceContexts_p = NULL;</li>
<li>+NH_MAKE_SILENT_END() +}</li>
<li>+static nh_make_SourceContext nh_make_initSourceContext(</li>
<li>NH_MAKE_SOURCE_CONTEXT type) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>nh_make_SourceContext SourceContext;</li>
<li></li>
<li>SourceContext.type = type;</li>
<li>SourceContext.path_p = NULL;</li>
<li>SourceContext.compileArgs_p = NULL;</li>
<li>SourceContext.linkArgs_p = NULL;</li>
<li>SourceContext.Version = nh_make_initVersion();</li>
<li>SourceContext.outputPath_p = NULL;</li>
<li>+NH_MAKE_END(SourceContext) +}</li>
<li>+void nh_make_initSourceArray(</li>
<li>nh_make_SourceArray *Array_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>Array_p-&gt;length = 0;</li>
<li>Array_p-&gt;Sources_p = NULL;</li>
<li>+NH_MAKE_SILENT_END() +}</li>
<li>+static nh_make_Source nh_make_initSource() +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>nh_make_Source Source;</li>
<li>Source.Context_p = NULL;</li>
<li>Source.path_p = NULL;</li>
<li>+NH_MAKE_END(Source) +}</li>
<li>+// INDENT ==========================================================================================</li>
<li>+void nh_make_getIndentAfterSourceContext(</li>
<li>NH_BYTE *name_p, NH_BYTE *buffer_p, int size, nh_make_SourceContextArray *Array_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>memset(buffer_p, 0, size);</li>
<li>int diff = Array_p-&gt;maxNameLength - strlen(name_p);</li>
<li>for (int i = 0; i &amp;lt diff; ++i) {buffer_p[i] = ' ';}</li>
<li>+NH_MAKE_SILENT_END() +}</li>
<li>+// ADD =============================================================================================</li>
<li>+static NH_MAKE_BOOL nh_make_matchSourceContext(</li>
<li>nh_make_SourceContext *SourceContext_p, NH_MAKE_SOURCE_CONTEXT type) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>if (type != NH_MAKE_SOURCE_CONTEXT_UNDEFINED) {</li>
<li>if (type == NH_MAKE_SOURCE_CONTEXT_BINARY &amp;&amp; SourceContext_p-&gt;type != NH_MAKE_SOURCE_CONTEXT_BINARY) {</li>
<li>NH_MAKE_END(NH_MAKE_FALSE)</li>
<li>}</li>
<li>if ((type == NH_MAKE_SOURCE_CONTEXT_SHARED_LIBRARY || type == NH_MAKE_SOURCE_CONTEXT_STATIC_LIBRARY) &amp;&amp; SourceContext_p-&gt;type == NH_MAKE_SOURCE_CONTEXT_BINARY) {</li>
<li>NH_MAKE_END(NH_MAKE_FALSE)</li>
<li>}</li>
<li>}</li>
<li>+NH_MAKE_END(NH_MAKE_TRUE) +}</li>
<li>+NH_MAKE_RESULT nh_make_addSourceContext(</li>
<li>nh_make_Runtime *Runtime_p, nh_make_Function *Function_p, NH_MAKE_SOURCE_CONTEXT type, int offset) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>nh_make_SourceContextArray *Array_p = &amp;Runtime_p-&gt;SourceContextArray;</li>
<li></li>
<li>if (Function_p-&gt;arguments &amp;lt 1) {NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_BAD_STATE)}</li>
<li></li>
<li>if (!Array_p-&gt;SourceContexts_p) {</li>
<li>Array_p-&gt;SourceContexts_p = malloc(sizeof(nh_make_SourceContext));</li>
<li>NH_MAKE_CHECK_NULL(Array_p-&gt;SourceContexts_p)</li>
<li>}</li>
<li>else {</li>
<li>Array_p-&gt;SourceContexts_p = realloc(Array_p-&gt;SourceContexts_p, sizeof(nh_make_SourceContext) * (Array_p-&gt;length + 1));</li>
<li>NH_MAKE_CHECK_NULL(Array_p-&gt;SourceContexts_p)</li>
<li>}</li>
<li></li>
<li>nh_make_SourceContext *SourceContext_p = &amp;Array_p-&gt;SourceContexts_p[Array_p-&gt;length];</li>
<li>*SourceContext_p = nh_make_initSourceContext(type);</li>
<li></li>
<li>int index = offset;</li>
<li></li>
<li>SourceContext_p-&gt;name_p = malloc(strlen(Function_p-&gt;arguments_pp[index]) + 1);</li>
<li>NH_MAKE_CHECK_NULL(SourceContext_p-&gt;name_p)</li>
<li>strcpy(SourceContext_p-&gt;name_p, Function_p-&gt;arguments_pp[index++]);</li>
<li></li>
<li>if (Function_p-&gt;arguments &gt; index) {</li>
<li>SourceContext_p-&gt;path_p = malloc(strlen(Function_p-&gt;arguments_pp[index]) + 1);</li>
<li>NH_MAKE_CHECK_NULL(SourceContext_p-&gt;path_p)</li>
<li>strcpy(SourceContext_p-&gt;path_p, Function_p-&gt;arguments_pp[index++]);</li>
<li>}</li>
<li></li>
<li>if (Function_p-&gt;arguments &gt; index) {</li>
<li>SourceContext_p-&gt;outputPath_p = malloc(strlen(Function_p-&gt;arguments_pp[index]) + 1);</li>
<li>NH_MAKE_CHECK_NULL(SourceContext_p-&gt;outputPath_p)</li>
<li>strcpy(SourceContext_p-&gt;outputPath_p, Function_p-&gt;arguments_pp[index++]);</li>
<li>}</li>
<li></li>
<li>if (Function_p-&gt;arguments &gt; index) {</li>
<li>SourceContext_p-&gt;Version.major = strtol(Function_p-&gt;arguments_pp[index++], NULL, 10);</li>
<li>}</li>
<li></li>
<li>if (Function_p-&gt;arguments &gt; index) {</li>
<li>SourceContext_p-&gt;Version.minor = strtol(Function_p-&gt;arguments_pp[index++], NULL, 10);</li>
<li>}</li>
<li></li>
<li>if (Function_p-&gt;arguments &gt; index) {</li>
<li>SourceContext_p-&gt;Version.patch = strtol(Function_p-&gt;arguments_pp[index++], NULL, 10);</li>
<li>}</li>
<li></li>
<li>if (strlen(SourceContext_p-&gt;name_p) &gt; Array_p-&gt;maxNameLength) {</li>
<li>Array_p-&gt;maxNameLength = strlen(SourceContext_p-&gt;name_p);</li>
<li>}</li>
<li></li>
<li>Array_p-&gt;length++;</li>
<li></li>
<li>NH_MAKE_CHECK(nh_make_appendToVariable(&amp;Runtime_p-&gt;VariableArray, "ALL", &amp;Function_p-&gt;arguments_pp[offset], 1))</li>
<li></li>
<li>if (type == NH_MAKE_SOURCE_CONTEXT_BINARY) {</li>
<li>NH_MAKE_CHECK(nh_make_appendToVariable(&amp;Runtime_p-&gt;VariableArray, "BINS", &amp;Function_p-&gt;arguments_pp[offset], 1))</li>
<li>}</li>
<li>else {</li>
<li>NH_MAKE_CHECK(nh_make_appendToVariable(&amp;Runtime_p-&gt;VariableArray, "LIBS", &amp;Function_p-&gt;arguments_pp[offset], 1))</li>
<li>}</li>
<li></li>
<li>NH_MAKE_CHECK(nh_make_computeVersion(Runtime_p, SourceContext_p))</li>
<li></li>
<li>switch (type)</li>
<li>{</li>
<li>case NH_MAKE_SOURCE_CONTEXT_BINARY :</li>
<li>nh_make_messagef("Add binary [%s]", SourceContext_p-&gt;name_p);</li>
<li>break;</li>
<li>case NH_MAKE_SOURCE_CONTEXT_SHARED_LIBRARY :</li>
<li>nh_make_messagef("Add shared library [%s]", SourceContext_p-&gt;name_p);</li>
<li>break;</li>
<li>case NH_MAKE_SOURCE_CONTEXT_STATIC_LIBRARY :</li>
<li>nh_make_messagef("Add static library [%s]", SourceContext_p-&gt;name_p);</li>
<li>break;</li>
<li>}</li>
<li>+NH_MAKE_END(NH_MAKE_SUCCESS) +}</li>
<li>+// ARGUMENTS =======================================================================================</li>
<li>+NH_MAKE_RESULT nh_make_addCompileArguments(</li>
<li>nh_make_SourceContextArray *ContextArray_p, nh_make_Function *Function_p, NH_MAKE_SOURCE_CONTEXT type) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>if (Function_p-&gt;arguments &amp;lt 2) {NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_BAD_STATE)}</li>
<li></li>
<li>nh_make_SourceContext *Context_p = NULL;</li>
<li>for (int j = 0; j &amp;lt ContextArray_p-&gt;length; ++j) {</li>
<li>if (!nh_make_matchSourceContext(ContextArray_p-&gt;SourceContexts_p+j, type)) {</li>
<li>continue;</li>
<li>}</li>
<li>if (!strcmp(ContextArray_p-&gt;SourceContexts_p[j].name_p, Function_p-&gt;arguments_pp[0])) {</li>
<li>Context_p = &amp;ContextArray_p-&gt;SourceContexts_p[j];</li>
<li>}</li>
<li>}</li>
<li></li>
<li>if (!Context_p) {NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_LIBRARY_NOT_FOUND)}</li>
<li></li>
<li>Context_p-&gt;compileArgs_p = malloc(strlen(Function_p-&gt;arguments_pp[1]) + 1);</li>
<li>NH_MAKE_CHECK_NULL(Context_p-&gt;compileArgs_p)</li>
<li>sprintf(Context_p-&gt;compileArgs_p, Function_p-&gt;arguments_pp[1]);</li>
<li></li>
<li>NH_BYTE offset_p[64];</li>
<li>nh_make_getIndentAfterSourceContext(Context_p-&gt;name_p, offset_p, 64, ContextArray_p);</li>
<li>nh_make_messagef("[%s]%s Set compile arguments \"%s\"", Context_p-&gt;name_p, offset_p, Context_p-&gt;compileArgs_p);</li>
<li>+NH_MAKE_END(NH_MAKE_SUCCESS) +}</li>
<li>+NH_MAKE_RESULT nh_make_addLinkArguments(</li>
<li>nh_make_SourceContextArray *ContextArray_p, nh_make_Function *Function_p, NH_MAKE_SOURCE_CONTEXT type) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>if (Function_p-&gt;arguments != 2) {NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_BAD_STATE)}</li>
<li></li>
<li>nh_make_SourceContext *Context_p = NULL;</li>
<li>for (int j = 0; j &amp;lt ContextArray_p-&gt;length; ++j) {</li>
<li>if (!nh_make_matchSourceContext(ContextArray_p-&gt;SourceContexts_p+j, type)) {</li>
<li>continue;</li>
<li>}</li>
<li>if (!strcmp(ContextArray_p-&gt;SourceContexts_p[j].name_p, Function_p-&gt;arguments_pp[0])) {</li>
<li>Context_p = &amp;ContextArray_p-&gt;SourceContexts_p[j];</li>
<li>}</li>
<li>}</li>
<li></li>
<li>if (!Context_p) {NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_LIBRARY_NOT_FOUND)}</li>
<li></li>
<li>Context_p-&gt;linkArgs_p = malloc(strlen(Function_p-&gt;arguments_pp[1]) + 1);</li>
<li>NH_MAKE_CHECK_NULL(Context_p-&gt;linkArgs_p)</li>
<li>sprintf(Context_p-&gt;linkArgs_p, Function_p-&gt;arguments_pp[1]);</li>
<li></li>
<li>NH_BYTE offset_p[64];</li>
<li>nh_make_getIndentAfterSourceContext(Context_p-&gt;name_p, offset_p, 64, ContextArray_p);</li>
<li>nh_make_messagef("[%s]%s Set link arguments \"%s\"", Context_p-&gt;name_p, offset_p, Context_p-&gt;linkArgs_p);</li>
<li>+NH_MAKE_END(NH_MAKE_SUCCESS) +}</li>
<li>+// SOURCES =========================================================================================</li>
<li>+NH_MAKE_RESULT nh_make_addSource(</li>
<li>nh_make_SourceContextArray *ContextArray_p, nh_make_SourceArray *SourceArray_p, nh_make_Function *Function_p,</li>
<li>NH_MAKE_SOURCE_CONTEXT type) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>nh_make_SourceContext *Context_p = NULL;</li>
<li></li>
<li>for (int i = 0; i &amp;lt Function_p-&gt;arguments; ++i)</li>
<li>{</li>
<li>if (Function_p-&gt;argumentTypes_p[i] == NH_MAKE_TOKEN_IDENTIFIER) {</li>
<li>for (int j = 0; j &amp;lt ContextArray_p-&gt;length; ++j) {</li>
<li>if (!nh_make_matchSourceContext(ContextArray_p-&gt;SourceContexts_p+j, type)) {</li>
<li>continue;</li>
<li>}</li>
<li>if (!strcmp(ContextArray_p-&gt;SourceContexts_p[j].name_p, Function_p-&gt;arguments_pp[i])) {</li>
<li>Context_p = &amp;ContextArray_p-&gt;SourceContexts_p[j];</li>
<li>}</li>
<li>}</li>
<li>}</li>
<li>else {</li>
<li></li>
<li>if (!Context_p) {</li>
<li>if (!ContextArray_p-&gt;length) {NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_BAD_STATE)}</li>
<li>Context_p = ContextArray_p-&gt;SourceContexts_p;</li>
<li>}</li>
<li></li>
<li>if (!SourceArray_p-&gt;Sources_p) {</li>
<li>SourceArray_p-&gt;Sources_p = malloc(sizeof(nh_make_Source));</li>
<li>NH_MAKE_CHECK_NULL(SourceArray_p-&gt;Sources_p)</li>
<li>}</li>
<li>else {</li>
<li>SourceArray_p-&gt;Sources_p = realloc(SourceArray_p-&gt;Sources_p, sizeof(nh_make_Source) * (SourceArray_p-&gt;length + 1));</li>
<li>NH_MAKE_CHECK_NULL(SourceArray_p-&gt;Sources_p)</li>
<li>}</li>
<li></li>
<li>nh_make_Source *Source_p = &amp;SourceArray_p-&gt;Sources_p[SourceArray_p-&gt;length];</li>
<li>*Source_p = nh_make_initSource();</li>
<li></li>
<li>Source_p-&gt;Context_p = Context_p;</li>
<li>Source_p-&gt;path_p = malloc(strlen(Function_p-&gt;arguments_pp[i]) + 1);</li>
<li>NH_MAKE_CHECK_NULL(Source_p-&gt;path_p)</li>
<li>sprintf(Source_p-&gt;path_p, Function_p-&gt;arguments_pp[i]);</li>
<li></li>
<li>SourceArray_p-&gt;length++;</li>
<li></li>
<li>NH_BYTE offset_p[64];</li>
<li>nh_make_getIndentAfterSourceContext(Context_p-&gt;name_p, offset_p, 64, ContextArray_p);</li>
<li>nh_make_messagef("[%s]%s Add source file (%d) \"%s\"", Context_p-&gt;name_p, offset_p, Context_p-&gt;type, Source_p-&gt;path_p);</li>
<li>}</li>
<li>}</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>diff --git a/src/lib/nhmake/Core/Source.h b/src/lib/nhmake/Core/Source.h new file mode 100644 index 0000000..8f91e6e --- /dev/null +++ b/src/lib/nhmake/Core/Source.h @ -0,0 +1,67 @ +#ifndef NH_MAKE_SOURCE_H +#define NH_MAKE_SOURCE_H</li>
<li>+#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>+/**</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>+#include "../Common/Types/Private.h"</li>
<li>+#endif</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>typedef struct nh_make_Source {</li>
<li>nh_make_SourceContext *Context_p;</li>
<li>NH_BYTE *path_p;</li>
<li>} nh_make_Source;</li>
<li></li>
<li>typedef struct nh_make_SourceArray {</li>
<li>int length;</li>
<li>nh_make_Source *Sources_p;</li>
<li>} nh_make_SourceArray;</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>typedef struct nh_make_Thread {</li>
<li>int depth;</li>
<li>NH_MAKE_BOOL running;</li>
<li>nh_make_Runtime *Runtime_p;</li>
<li>#if defined(__linux__) || defined(__APPLE__)</li>
<li>pthread_t id;</li>
<li>#elif defined(_WIN32) || defined (WIN32)</li>
<li>DWORD id;</li>
<li>#endif</li>
<li>} nh_make_Thread;</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li>+#endif diff --git a/src/lib/nhmake/Parser/Parser.c b/src/lib/nhmake/Parser/Parser.c new file mode 100644 index 0000000..e850521 --- /dev/null +++ b/src/lib/nhmake/Parser/Parser.c @ -0,0 +1,369 @ +// LICENSE NOTICE ==================================================================================</li>
<li>+/**</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>+// INCLUDE =========================================================================================</li>
<li>+#include "Parser.h"</li>
<li>+#include "../Common/Macros/Macros.h" +#include NH_MAKE_FLOW +#include NH_MAKE_CUSTOM_CHECK</li>
<li>+#include &amp;ltstdio.h&gt; +#include &amp;ltstdlib.h&gt; +#include &amp;ltstring.h&gt; +#include &amp;ltunistd.h&gt; +#include &amp;ltctype.h&gt;</li>
<li>+// PARSE ===========================================================================================</li>
<li>+static nh_make_Token *nh_make_parseToken(</li>
<li>nh_make_Token *Token_p, nh_make_Definition *Definition_p +);</li>
<li>+static nh_make_Token *nh_make_parseFunction(</li>
<li>nh_make_Token *Token_p, nh_make_Definition *Definition_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>Definition_p-&gt;type = NH_MAKE_DEFINITION_FUNCTION;</li>
<li>Definition_p-&gt;Function.name_p = Token_p-&gt;string_p;</li>
<li>Definition_p-&gt;Function.arguments_pp = NULL;</li>
<li>Definition_p-&gt;Function.arguments = 0;</li>
<li></li>
<li>++Token_p;</li>
<li></li>
<li>if (Token_p-&gt;type != NH_MAKE_TOKEN_ROUND_BRACKET_LEFT) {</li>
<li>NH_MAKE_END(Token_p)</li>
<li>}</li>
<li></li>
<li>Definition_p-&gt;Function.arguments_pp = malloc(sizeof(NH_BYTE*));</li>
<li>NH_MAKE_CHECK_NULL(NULL, Definition_p-&gt;Function.arguments_pp)</li>
<li></li>
<li>Definition_p-&gt;Function.argumentTypes_p = malloc(sizeof(NH_MAKE_TOKEN));</li>
<li>NH_MAKE_CHECK_NULL(NULL, Definition_p-&gt;Function.argumentTypes_p)</li>
<li></li>
<li>while (Token_p-&gt;type != NH_MAKE_TOKEN_ROUND_BRACKET_RIGHT)</li>
<li>{</li>
<li>switch (Token_p-&gt;type)</li>
<li>{</li>
<li>case NH_MAKE_TOKEN_IDENTIFIER :</li>
<li>case NH_MAKE_TOKEN_STRING :</li>
<li>Definition_p-&gt;Function.argumentTypes_p[Definition_p-&gt;Function.arguments] = Token_p-&gt;type;</li>
<li>Definition_p-&gt;Function.arguments_pp[Definition_p-&gt;Function.arguments++] = Token_p-&gt;string_p;</li>
<li>Definition_p-&gt;Function.arguments_pp = realloc(Definition_p-&gt;Function.arguments_pp, sizeof(NH_BYTE*) * (Definition_p-&gt;Function.arguments + 1));</li>
<li>Definition_p-&gt;Function.argumentTypes_p = realloc(Definition_p-&gt;Function.argumentTypes_p, sizeof(NH_MAKE_TOKEN) * (Definition_p-&gt;Function.arguments + 1));</li>
<li>break;</li>
<li>}</li>
<li>++Token_p;</li>
<li>}</li>
<li>+NH_MAKE_END(++Token_p) +}</li>
<li>+static nh_make_Token *nh_make_parseBlock(</li>
<li>nh_make_Token *Token_p, nh_make_Definition *Definition_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>Definition_p-&gt;type = NH_MAKE_DEFINITION_BLOCK;</li>
<li>Definition_p-&gt;Block.Definitions_p = NULL;</li>
<li>Definition_p-&gt;Block.definitions = 0;</li>
<li></li>
<li>if (Token_p-&gt;type == NH_MAKE_TOKEN_CURLY_BRACKET_RIGHT) {</li>
<li>NH_MAKE_END(Token_p)</li>
<li>}</li>
<li></li>
<li>Definition_p-&gt;Block.Definitions_p = malloc(sizeof(nh_make_Definition));</li>
<li>NH_MAKE_CHECK_NULL(NULL, Definition_p-&gt;Block.Definitions_p)</li>
<li></li>
<li>while (Token_p-&gt;type != NH_MAKE_TOKEN_CURLY_BRACKET_RIGHT) {</li>
<li>Token_p = nh_make_parseToken(Token_p, &amp;Definition_p-&gt;Block.Definitions_p[Definition_p-&gt;Block.definitions++]);</li>
<li>Definition_p-&gt;Block.Definitions_p = realloc(Definition_p-&gt;Block.Definitions_p, sizeof(nh_make_Definition) * (Definition_p-&gt;Block.definitions + 1));</li>
<li>}</li>
<li>+NH_MAKE_END(Token_p) +}</li>
<li>+static nh_make_Token *nh_make_parseOption(</li>
<li>nh_make_Token *Token_p, nh_make_Definition *Definition_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>Definition_p-&gt;type = NH_MAKE_DEFINITION_OPTION;</li>
<li></li>
<li>nh_make_Token *Description_p = Token_p-&gt;type == NH_MAKE_TOKEN_STRING ? Token_p : NULL;</li>
<li>NH_MAKE_BOOL longOption = NH_MAKE_FALSE;</li>
<li></li>
<li>if (Token_p-&gt;type == NH_MAKE_TOKEN_STRING) {</li>
<li>if (Token_p[2].type == NH_MAKE_TOKEN_HYPHEN_MINUS) {</li>
<li>longOption = NH_MAKE_TRUE;</li>
<li>Token_p = Token_p + 3;</li>
<li>}</li>
<li>else {Token_p = Token_p + 2;}</li>
<li>}</li>
<li>else {</li>
<li>if (Token_p[1].type == NH_MAKE_TOKEN_HYPHEN_MINUS) {</li>
<li>longOption = NH_MAKE_TRUE;</li>
<li>Token_p = Token_p + 2;</li>
<li>}</li>
<li>else {Token_p = Token_p + 1;}</li>
<li>}</li>
<li></li>
<li>Definition_p-&gt;Option.arguments = 0;</li>
<li>Definition_p-&gt;Option.arguments_pp = NULL;</li>
<li>Definition_p-&gt;Option.longOption = longOption;</li>
<li>Definition_p-&gt;Option.name_p = Token_p-&gt;string_p;</li>
<li>Definition_p-&gt;Option.description_p = Description_p ? Description_p-&gt;string_p : NULL;</li>
<li>Definition_p-&gt;Option.Block_p = malloc(sizeof(nh_make_Block));</li>
<li>NH_MAKE_CHECK_NULL(NULL, Definition_p-&gt;Option.Block_p)</li>
<li></li>
<li>++Token_p;</li>
<li></li>
<li>nh_make_Token *Argument_p = Token_p;</li>
<li>int arguments = 0;</li>
<li>while (Argument_p-&gt;type == NH_MAKE_TOKEN_IDENTIFIER || Argument_p-&gt;type == NH_MAKE_TOKEN_STRING) {</li>
<li>arguments++;</li>
<li>Argument_p++;</li>
<li>}</li>
<li></li>
<li>if (arguments) {</li>
<li>Definition_p-&gt;Option.arguments = arguments;</li>
<li>Definition_p-&gt;Option.arguments_pp = malloc(sizeof(NH_BYTE*) * arguments);</li>
<li>NH_MAKE_CHECK_NULL(NULL, Definition_p-&gt;Option.arguments_pp)</li>
<li>for (int i = 0; i &amp;lt arguments; ++i) {</li>
<li>Definition_p-&gt;Option.arguments_pp[i] = Token_p-&gt;string_p;</li>
<li>Token_p++;</li>
<li>}</li>
<li>}</li>
<li></li>
<li>if (Token_p-&gt;type != NH_MAKE_TOKEN_CURLY_BRACKET_LEFT) {</li>
<li>NH_MAKE_END(Token_p)</li>
<li>}</li>
<li>+NH_MAKE_END(nh_make_parseBlock(++Token_p, Definition_p-&gt;Option.Block_p)) +}</li>
<li>+static nh_make_Token *nh_make_parseIf(</li>
<li>nh_make_Token *Token_p, nh_make_Definition *Definition_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>Definition_p-&gt;type = NH_MAKE_DEFINITION_IF;</li>
<li>Definition_p-&gt;If.string_p = Token_p-&gt;string_p;</li>
<li>Definition_p-&gt;If.Block_p = malloc(sizeof(nh_make_Definition));</li>
<li>NH_MAKE_CHECK_NULL(NULL, Definition_p-&gt;If.Block_p)</li>
<li></li>
<li>++Token_p;</li>
<li></li>
<li>if (Token_p-&gt;type != NH_MAKE_TOKEN_CURLY_BRACKET_LEFT) {</li>
<li>NH_MAKE_END(Token_p)</li>
<li>}</li>
<li>+NH_MAKE_END(nh_make_parseBlock(++Token_p, Definition_p-&gt;If.Block_p)) +}</li>
<li>+static nh_make_Token *nh_make_parseToken(</li>
<li>nh_make_Token *Token_p, nh_make_Definition *Definition_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>Definition_p-&gt;type = NH_MAKE_DEFINITION_UNDEFINED;</li>
<li></li>
<li>switch (Token_p-&gt;type)</li>
<li>{</li>
<li>case NH_MAKE_TOKEN_CURLY_BRACKET_RIGHT :</li>
<li>case NH_MAKE_TOKEN_CURLY_BRACKET_LEFT :</li>
<li>case NH_MAKE_TOKEN_ROUND_BRACKET_RIGHT :</li>
<li>case NH_MAKE_TOKEN_ROUND_BRACKET_LEFT :</li>
<li>case NH_MAKE_TOKEN_ANGLE_BRACKET_RIGHT :</li>
<li>case NH_MAKE_TOKEN_ANGLE_BRACKET_LEFT :</li>
<li>case NH_MAKE_TOKEN_COMMA :</li>
<li>break;</li>
<li></li>
<li>case NH_MAKE_TOKEN_STRING :</li>
<li>if (Token_p[1].type == NH_MAKE_TOKEN_HYPHEN_MINUS) {</li>
<li>NH_MAKE_END(nh_make_parseOption(Token_p, Definition_p))</li>
<li>}</li>
<li>break;</li>
<li></li>
<li>case NH_MAKE_TOKEN_IDENTIFIER :</li>
<li>switch((Token_p+1)-&gt;type) {</li>
<li>case NH_MAKE_TOKEN_CURLY_BRACKET_LEFT :</li>
<li>NH_MAKE_END(nh_make_parseIf(Token_p, Definition_p))</li>
<li>case NH_MAKE_TOKEN_ROUND_BRACKET_LEFT :</li>
<li>NH_MAKE_END(nh_make_parseFunction(Token_p, Definition_p))</li>
<li>}</li>
<li>break;</li>
<li></li>
<li>case NH_MAKE_TOKEN_HYPHEN_MINUS :</li>
<li>NH_MAKE_END(nh_make_parseOption(Token_p, Definition_p))</li>
<li>break;</li>
<li>}</li>
<li>+NH_MAKE_END(++Token_p) +}</li>
<li>+static NH_MAKE_RESULT nh_make_parseFile(</li>
<li>nh_make_Parser *Parser_p, nh_make_File *File_p) +{ +NH_MAKE_BEGIN()</li>
<li>+#include NH_MAKE_DEFAULT_CHECK</li>
<li></li>
<li>nh_make_Tokenizer Tokenizer = nh_make_initTokenizer();</li>
<li>NH_MAKE_CHECK(nh_make_tokenizeFile(&amp;Tokenizer, File_p))</li>
<li></li>
<li>nh_make_Token *Token_p = Tokenizer.Tokens_p;</li>
<li></li>
<li>Parser_p-&gt;definitions = 0;</li>
<li>Parser_p-&gt;Definitions_p = malloc(sizeof(nh_make_Definition));</li>
<li>NH_MAKE_CHECK_NULL(Parser_p-&gt;Definitions_p)</li>
<li></li>
<li>while (Token_p-&gt;type != NH_MAKE_TOKEN_EOF) {</li>
<li>Token_p = nh_make_parseToken(Token_p, &amp;Parser_p-&gt;Definitions_p[Parser_p-&gt;definitions]);</li>
<li>if (Parser_p-&gt;Definitions_p[Parser_p-&gt;definitions].type != NH_MAKE_DEFINITION_UNDEFINED) {</li>
<li>Parser_p-&gt;definitions++;</li>
<li>Parser_p-&gt;Definitions_p = realloc(Parser_p-&gt;Definitions_p, sizeof(nh_make_Definition) * (Parser_p-&gt;definitions + 1));</li>
<li>}</li>
<li>}</li>
<li>+#include NH_MAKE_CUSTOM_CHECK</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+// SHOW ============================================================================================</li>
<li>+static void nh_make_showParserDefinition(</li>
<li>nh_make_Definition *Definition_p, unsigned int depth) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>NH_BYTE depth_p[255];</li>
<li>memset(depth_p, 0, 255);</li>
<li></li>
<li>for (int i = 0; i &amp;lt (depth * 2); ++i) {depth_p[i] = ' ';}</li>
<li></li>
<li>switch (Definition_p-&gt;type)</li>
<li>{</li>
<li>case NH_MAKE_DEFINITION_IF :</li>
<li>nh_make_messagef("%s%s", depth_p, Definition_p-&gt;If.string_p);</li>
<li>nh_make_messagef("%s{", depth_p);</li>
<li>for (int j = 0; j &amp;lt Definition_p-&gt;If.Block_p-&gt;Block.definitions; ++j) {</li>
<li>nh_make_showParserDefinition(&amp;Definition_p-&gt;If.Block_p-&gt;Block.Definitions_p[j], depth + 1);</li>
<li>}</li>
<li>nh_make_messagef("%s}", depth_p);</li>
<li>break;</li>
<li></li>
<li>case NH_MAKE_DEFINITION_FUNCTION :</li>
<li>nh_make_messagef("%s%s", depth_p, Definition_p-&gt;Function.name_p);</li>
<li>for (int j = 0; j &amp;lt Definition_p-&gt;Function.arguments; ++j) {</li>
<li>nh_make_messagef("%s  %s", depth_p, Definition_p-&gt;Function.arguments_pp[j]);</li>
<li>}</li>
<li>break;</li>
<li></li>
<li>case NH_MAKE_DEFINITION_BLOCK :</li>
<li>nh_make_messagef("%s{", depth_p);</li>
<li>for (int j = 0; j &amp;lt Definition_p-&gt;Block.definitions; ++j) {</li>
<li>nh_make_showParserDefinition(&amp;Definition_p-&gt;Block.Definitions_p[j], depth + 1);</li>
<li>}</li>
<li>nh_make_messagef("%s}", depth_p);</li>
<li>break;</li>
<li></li>
<li>case NH_MAKE_DEFINITION_OPTION :</li>
<li>if (Definition_p-&gt;Option.longOption) {</li>
<li>nh_make_messagef("%s--%s", depth_p, Definition_p-&gt;Option.name_p);</li>
<li>}</li>
<li>else {</li>
<li>nh_make_messagef("%s-%s", depth_p, Definition_p-&gt;Option.name_p);</li>
<li>}</li>
<li>if (Definition_p-&gt;Option.description_p) {</li>
<li>nh_make_messagef("%s  description: %s", depth_p, Definition_p-&gt;Option.description_p);</li>
<li>}</li>
<li>for (int i = 0; i &amp;lt Definition_p-&gt;Option.arguments; ++i) {</li>
<li>nh_make_messagef("%s  argument %d: %s", depth_p, i, Definition_p-&gt;Option.arguments_pp[i]);</li>
<li>}</li>
<li>nh_make_showParserDefinition(Definition_p-&gt;Option.Block_p, depth + 1);</li>
<li>break;</li>
<li>}</li>
<li>+NH_MAKE_SILENT_END() +}</li>
<li>+static void nh_make_showParseTree(</li>
<li>nh_make_Parser *Parser_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>nh_make_operationf("Show Parse-Tree");</li>
<li></li>
<li>for (int i = 0; i &amp;lt Parser_p-&gt;definitions; ++i) {</li>
<li>nh_make_showParserDefinition(&amp;Parser_p-&gt;Definitions_p[i], 0);</li>
<li>}</li>
<li>+NH_MAKE_SILENT_END() +}</li>
<li>+// PARSER ARRAY ====================================================================================</li>
<li>+void nh_make_initParserArray(</li>
<li>nh_make_ParserArray *Array_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>Array_p-&gt;length = 0;</li>
<li>Array_p-&gt;Parsers_p = NULL;</li>
<li>+NH_MAKE_SILENT_END() +}</li>
<li>+static nh_make_Parser nh_make_initParser() +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>nh_make_Parser Parser;</li>
<li>Parser.executed = NH_MAKE_FALSE;</li>
<li>Parser.Definitions_p = NULL;</li>
<li>Parser.definitions = 0;</li>
<li>+NH_MAKE_END(Parser) +}</li>
<li>+NH_MAKE_RESULT nh_make_appendParser(</li>
<li>nh_make_ParserArray *Array_p, nh_make_File *File_p, NH_MAKE_BOOL showParseTree) +{ +NH_MAKE_BEGIN()</li>
<li>+#include NH_MAKE_DEFAULT_CHECK</li>
<li></li>
<li>if (!Array_p-&gt;Parsers_p) {</li>
<li>Array_p-&gt;Parsers_p = malloc(sizeof(nh_make_Parser));</li>
<li>NH_MAKE_CHECK_NULL(Array_p-&gt;Parsers_p)</li>
<li>}</li>
<li>else {</li>
<li>Array_p-&gt;Parsers_p = realloc(Array_p-&gt;Parsers_p, sizeof(nh_make_Parser) * (Array_p-&gt;length + 1));</li>
<li>NH_MAKE_CHECK_NULL(Array_p-&gt;Parsers_p)</li>
<li>}</li>
<li></li>
<li>nh_make_Parser *Parser_p = &amp;Array_p-&gt;Parsers_p[Array_p-&gt;length];</li>
<li></li>
<li>*Parser_p = nh_make_initParser();</li>
<li>NH_MAKE_CHECK(nh_make_parseFile(Parser_p, File_p))</li>
<li></li>
<li>if (showParseTree) {</li>
<li>nh_make_showParseTree(Parser_p);</li>
<li>}</li>
<li></li>
<li>Array_p-&gt;length++;</li>
<li>+#include NH_MAKE_CUSTOM_CHECK</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>diff --git a/src/lib/nhmake/Parser/Parser.h b/src/lib/nhmake/Parser/Parser.h new file mode 100644 index 0000000..84c75c1 --- /dev/null +++ b/src/lib/nhmake/Parser/Parser.h @ -0,0 +1,84 @ +#ifndef NH_MAKE_PARSER_H +#define NH_MAKE_PARSER_H</li>
<li>+#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>+/**</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>+#include "Tokenizer.h"</li>
<li>+#include "../Common/Types/Private.h"</li>
<li>+#include "../Core/File.h"</li>
<li>+#endif</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>typedef union nh_make_Definition nh_make_Definition;</li>
<li></li>
<li>typedef struct nh_make_Block {</li>
<li>NH_MAKE_DEFINITION type;</li>
<li>unsigned int definitions;</li>
<li>nh_make_Definition *Definitions_p;</li>
<li>} nh_make_Block;</li>
<li></li>
<li>typedef struct nh_make_Option {</li>
<li>NH_MAKE_DEFINITION type;</li>
<li>NH_MAKE_BOOL longOption;</li>
<li>int arguments;</li>
<li>NH_BYTE **arguments_pp;</li>
<li>NH_BYTE *name_p;</li>
<li>NH_BYTE *description_p;</li>
<li>nh_make_Definition *Block_p;</li>
<li>} nh_make_Option;</li>
<li></li>
<li>typedef struct nh_make_If {</li>
<li>NH_MAKE_DEFINITION type;</li>
<li>NH_BYTE *string_p;</li>
<li>nh_make_Definition *Block_p;</li>
<li>} nh_make_If;</li>
<li></li>
<li>typedef union nh_make_Definition {</li>
<li>NH_MAKE_DEFINITION type;</li>
<li>nh_make_Option Option;</li>
<li>nh_make_Function Function;</li>
<li>nh_make_Block Block;</li>
<li>nh_make_If If;</li>
<li>} nh_make_Definition;</li>
<li></li>
<li>typedef struct nh_make_Parser {</li>
<li>NH_MAKE_BOOL executed;</li>
<li>NH_MAKE_BOOL expectExpression;</li>
<li>unsigned int definitions;</li>
<li>nh_make_Definition *Definitions_p;</li>
<li>} nh_make_Parser;</li>
<li></li>
<li>typedef struct nh_make_ParserArray {</li>
<li>int length;</li>
<li>nh_make_Parser *Parsers_p;</li>
<li>} nh_make_ParserArray;</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li>+#endif diff --git a/src/lib/nhmake/Parser/Tokenizer.c b/src/lib/nhmake/Parser/Tokenizer.c new file mode 100644 index 0000000..21df61a --- /dev/null +++ b/src/lib/nhmake/Parser/Tokenizer.c @ -0,0 +1,230 @ +// LICENSE NOTICE ==================================================================================</li>
<li>+/**</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>+// INCLUDE =========================================================================================</li>
<li>+#include "Tokenizer.h"</li>
<li>+#include "../Core/Utils.h" +#include "../Common/Macros/Macros.h" +#include NH_MAKE_FLOW +#include NH_MAKE_DEFAULT_CHECK</li>
<li>+#include &amp;ltstdio.h&gt; +#include &amp;ltstdlib.h&gt; +#include &amp;ltstring.h&gt; +#include &amp;ltunistd.h&gt; +#include &amp;ltctype.h&gt;</li>
<li>+// HELPER ==========================================================================================</li>
<li>+static NH_MAKE_BOOL nh_make_isASCIIUpperAlpha(</li>
<li>NH_BYTE codepoint) +{ +NH_MAKE_BEGIN() +NH_MAKE_END(codepoint &gt;= 0x41 &amp;&amp; codepoint &amp;lt= 0x5A) +}</li>
<li>+static NH_MAKE_BOOL nh_make_isASCIILowerAlpha(</li>
<li>NH_BYTE codepoint) +{ +NH_MAKE_BEGIN() +NH_MAKE_END(codepoint &gt;= 0x61 &amp;&amp; codepoint &amp;lt= 0x7A) +}</li>
<li>+static NH_MAKE_BOOL nh_make_isASCIIAlpha(</li>
<li>NH_BYTE codepoint) +{ +NH_MAKE_BEGIN() +NH_MAKE_END(nh_make_isASCIIUpperAlpha(codepoint) || nh_make_isASCIILowerAlpha(codepoint)) +}</li>
<li>+static NH_MAKE_BOOL nh_make_isBracket(</li>
<li>NH_BYTE codepoint) +{ +NH_MAKE_BEGIN() +NH_MAKE_END(codepoint == '(' || codepoint == ')' || codepoint == '{' || codepoint == '}' || codepoint == '[' || codepoint == ']') +}</li>
<li>+static NH_MAKE_BOOL nh_make_isTokenBegin(</li>
<li>NH_BYTE codepoint) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>if (nh_make_isASCIIAlpha(codepoint) || nh_make_isBracket(codepoint)</li>
<li>|| codepoint == ','</li>
<li>|| codepoint == '"'</li>
<li>|| codepoint == ':'</li>
<li>|| codepoint == '-')</li>
<li></li>
<li>{NH_MAKE_END(NH_MAKE_TRUE)}</li>
<li>+NH_MAKE_END(NH_MAKE_FALSE) +}</li>
<li>+// TOKENIZE ========================================================================================</li>
<li>+static NH_BYTE *nh_make_tokenizeString(</li>
<li>nh_make_Token *Token_p, NH_BYTE *bytes_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>NH_BYTE *string_p = malloc(1);</li>
<li>unsigned int stringLength = 0;</li>
<li></li>
<li>NH_BYTE *stringBegin_p = bytes_p;</li>
<li></li>
<li>NH_MAKE_BOOL escape = NH_MAKE_FALSE;</li>
<li>while (*bytes_p &amp;&amp; (*bytes_p != '"' || escape)) {</li>
<li>escape = escape ? NH_MAKE_FALSE : *bytes_p == 0x5C;</li>
<li>if (!escape) {</li>
<li>string_p = realloc(string_p, stringLength + 1);</li>
<li>string_p[stringLength++] = *bytes_p;</li>
<li>}</li>
<li>bytes_p++;</li>
<li>}</li>
<li>if (!*bytes_p) {NH_MAKE_END(NULL)}</li>
<li></li>
<li>*bytes_p = 0;</li>
<li></li>
<li>string_p = realloc(string_p, stringLength + 1);</li>
<li>string_p[stringLength] = 0;</li>
<li></li>
<li>Token_p-&gt;string_p = string_p;</li>
<li></li>
<li>*bytes_p = '"';</li>
<li>+NH_MAKE_END(&amp;bytes_p[1]) +}</li>
<li>+static NH_BYTE *nh_make_getToken(</li>
<li>nh_make_Token *Token_p, NH_BYTE *bytes_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>if (!*bytes_p) {NH_MAKE_END(NULL)}</li>
<li></li>
<li>Token_p-&gt;type = NH_MAKE_TOKEN_UNDEFINED;</li>
<li>Token_p-&gt;string_p = NULL;</li>
<li></li>
<li>while (*bytes_p &amp;&amp; !nh_make_isTokenBegin(*bytes_p)) {</li>
<li>if (bytes_p[0] == '/' &amp;&amp; bytes_p[1] == '/') {</li>
<li>while (*bytes_p &amp;&amp; *bytes_p != '<br  />
') {bytes_p++;}</li>
<li>}</li>
<li>bytes_p++;</li>
<li>}</li>
<li>if (!*bytes_p) {NH_MAKE_END(NULL)}</li>
<li></li>
<li>NH_BYTE *tokenBegin_p = bytes_p;</li>
<li></li>
<li>switch (*tokenBegin_p)</li>
<li>{</li>
<li>case '(' : Token_p-&gt;type = NH_MAKE_TOKEN_ROUND_BRACKET_LEFT; break;</li>
<li>case ')' : Token_p-&gt;type = NH_MAKE_TOKEN_ROUND_BRACKET_RIGHT; break;</li>
<li>case '{' : Token_p-&gt;type = NH_MAKE_TOKEN_CURLY_BRACKET_LEFT; break;</li>
<li>case '}' : Token_p-&gt;type = NH_MAKE_TOKEN_CURLY_BRACKET_RIGHT; break;</li>
<li>case '[' : Token_p-&gt;type = NH_MAKE_TOKEN_ANGLE_BRACKET_LEFT; break;</li>
<li>case ']' : Token_p-&gt;type = NH_MAKE_TOKEN_ANGLE_BRACKET_RIGHT; break;</li>
<li>case '-' : Token_p-&gt;type = NH_MAKE_TOKEN_HYPHEN_MINUS; break;</li>
<li>case ',' : Token_p-&gt;type = NH_MAKE_TOKEN_COMMA; break;</li>
<li>case ':' : Token_p-&gt;type = NH_MAKE_TOKEN_COLON; break;</li>
<li>case '"' :</li>
<li>Token_p-&gt;type = NH_MAKE_TOKEN_STRING;</li>
<li>NH_MAKE_END(nh_make_tokenizeString(Token_p, &amp;bytes_p[1]))</li>
<li>break;</li>
<li>}</li>
<li></li>
<li>if (Token_p-&gt;type != NH_MAKE_TOKEN_UNDEFINED) {</li>
<li>NH_MAKE_END(&amp;bytes_p[1])</li>
<li>}</li>
<li></li>
<li>while (*bytes_p &amp;&amp; (nh_make_isASCIIAlpha(*bytes_p) || *bytes_p == '_')) {bytes_p++;}</li>
<li>if (!*bytes_p) {NH_MAKE_END(NULL)}</li>
<li></li>
<li>NH_BYTE tmp = *bytes_p;</li>
<li>*bytes_p = 0;</li>
<li></li>
<li>Token_p-&gt;type = NH_MAKE_TOKEN_IDENTIFIER;</li>
<li>Token_p-&gt;string_p = malloc(strlen(tokenBegin_p) + 1);</li>
<li>strcpy(Token_p-&gt;string_p, tokenBegin_p);</li>
<li></li>
<li>*bytes_p = tmp;</li>
<li>+NH_MAKE_END(bytes_p) +}</li>
<li>+static void nh_make_getTokens(</li>
<li>nh_make_Token *Tokens_p, NH_BYTE *bytes_p, unsigned int *tokens_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>unsigned int tokens = 0;</li>
<li></li>
<li>while (bytes_p)</li>
<li>{</li>
<li>nh_make_Token Token;</li>
<li>bytes_p = nh_make_getToken(&amp;Token, bytes_p);</li>
<li>if (Tokens_p) {Tokens_p[tokens] = Token;}</li>
<li>tokens++;</li>
<li>}</li>
<li></li>
<li>if (Tokens_p) {</li>
<li>Tokens_p[tokens - 1].type = NH_MAKE_TOKEN_EOF;</li>
<li>}</li>
<li></li>
<li>if (tokens_p) {*tokens_p = tokens;}</li>
<li>+NH_MAKE_SILENT_END() +}</li>
<li>+NH_MAKE_RESULT nh_make_tokenizeFile(</li>
<li>nh_make_Tokenizer *Tokenizer_p, nh_make_File *File_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>NH_BYTE *bytes_p = malloc(strlen(File_p-&gt;data_p) + 1);</li>
<li>NH_MAKE_CHECK_NULL(bytes_p)</li>
<li>strcpy(bytes_p, File_p-&gt;data_p);</li>
<li></li>
<li>unsigned int tokens = 0;</li>
<li>nh_make_getTokens(NULL, bytes_p, &amp;tokens);</li>
<li></li>
<li>free(bytes_p);</li>
<li>bytes_p = NULL;</li>
<li></li>
<li>bytes_p = malloc(strlen(File_p-&gt;data_p) + 1);</li>
<li>NH_MAKE_CHECK_NULL(bytes_p)</li>
<li>strcpy(bytes_p, File_p-&gt;data_p);</li>
<li></li>
<li>nh_make_Token *Tokens_p = malloc(sizeof(nh_make_Token) * tokens);</li>
<li>for (int i = 0; i &amp;lt tokens; ++i) {</li>
<li>Tokens_p[i].string_p = NULL;</li>
<li>}</li>
<li>nh_make_getTokens(Tokens_p, bytes_p, NULL);</li>
<li></li>
<li>free(bytes_p);</li>
<li></li>
<li>Tokenizer_p-&gt;tokens = tokens;</li>
<li>Tokenizer_p-&gt;Tokens_p = Tokens_p;</li>
<li>+NH_MAKE_END(NH_MAKE_SUCCESS) +}</li>
<li>+// INIT ============================================================================================</li>
<li>+nh_make_Tokenizer nh_make_initTokenizer() +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>nh_make_Tokenizer Tokenizer;</li>
<li>Tokenizer.tokens = 0;</li>
<li>Tokenizer.Tokens_p = NULL;</li>
<li>+NH_MAKE_END(Tokenizer) +}</li>
<li>diff --git a/src/lib/nhmake/Parser/Tokenizer.h b/src/lib/nhmake/Parser/Tokenizer.h new file mode 100644 index 0000000..573f740 --- /dev/null +++ b/src/lib/nhmake/Parser/Tokenizer.h @ -0,0 +1,47 @ +#ifndef NH_MAKE_TOKENIZER_H +#define NH_MAKE_TOKENIZER_H</li>
<li>+#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>+/**</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>+#include "../Common/Types/Private.h"</li>
<li>+#include "../Core/File.h"</li>
<li>+#endif</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>typedef struct nh_make_Token {</li>
<li>NH_MAKE_TOKEN type;</li>
<li>NH_BYTE *string_p;</li>
<li>} nh_make_Token;</li>
<li></li>
<li>typedef struct nh_make_Tokenizer {</li>
<li>unsigned int tokens;</li>
<li>nh_make_Token *Tokens_p;</li>
<li>} nh_make_Tokenizer;</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li><p class="startli">+#endif diff --git a/external/selfmake/src/lib/Parser/Variables.c b/src/lib/nhmake/Parser/Variables.c similarity index 50% rename from external/selfmake/src/lib/Parser/Variables.c rename to src/lib/nhmake/Parser/Variables.c index e232160..613f6b3 100644 --- a/external/selfmake/src/lib/Parser/Variables.c +++ b/src/lib/nhmake/Parser/Variables.c @ -1,8 +1,8 @ // LICENSE NOTICE ==================================================================================</p>
<p class="startli">/**</p>
</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors<ul>
<li>Published under MIT */</li>
</ul>
</li>
</ul>
<p >@ -12,8 +12,8 @ #include "Tokenizer.h"</p>
<p >#include "../Common/Macros/Macros.h" -#include SM_FLOW -#include SM_CUSTOM_CHECK +#include NH_MAKE_FLOW +#include NH_MAKE_CUSTOM_CHECK</p>
<p >#include &amp;ltstdio.h&gt; #include &amp;ltstdlib.h&gt; @ -23,102 +23,102 @</p>
<p >// INIT ============================================================================================</p>
<p >-void sm_initVariableArray(</p><ul>
<li>sm_VariableArray *Array_p) +void nh_make_initVariableArray(</li>
<li><p class="startli">nh_make_VariableArray *Array_p) { -SM_BEGIN() +NH_MAKE_BEGIN()</p>
<p class="startli">Array_p-&gt;length = 0; Array_p-&gt;Variables_p = NULL;</p>
</li>
</ul>
<p >-SM_SILENT_END() +NH_MAKE_SILENT_END() }</p>
<p >// UPDATE ==========================================================================================</p>
<p >-sm_Variable *sm_getVariable(</p><ul>
<li>sm_VariableArray *Array_p, SM_BYTE *name_p) +nh_make_Variable *nh_make_getVariable(</li>
<li><p class="startli">nh_make_VariableArray *Array_p, NH_BYTE *name_p) { -SM_BEGIN() +NH_MAKE_BEGIN()</p>
<p class="startli">for (int i = 0; i &amp;lt Array_p-&gt;length; ++i) { if (!strcmp(name_p, Array_p-&gt;Variables_p[i].name_p)) {</p>
</li>
<li>SM_END(&amp;Array_p-&gt;Variables_p[i])</li>
<li>NH_MAKE_END(&amp;Array_p-&gt;Variables_p[i]) } }</li>
</ul>
<p >-SM_END(NULL) +NH_MAKE_END(NULL) }</p>
<p >-static sm_Variable *sm_createVariable(</p><ul>
<li>sm_VariableArray *Array_p, SM_BYTE *name_p) +static nh_make_Variable *nh_make_createVariable(</li>
<li><p class="startli">nh_make_VariableArray *Array_p, NH_BYTE *name_p) { -SM_BEGIN() +NH_MAKE_BEGIN()</p>
<p class="startli">if (!Array_p-&gt;Variables_p) {</p>
</li>
<li>Array_p-&gt;Variables_p = malloc(sizeof(sm_Variable));</li>
<li>SM_CHECK_NULL(NULL, Array_p-&gt;Variables_p)</li>
<li>Array_p-&gt;Variables_p = malloc(sizeof(nh_make_Variable));</li>
<li>NH_MAKE_CHECK_NULL(NULL, Array_p-&gt;Variables_p) } else {</li>
<li>Array_p-&gt;Variables_p = realloc(Array_p-&gt;Variables_p, sizeof(sm_Variable) * (Array_p-&gt;length + 1));</li>
<li>SM_CHECK_NULL(NULL, Array_p-&gt;Variables_p)</li>
<li>Array_p-&gt;Variables_p = realloc(Array_p-&gt;Variables_p, sizeof(nh_make_Variable) * (Array_p-&gt;length + 1));</li>
<li>NH_MAKE_CHECK_NULL(NULL, Array_p-&gt;Variables_p) }</li>
<li>sm_Variable *Variable_p = &amp;Array_p-&gt;Variables_p[Array_p-&gt;length];</li>
<li><p class="startli">nh_make_Variable *Variable_p = &amp;Array_p-&gt;Variables_p[Array_p-&gt;length];</p>
<p class="startli">Variable_p-&gt;values_pp = NULL; Variable_p-&gt;valueCount = 0;</p>
<p class="startli">Variable_p-&gt;name_p = malloc(strlen(name_p) + 1);</p>
</li>
<li>SM_CHECK_NULL(NULL, Variable_p-&gt;name_p)</li>
<li><p class="startli">NH_MAKE_CHECK_NULL(NULL, Variable_p-&gt;name_p) sprintf(Variable_p-&gt;name_p, name_p);</p>
<p class="startli">Array_p-&gt;length++;</p>
</li>
</ul>
<p >-SM_END(Variable_p) +NH_MAKE_END(Variable_p) }</p>
<p >-SM_RESULT sm_appendToVariable(</p><ul>
<li>sm_VariableArray *Array_p, SM_BYTE *variable_p, SM_BYTE **values_pp, int valueCount) +NH_MAKE_RESULT nh_make_appendToVariable(</li>
<li>nh_make_VariableArray *Array_p, NH_BYTE *variable_p, NH_BYTE **values_pp, int valueCount) { -SM_BEGIN() +NH_MAKE_BEGIN()</li>
</ul>
<p >-#include SM_DEFAULT_CHECK +#include NH_MAKE_DEFAULT_CHECK</p>
<ul>
<li>sm_Variable *Variable_p = sm_getVariable(Array_p, variable_p);</li>
<li>nh_make_Variable *Variable_p = nh_make_getVariable(Array_p, variable_p); if (!Variable_p) {</li>
<li>Variable_p = sm_createVariable(Array_p, variable_p);</li>
<li>Variable_p = nh_make_createVariable(Array_p, variable_p); }</li>
<li>SM_CHECK_NULL(Variable_p)</li>
<li>NH_MAKE_CHECK_NULL(Variable_p)</li>
<li>Variable_p-&gt;values_pp = realloc(Variable_p-&gt;values_pp, sizeof(SM_BYTE*) * (Variable_p-&gt;valueCount + valueCount));</li>
<li>SM_CHECK_NULL(Variable_p-&gt;values_pp)</li>
<li>Variable_p-&gt;values_pp = realloc(Variable_p-&gt;values_pp, sizeof(NH_BYTE*) * (Variable_p-&gt;valueCount + valueCount));</li>
<li><p class="startli">NH_MAKE_CHECK_NULL(Variable_p-&gt;values_pp)</p>
<p class="startli">for (int i = Variable_p-&gt;valueCount, j = 0; i &amp;lt valueCount + Variable_p-&gt;valueCount; ++i, ++j) { Variable_p-&gt;values_pp[i] = malloc(strlen(values_pp[j]) + 1);</p>
</li>
<li>SM_CHECK_NULL(Variable_p-&gt;values_pp[i])</li>
<li><p class="startli">NH_MAKE_CHECK_NULL(Variable_p-&gt;values_pp[i]) sprintf(Variable_p-&gt;values_pp[i], values_pp[j]); }</p>
<p class="startli">Variable_p-&gt;valueCount += valueCount;</p>
</li>
</ul>
<p >-#include SM_CUSTOM_CHECK +#include NH_MAKE_CUSTOM_CHECK</p>
<p >-SM_END(SM_SUCCESS) +NH_MAKE_END(NH_MAKE_SUCCESS) }</p>
<p >-SM_RESULT sm_updateVariable(</p><ul>
<li>sm_VariableArray *Array_p, SM_BYTE *variable_p, SM_BYTE **values_pp, int valueCount) +NH_MAKE_RESULT nh_make_updateVariable(</li>
<li>nh_make_VariableArray *Array_p, NH_BYTE *variable_p, NH_BYTE **values_pp, int valueCount) { -SM_BEGIN() +NH_MAKE_BEGIN()</li>
</ul>
<p >-#include SM_DEFAULT_CHECK +#include NH_MAKE_DEFAULT_CHECK</p>
<ul>
<li>sm_Variable *Variable_p = sm_getVariable(Array_p, variable_p);</li>
<li>nh_make_Variable *Variable_p = nh_make_getVariable(Array_p, variable_p); if (!Variable_p) {</li>
<li>Variable_p = sm_createVariable(Array_p, variable_p);</li>
<li>Variable_p = nh_make_createVariable(Array_p, variable_p); }</li>
<li>SM_CHECK_NULL(Variable_p)</li>
<li><p class="startli">NH_MAKE_CHECK_NULL(Variable_p)</p>
<p class="startli">if (Variable_p-&gt;values_pp) { for (int i = 0; i &amp;lt Variable_p-&gt;valueCount; ++i) { @ -127,12 +127,12 @ SM_BEGIN() free(Variable_p-&gt;values_pp); }</p>
</li>
<li>Variable_p-&gt;values_pp = malloc(sizeof(SM_BYTE*) * valueCount);</li>
<li>SM_CHECK_NULL(Variable_p-&gt;values_pp)</li>
<li>Variable_p-&gt;values_pp = malloc(sizeof(NH_BYTE*) * valueCount);</li>
<li><p class="startli">NH_MAKE_CHECK_NULL(Variable_p-&gt;values_pp)</p>
<p class="startli">for (int i = 0; i &amp;lt valueCount; ++i) { Variable_p-&gt;values_pp[i] = malloc(strlen(values_pp[i]) + 1);</p>
</li>
<li>SM_CHECK_NULL(Variable_p-&gt;values_pp[i])</li>
<li>NH_MAKE_CHECK_NULL(Variable_p-&gt;values_pp[i]) sprintf(Variable_p-&gt;values_pp[i], values_pp[i]); }</li>
</ul>
<p >@ -142,19 +142,19 @ SM_BEGIN() chdir(Variable_p-&gt;values_pp[0]); }</p>
<p >-#include SM_CUSTOM_CHECK +#include NH_MAKE_CUSTOM_CHECK</p>
<p >-SM_END(SM_SUCCESS) +NH_MAKE_END(NH_MAKE_SUCCESS) }</p>
<p >// REPLACE =========================================================================================</p>
<p >-static SM_BYTE *sm_substituteVariableCallsInString(</p><ul>
<li>sm_VariableArray *Array_p, SM_BYTE *string_p) +static NH_BYTE *nh_make_substituteVariableCallsInString(</li>
<li>nh_make_VariableArray *Array_p, NH_BYTE *string_p) { -SM_BEGIN() +NH_MAKE_BEGIN()</li>
<li>SM_BYTE *begin_p = NULL;</li>
<li><p class="startli">NH_BYTE *begin_p = NULL;</p>
<p class="startli">for (int i = 0; i &amp;lt strlen(string_p); ++i) { if (string_p[i] == '$' &amp;&amp; i + 1 &amp;lt strlen(string_p) &amp;&amp; string_p[i + 1] == '{') { @ -165,18 +165,18 @ SM_BEGIN()</p>
<p class="startli">if (begin_p) {</p>
</li>
<li>SM_BYTE *end_p = begin_p;</li>
<li><p class="startli">NH_BYTE *end_p = begin_p; while (*end_p != '}') {++end_p;} *end_p = 0;</p>
<p class="startli">int nameLength = strlen(begin_p + 2);</p>
</li>
<li>sm_Variable *Var_p = sm_getVariable(Array_p, begin_p + 2);</li>
<li>nh_make_Variable *Var_p = nh_make_getVariable(Array_p, begin_p + 2); *end_p = '}';</li>
<li>if (!Var_p) {SM_END(string_p)}</li>
<li>if (!Var_p) {NH_MAKE_END(string_p)}</li>
<li>SM_BYTE *newString_p = malloc((strlen(string_p) - strlen(Var_p-&gt;name_p) - 3) + strlen(Var_p-&gt;values_pp[0]) + 1);</li>
<li>SM_CHECK_NULL(NULL, newString_p)</li>
<li>NH_BYTE *newString_p = malloc((strlen(string_p) - strlen(Var_p-&gt;name_p) - 3) + strlen(Var_p-&gt;values_pp[0]) + 1);</li>
<li><p class="startli">NH_MAKE_CHECK_NULL(NULL, newString_p)</p>
<p class="startli">*end_p = 0; *begin_p = 0; @ -186,22 +186,22 @ SM_BEGIN() sprintf(newString_p + strlen(newString_p), end_p + 1);</p>
<p class="startli">free(string_p);</p>
</li>
<li>SM_END(sm_substituteVariableCallsInString(Array_p, newString_p))</li>
<li>NH_MAKE_END(nh_make_substituteVariableCallsInString(Array_p, newString_p)) }</li>
</ul>
<p >-SM_END(string_p) +NH_MAKE_END(string_p) }</p>
<p >-SM_BYTE *sm_substituteVariables(</p><ul>
<li>sm_VariableArray *Array_p, SM_BYTE *string_p) +NH_BYTE *nh_make_substituteVariables(</li>
<li>nh_make_VariableArray *Array_p, NH_BYTE *string_p) { -SM_BEGIN() +NH_MAKE_BEGIN()</li>
<li>SM_BYTE *newString_p = malloc(strlen(string_p) + 1);</li>
<li>SM_CHECK_NULL(NULL, newString_p)</li>
<li>NH_BYTE *newString_p = malloc(strlen(string_p) + 1);</li>
<li><p class="startli">NH_MAKE_CHECK_NULL(NULL, newString_p)</p>
<p class="startli">sprintf(newString_p, string_p);</p>
</li>
</ul>
<p >-SM_END(sm_substituteVariableCallsInString(Array_p, newString_p)) +NH_MAKE_END(nh_make_substituteVariableCallsInString(Array_p, newString_p)) }</p>
<p >diff --git a/src/lib/nhmake/Parser/Variables.h b/src/lib/nhmake/Parser/Variables.h new file mode 100644 index 0000000..f43deef --- /dev/null +++ b/src/lib/nhmake/Parser/Variables.h @ -0,0 +1,59 @ +#ifndef NH_MAKE_VARIABLES_H +#define NH_MAKE_VARIABLES_H</p><ul>
<li>+#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>+/**</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>+#include "../Common/Types/Private.h"</li>
<li>+#endif</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>typedef struct nh_make_Variable {</li>
<li>NH_BYTE *name_p;</li>
<li>int valueCount;</li>
<li>NH_BYTE **values_pp;</li>
<li>} nh_make_Variable;</li>
<li></li>
<li>typedef struct nh_make_VariableArray {</li>
<li>int length;</li>
<li>nh_make_Variable *Variables_p;</li>
<li>} nh_make_VariableArray;</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li>+#endif diff --git a/src/lib/nhmake/Test/Process.c b/src/lib/nhmake/Test/Process.c new file mode 100644 index 0000000..8aedee4 --- /dev/null +++ b/src/lib/nhmake/Test/Process.c @ -0,0 +1,157 @ +// LICENSE NOTICE ==================================================================================</li>
<li>+/**</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>+// INCLUDE =========================================================================================</li>
<li>+#include "Process.h" +#include "Channel.h"</li>
<li>+#include "../Common/Macros/Macros.h" +#include NH_MAKE_FLOW +#include NH_MAKE_DEFAULT_CHECK</li>
<li>+#include &amp;ltstdlib.h&gt; +#include &amp;ltstdio.h&gt; +#include &amp;ltunistd.h&gt; +#include &amp;lterrno.h&gt; +#include &amp;ltstring.h&gt;</li>
<li>+#if defined(__linux__) || defined(__APPLE__)</li>
<li>#include &amp;ltsys/wait.h&gt;</li>
<li>#include &amp;ltsignal.h&gt; +#endif</li>
<li>+// FORK ============================================================================================</li>
<li>+static nh_make_Process nh_make_initProcess() +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>nh_make_Process Process;</li>
<li>Process.id = 0;</li>
<li></li>
<li>nh_make_initChannel(&amp;Process.IPC.In);</li>
<li>nh_make_initChannel(&amp;Process.IPC.Out);</li>
<li>+NH_MAKE_END(Process) +}</li>
<li>+nh_make_Process nh_make_fork() +{ +NH_MAKE_BEGIN()</li>
<li>+#include NH_MAKE_CUSTOM_CHECK</li>
<li></li>
<li>nh_make_Process Fork = nh_make_initProcess();</li>
<li></li>
<li>nh_make_openChannel(&amp;Fork.IPC.In);</li>
<li>nh_make_openChannel(&amp;Fork.IPC.Out);</li>
<li></li>
<li>Fork.id = fork();</li>
<li></li>
<li>if (Fork.id == 0) { // child</li>
<li>nh_make_closeChannelWriteAccess(&amp;Fork.IPC.In);</li>
<li>nh_make_closeChannelReadAccess(&amp;Fork.IPC.Out);</li>
<li>NH_MAKE_END(Fork)</li>
<li>}</li>
<li></li>
<li>nh_make_closeChannelReadAccess(&amp;Fork.IPC.In);</li>
<li>nh_make_closeChannelWriteAccess(&amp;Fork.IPC.Out);</li>
<li>+#include NH_MAKE_DEFAULT_CHECK</li>
<li>+NH_MAKE_END(Fork) +}</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>+// TODO ============================================================================</li>
<li>+static NH_MAKE_RESULT nh_make_unregisterFork(</li>
<li>nh_make_Process *Fork_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>if (Fork_p-&gt;id == 0) {NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_BAD_STATE)}</li>
<li></li>
<li>nh_make_closeChannelWriteAccess(&amp;Fork_p-&gt;IPC.In);</li>
<li>nh_make_closeChannelReadAccess(&amp;Fork_p-&gt;IPC.Out);</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+void nh_make_checkForks() +{ +NH_MAKE_BEGIN()</li>
<li>+// if (init == NH_MAKE_FALSE) {NH_MAKE_SILENT_END()} +// +// for (int i = 0; i &amp;lt NH_MAKE_MAX_FORKS; ++i) { +// nh_make_Process *Proc_p = &amp;NH_MAKE_PROCESS_POOL.Forks_p[i]; +// if (Proc_p-&gt;id != 0) { +// int status; +//#if defined(__linux__) || defined(__APPLE__) +// int result = waitpid(Proc_p-&gt;id, &amp;status, WNOHANG); +// if (result == -1) { +// printf("nh_make_checkForks %s\n", strerror(errno)); +// } +// if (result == -1 || WIFEXITED(status)) { +// nh_make_unregisterFork(&amp;NH_MAKE_PROCESS_POOL.Forks_p[i]); +// } +//#endif +// } +// }</li>
<li>+NH_MAKE_SILENT_END() +}</li>
<li>+void nh_make_killFork(</li>
<li>nh_make_Process *Fork_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>kill(Fork_p-&gt;id, SIGTERM);</li>
<li>nh_make_unregisterFork(Fork_p);</li>
<li>+NH_MAKE_SILENT_END() +}</li>
<li>+// WRITE ===========================================================================================</li>
<li>+NH_BYTE *_nh_make_writeToProcess(</li>
<li>nh_make_Process *Proc_p, NH_BYTE *write_p, int writeLen, NH_MAKE_BOOL getResponse) +{</li>
<li>nh_make_writeToChannel(&amp;Proc_p-&gt;IPC.In, write_p, writeLen);</li>
<li></li>
<li>while (getResponse)</li>
<li>{</li>
<li>NH_BYTE *response_p = nh_make_readFromChannel(&amp;Proc_p-&gt;IPC.Out, NULL);</li>
<li>if (response_p != NULL) {</li>
<li>return response_p;</li>
<li>}</li>
<li>}</li>
<li></li>
<li>return NULL; +}</li>
<li>+NH_BYTE *nh_make_writeToProcess(</li>
<li>nh_make_Process *Proc_p, NH_BYTE *write_p, int writeLen, NH_MAKE_BOOL getResponse) +{ +NH_MAKE_BEGIN() +NH_MAKE_END(_nh_make_writeToProcess(Proc_p, write_p, writeLen, getResponse)) +}</li>
<li>diff --git a/src/lib/nhmake/Test/Process.h b/src/lib/nhmake/Test/Process.h new file mode 100644 index 0000000..675cc3b --- /dev/null +++ b/src/lib/nhmake/Test/Process.h @ -0,0 +1,49 @ +#ifndef NH_MAKE_PROCESS_H +#define NH_MAKE_PROCESS_H</li>
<li>+#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>+/**</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>+#include "Channel.h"</li>
<li>+#include "../Common/Types/Private.h"</li>
<li>+#include &amp;ltsys/types.h&gt;</li>
<li>+#endif</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li>+#if defined(__unix__) || defined(__APPLE__)</li>
<li>typedef pid_t NH_MAKE_PROCESS; +#endif</li>
<li></li>
<li>typedef struct nh_make_ProcessIPC {</li>
<li>nh_make_Channel In;</li>
<li>nh_make_Channel Out;</li>
<li>} nh_make_ProcessIPC;</li>
<li></li>
<li>typedef struct nh_make_Process {</li>
<li>NH_MAKE_PROCESS id;</li>
<li>nh_make_ProcessIPC IPC;</li>
<li>} nh_make_Process;</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li>+#endif diff --git a/src/lib/nhmake/Test/Test.c b/src/lib/nhmake/Test/Test.c new file mode 100644 index 0000000..c46bea0 --- /dev/null +++ b/src/lib/nhmake/Test/Test.c @ -0,0 +1,315 @ +// LICENSE NOTICE ==================================================================================</li>
<li>+/**</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>+// INCLUDE =========================================================================================</li>
<li>+#include "Test.h" +#include "Channel.h" +#include "Process.h" +#include "Library.h"</li>
<li>+#include "../Core/Runtime.h" +#include "../Parser/Variables.h"</li>
<li>+#include "../Common/Macros/Macros.h" +#include NH_MAKE_FLOW +#include NH_MAKE_DEFAULT_CHECK</li>
<li>+#include &amp;ltstdlib.h&gt; +#include &amp;ltstdio.h&gt; +#include &amp;ltunistd.h&gt; +#include &amp;lterrno.h&gt; +#include &amp;ltstring.h&gt;</li>
<li>+#if defined(__linux__) || defined(__APPLE__)</li>
<li>#include &amp;ltsys/wait.h&gt; +#endif</li>
<li>+// TEST ============================================================================================</li>
<li>+typedef int (*nh_make_initializer_f)(); +typedef void *(*nh_make_customLoader_f)(NH_BYTE *libraryName_p, NH_BYTE *functionName_p); +typedef int (*nh_make_test_f)(int arguments, nh_make_TestArgument *Arguments_p, NH_BYTE *output_p, int maxOutputLength);</li>
<li>+static NH_MAKE_RESULT nh_make_runTests(</li>
<li>nh_make_TestEnvironment *TestEnvironment_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>void *initLib_p = NULL;</li>
<li>void *loadLib_p = NULL;</li>
<li></li>
<li>if (TestEnvironment_p-&gt;Initializer_p)</li>
<li>{</li>
<li>initLib_p = nh_make_openLibrary(TestEnvironment_p-&gt;Initializer_p-&gt;libraryName_p);</li>
<li>NH_MAKE_CHECK_NULL(initLib_p)</li>
<li></li>
<li>nh_make_initializer_f initializer_f = nh_make_loadSymbol(initLib_p, TestEnvironment_p-&gt;Initializer_p-&gt;functionName_p);</li>
<li>NH_MAKE_CHECK_NULL(initializer_f)</li>
<li></li>
<li>// run custom initializer</li>
<li>if (initializer_f()) {NH_MAKE_END(NH_MAKE_ERROR_BAD_STATE)}</li>
<li>}</li>
<li></li>
<li>nh_make_customLoader_f customLoader_f = NULL;</li>
<li></li>
<li>if (TestEnvironment_p-&gt;Loader_p)</li>
<li>{</li>
<li>loadLib_p = nh_make_openLibrary(TestEnvironment_p-&gt;Loader_p-&gt;libraryName_p);</li>
<li>NH_MAKE_CHECK_NULL(loadLib_p)</li>
<li></li>
<li>customLoader_f = nh_make_loadSymbol(loadLib_p, TestEnvironment_p-&gt;Loader_p-&gt;functionName_p);</li>
<li>NH_MAKE_CHECK_NULL(customLoader_f)</li>
<li>}</li>
<li></li>
<li>NH_MAKE_BOOL match = NH_MAKE_FALSE;</li>
<li></li>
<li>for (int i = 0; i &amp;lt TestEnvironment_p-&gt;TestArray_p-&gt;length; ++i)</li>
<li>{</li>
<li>nh_make_Test *Test_p = &amp;TestEnvironment_p-&gt;TestArray_p-&gt;Tests_p[i];</li>
<li>nh_make_test_f test_f = NULL;</li>
<li></li>
<li>if (strcmp(Test_p-&gt;Context_p-&gt;name_p, TestEnvironment_p-&gt;target_p)) {continue;}</li>
<li></li>
<li>if (customLoader_f) {</li>
<li>test_f = customLoader_f(Test_p-&gt;Context_p-&gt;name_p, Test_p-&gt;name_p);</li>
<li>}</li>
<li>else {</li>
<li>Test_p-&gt;dl_p = nh_make_openLibrary(Test_p-&gt;Context_p-&gt;name_p);</li>
<li>NH_MAKE_CHECK_NULL(Test_p-&gt;dl_p)</li>
<li>test_f = nh_make_loadSymbol(Test_p-&gt;dl_p, Test_p-&gt;name_p);</li>
<li>}</li>
<li></li>
<li>NH_MAKE_CHECK_NULL(test_f)</li>
<li></li>
<li>NH_BYTE result_p[1024];</li>
<li>memset(result_p, 0, 1024);</li>
<li></li>
<li>// perform the test</li>
<li>int result = test_f(Test_p-&gt;arguments, Test_p-&gt;Arguments_p, result_p, 1024);</li>
<li></li>
<li>nh_make_messagef("%d: %s", result, result_p);</li>
<li></li>
<li>match = NH_MAKE_TRUE;</li>
<li>}</li>
<li></li>
<li>if (match) {</li>
<li>nh_make_messagef("");</li>
<li>}</li>
<li>+NH_MAKE_END(NH_MAKE_SUCCESS) +}</li>
<li>+static nh_make_TestEnvironment nh_make_initializeTestEnvironment(</li>
<li>nh_make_Runtime *Runtime_p, nh_make_ExternalFunction *Initializer_p, nh_make_ExternalFunction *Loader_p,</li>
<li>NH_BYTE *target_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>nh_make_TestEnvironment TestEnvironment;</li>
<li>TestEnvironment.target_p = target_p;</li>
<li></li>
<li>nh_make_Variable *InitLibrary_p = nh_make_getVariable(&amp;Runtime_p-&gt;VariableArray, "TEST_INITIALIZER_SOURCE");</li>
<li>nh_make_Variable *InitFunction_p = nh_make_getVariable(&amp;Runtime_p-&gt;VariableArray, "TEST_INITIALIZER");</li>
<li></li>
<li>if (InitLibrary_p &amp;&amp; InitFunction_p) {</li>
<li>Initializer_p-&gt;libraryName_p = InitLibrary_p-&gt;values_pp[0];</li>
<li>Initializer_p-&gt;functionName_p = InitFunction_p-&gt;values_pp[0];</li>
<li>TestEnvironment.Initializer_p = Initializer_p;</li>
<li>}</li>
<li>else {TestEnvironment.Initializer_p = NULL;}</li>
<li></li>
<li>nh_make_Variable *LoadLibrary_p = nh_make_getVariable(&amp;Runtime_p-&gt;VariableArray, "TEST_LOADER_SOURCE");</li>
<li>nh_make_Variable *LoadFunction_p = nh_make_getVariable(&amp;Runtime_p-&gt;VariableArray, "TEST_LOADER");</li>
<li></li>
<li>if (LoadLibrary_p &amp;&amp; LoadFunction_p) {</li>
<li>Loader_p-&gt;libraryName_p = LoadLibrary_p-&gt;values_pp[0];</li>
<li>Loader_p-&gt;functionName_p = LoadFunction_p-&gt;values_pp[0];</li>
<li>TestEnvironment.Loader_p = Loader_p;</li>
<li>}</li>
<li>else {TestEnvironment.Loader_p = NULL;}</li>
<li>+NH_MAKE_END(TestEnvironment) +}</li>
<li>+static NH_MAKE_RESULT nh_make_runTestEnvironment(</li>
<li>nh_make_TestEnvironment *TestEnvironment_p, nh_make_TestArray *TestArray_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>TestEnvironment_p-&gt;Process = nh_make_fork();</li>
<li>TestEnvironment_p-&gt;TestArray_p = TestArray_p;</li>
<li></li>
<li>if (TestEnvironment_p-&gt;Process.id == 0) {</li>
<li>exit(nh_make_runTests(TestEnvironment_p));</li>
<li>}</li>
<li></li>
<li>pid_t w;</li>
<li>int wstatus;</li>
<li></li>
<li>do {</li>
<li>w = waitpid(TestEnvironment_p-&gt;Process.id, &amp;wstatus, WUNTRACED | WCONTINUED);</li>
<li>if (w == -1) {</li>
<li>perror("waitpid");</li>
<li>exit(EXIT_FAILURE);</li>
<li>} +// if (WIFEXITED(wstatus)) { +// printf("exited, status=%d\n", WEXITSTATUS(wstatus)); +// } else if (WIFSIGNALED(wstatus)) { +// printf("killed by signal %d\n", WTERMSIG(wstatus)); +// } else if (WIFSTOPPED(wstatus)) { +// printf("stopped by signal %d\n", WSTOPSIG(wstatus)); +// } else if (WIFCONTINUED(wstatus)) { +// printf("continued\n"); +// }</li>
<li>} while (!WIFEXITED(wstatus) &amp;&amp; !WIFSIGNALED(wstatus));</li>
<li>+NH_MAKE_END(NH_MAKE_SUCCESS) +}</li>
<li>+NH_MAKE_RESULT nh_make_test(</li>
<li>nh_make_Runtime *Runtime_p, NH_BYTE *name_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>nh_make_ExternalFunction Initializer;</li>
<li>nh_make_ExternalFunction Loader;</li>
<li></li>
<li>nh_make_TestEnvironment TestEnvironment =</li>
<li>nh_make_initializeTestEnvironment(Runtime_p, &amp;Initializer, &amp;Loader, name_p);</li>
<li></li>
<li>NH_MAKE_CHECK(nh_make_runTestEnvironment(&amp;TestEnvironment, &amp;Runtime_p-&gt;TestArray))</li>
<li>+NH_MAKE_END(NH_MAKE_SUCCESS) +}</li>
<li>+//NH_BYTE *nh_make_getTestResult( +// nh_make_Process *Fork_p) +//{ +//NH_MAKE_BEGIN() +// +// if (Fork_p-&gt;id != 0) { +// NH_BYTE *receive_p = nh_make_readFromChannel(&amp;Fork_p-&gt;IPC.Out, NULL); +// if (receive_p != NULL) { +// NH_MAKE_CHECK(nh_make_handleIPCReceive(receive_p)) +// } +//// TODO free? +// } +// +//NH_MAKE_END(NH_MAKE_SIGNAL_OK) +//} +// +//NH_MAKE_RESULT nh_make_destroyTestEnvironment( +// nh_make_TestEnvironment *TestEnvironment_p) +//{ +//NH_MAKE_BEGIN() +// +//NH_MAKE_END(NH_MAKE_SUCCESS) +//}</li>
<li></li>
<li>+// TEST ARRAY ======================================================================================</li>
<li>+void nh_make_initTestArray(</li>
<li>nh_make_TestArray *Array_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>Array_p-&gt;length = 0;</li>
<li>Array_p-&gt;Tests_p = NULL;</li>
<li>+NH_MAKE_SILENT_END() +}</li>
<li>+static nh_make_Test nh_make_initTest() +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>nh_make_Test Test;</li>
<li>Test.Context_p = NULL;</li>
<li>Test.name_p = NULL;</li>
<li>Test.dl_p = NULL;</li>
<li>Test.arguments = 0;</li>
<li>Test.Arguments_p = NULL;</li>
<li>+NH_MAKE_END(Test) +}</li>
<li>+NH_MAKE_RESULT nh_make_addTest(</li>
<li>nh_make_SourceContextArray *ContextArray_p, nh_make_TestArray *TestArray_p, nh_make_Function *Function_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>nh_make_SourceContext *Context_p = NULL;</li>
<li>nh_make_Test *Test_p = NULL;</li>
<li></li>
<li>for (int i = 0; i &amp;lt Function_p-&gt;arguments; ++i)</li>
<li>{</li>
<li>if (Function_p-&gt;argumentTypes_p[i] == NH_MAKE_TOKEN_IDENTIFIER) {</li>
<li>for (int j = 0; j &amp;lt ContextArray_p-&gt;length; ++j) {</li>
<li>if (!strcmp(ContextArray_p-&gt;SourceContexts_p[j].name_p, Function_p-&gt;arguments_pp[i])) {</li>
<li>Context_p = &amp;ContextArray_p-&gt;SourceContexts_p[j];</li>
<li>}</li>
<li>}</li>
<li>}</li>
<li>else {</li>
<li></li>
<li>if (!Context_p) {</li>
<li>NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_BAD_STATE)</li>
<li>}</li>
<li></li>
<li>if (!Test_p)</li>
<li>{</li>
<li>if (!TestArray_p-&gt;Tests_p) {</li>
<li>TestArray_p-&gt;Tests_p = malloc(sizeof(nh_make_Test));</li>
<li>NH_MAKE_CHECK_NULL(TestArray_p-&gt;Tests_p)</li>
<li>}</li>
<li>else {</li>
<li>TestArray_p-&gt;Tests_p = realloc(TestArray_p-&gt;Tests_p, sizeof(nh_make_Test) * (TestArray_p-&gt;length + 1));</li>
<li>NH_MAKE_CHECK_NULL(TestArray_p-&gt;Tests_p)</li>
<li>}</li>
<li></li>
<li>Test_p = &amp;TestArray_p-&gt;Tests_p[TestArray_p-&gt;length];</li>
<li>*Test_p = nh_make_initTest();</li>
<li></li>
<li>Test_p-&gt;Context_p = Context_p;</li>
<li>Test_p-&gt;name_p = malloc(strlen(Function_p-&gt;arguments_pp[i]) + 1);</li>
<li>NH_MAKE_CHECK_NULL(Test_p-&gt;name_p)</li>
<li>sprintf(Test_p-&gt;name_p, Function_p-&gt;arguments_pp[i]);</li>
<li></li>
<li>TestArray_p-&gt;length++;</li>
<li></li>
<li>NH_BYTE offset_p[64];</li>
<li>nh_make_getIndentAfterSourceContext(Context_p-&gt;name_p, offset_p, 64, ContextArray_p);</li>
<li>nh_make_messagef("[%s]%s Add test \"%s\"", Context_p-&gt;name_p, offset_p, Test_p-&gt;name_p);</li>
<li>}</li>
<li>else</li>
<li>{</li>
<li>if (!Test_p-&gt;Arguments_p) {</li>
<li>Test_p-&gt;Arguments_p = malloc(sizeof(nh_make_TestArgument));</li>
<li>NH_MAKE_CHECK_NULL(Test_p-&gt;Arguments_p)</li>
<li>}</li>
<li>else {</li>
<li>Test_p-&gt;Arguments_p = realloc(Test_p-&gt;Arguments_p, sizeof(nh_make_TestArgument) * (Test_p-&gt;arguments + 1));</li>
<li>NH_MAKE_CHECK_NULL(Test_p-&gt;Arguments_p)</li>
<li>}</li>
<li></li>
<li>nh_make_TestArgument *TestArgument_p = &amp;Test_p-&gt;Arguments_p[Test_p-&gt;arguments];</li>
<li></li>
<li>TestArgument_p-&gt;p = malloc(strlen(Function_p-&gt;arguments_pp[i]) + 1);</li>
<li>NH_MAKE_CHECK_NULL(TestArgument_p-&gt;p)</li>
<li>sprintf(TestArgument_p-&gt;p, Function_p-&gt;arguments_pp[i]);</li>
<li></li>
<li>Test_p-&gt;arguments++;</li>
<li>}</li>
<li>}</li>
<li>}</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>diff --git a/src/lib/nhmake/Test/Test.h b/src/lib/nhmake/Test/Test.h new file mode 100644 index 0000000..456e9c6 --- /dev/null +++ b/src/lib/nhmake/Test/Test.h @ -0,0 +1,68 @ +#ifndef NH_MAKE_TEST_H +#define NH_MAKE_TEST_H</li>
<li>+#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>+/**</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>+#include "Process.h"</li>
<li>+#include "../Common/Types/Private.h"</li>
<li>+#endif</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>typedef struct nh_make_ExternalFunction {</li>
<li>NH_BYTE *libraryName_p;</li>
<li>NH_BYTE *functionName_p;</li>
<li>} nh_make_ExternalFunction;</li>
<li></li>
<li>typedef struct nh_make_Test {</li>
<li>nh_make_SourceContext *Context_p;</li>
<li>NH_BYTE *name_p;</li>
<li>void *dl_p;</li>
<li>int arguments;</li>
<li>nh_make_TestArgument *Arguments_p;</li>
<li>} nh_make_Test;</li>
<li></li>
<li>typedef struct nh_make_TestArray {</li>
<li>int length;</li>
<li>nh_make_Test *Tests_p;</li>
<li>} nh_make_TestArray;</li>
<li></li>
<li>typedef struct nh_make_TestEnvironment {</li>
<li>nh_make_Process Process;</li>
<li>nh_make_ExternalFunction *Initializer_p;</li>
<li>nh_make_ExternalFunction *Loader_p;</li>
<li>nh_make_TestArray *TestArray_p;</li>
<li>NH_BYTE *target_p;</li>
<li>} nh_make_TestEnvironment;</li>
<li>+/**<ul>
<li>*/</li>
</ul>
</li>
<li>typedef struct sm_X11 {</li>
<li><p class="startli">typedef struct nh_make_X11 {</p>
<p class="startli">#ifdef __unix__ int screen; @ -45,37 +45,37 @ int width, height; #endif</p>
</li>
<li>} sm_X11;</li>
<li><p class="startli">} nh_make_X11;</p>
<p class="startli">/** </p>
</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
  <!-- HTML footer for doxygen 1.8.15-->
  <!-- start footer part -->
  <div id="nav-path" class="navpath">
    <!--  -->
    <!-- <li class="footer">Generated by -->
    <!-- <a href="http://www.doxygen.org/index.html"> -->
    <!-- <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li> -->
    <div id="foot"> 
      <div style="color:#24bbc4;text-align:center;margin:auto;font-size:16px;">
        <b>
<!-- NH_MAKE_INSERT_STAGE_BEGIN -->
prototype.1
<!-- NH_MAKE_INSERT_STAGE_END -->
-
<!-- NH_MAKE_INSERT_API_VERSION_BEGIN -->
ver.0.2.3.0
<!-- NH_MAKE_INSERT_API_VERSION_END -->
-
<!-- NH_MAKE_INSERT_REVISION_BEGIN -->
rev.08400
<!-- NH_MAKE_INSERT_REVISION_END -->
          </b>
        </div>
      </div>
    </div>
  </body>
  <style>
    #foot {display: flex; padding-top:13px; padding-bottom:14px; background: #151515; border-top: 3px solid #24bbc4; justify-content: space-between;}
  </style>
</html>
