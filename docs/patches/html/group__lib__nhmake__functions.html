<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.9.2"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Netzhaut | Web Browser Engine | Patches</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="resize.js"></script>
    <script type="text/javascript" src="navtreedata.js"></script>
    <script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/searchdata.js"></script>
    <script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript">
    /* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
      $(document).ready(function() { init_search(); });
    /* @license-end */
    </script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link rel="icon" href="../../logo/favicon.png">
    <link href="../../theme/custom.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>  
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
       <div style="height: 56px;">
        <div style="left:10px;top:5px;position:absolute;">
          <b>Netzhaut</b>
          <br>
          <b>Web Browser Engine</b>
        </div>
        <div style="height:56px;right:10px;top:0px;position:absolute;background-color:#151515;"><a href="https://netzwerkz.org"><img alt="netzwerkz logo" style="height:56px;" src="../../logo/netzwerkz.png"/></a></div>
        <div id="projectlogo"><img alt="netzhaut logo" src="../../logo/netzhaut.png"/></div>
       </div>
      </div>
      <div id="titlearea">
        <div class="topnav">
          <a href="../../index.html">Home</a>
          <a href="../../guides/html/index.html">Guides</a>
          <a href="../../general/html/index.html">General</a>
          <a href="../../architecture/html/index.html">Architecture</a>
          <a href="../../design/html/index.html">Design</a>
          <a href="../../internals/html/index.html">Internals</a>
          <a href="../../api/html/index.html">API</a>
          <a href="../../changelogs/html/index.html">Changelogs</a>
          <a class="active" href="../../patches/html/index.html">Patches</a>
        </div>
       </div>
      </div>
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__lib__nhmake__functions.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Functions</div></div>
</div><!--header-->
<div class="contents">
<ul>
<li><p class="startli">* */ -/**</p>
<p class="startli">*/</p>
</li>
<li>+#endif</li>
<li>diff --git a/src/lib/nhmake/Core/Binaries.c b/src/lib/nhmake/Core/Binaries.c new file mode 100644 index 0000000..b543fea --- /dev/null +++ b/src/lib/nhmake/Core/Binaries.c @ -0,0 +1,151 @ +// LICENSE NOTICE ==================================================================================</li>
<li>+/**</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>+// INCLUDE =========================================================================================</li>
<li>+#include "Binaries.h" +#include "Util.h" +#include "Main.h"</li>
<li>+#include "../Common/Macro.h"</li>
<li>+#include NH_MAKE_FLOW +#include NH_MAKE_CUSTOM_CHECK</li>
<li>+#include &amp;ltstdio.h&gt; +#include &amp;ltstdlib.h&gt; +#include &amp;ltstring.h&gt; +#include &amp;ltunistd.h&gt;</li>
<li>+// BUILD BINARY ====================================================================================</li>
<li>+NH_MAKE_RESULT nh_make_buildnhterminal() +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>char projDir_p[2048] = {'\0'};</li>
<li>NH_MAKE_CHECK(NH_MAKE_ERROR_GET_PROJECT_DIRECTORY, nh_make_getProjectDir(projDir_p, 2048))</li>
<li></li>
<li>// set -no-pie because of <a href="https://stackoverflow.com/questions/41398444/gcc-creates-mime-type-application-x-sharedlib-instead-of-application-x-applicati">https://stackoverflow.com/questions/41398444/gcc-creates-mime-type-application-x-sharedlib-instead-of-application-x-applicati</a></li>
<li>static char command_p[2048] = {'\0'};</li>
<li>sprintf(command_p, "gcc -std=gnu99 -Wl,-rpath=%s/lib:/usr/local/lib -o%s/bin/nhterminal -no-pie -L%s/lib -lnetzhaut %s/src/bin/nhterminal/Terminal.c", projDir_p, projDir_p, projDir_p, projDir_p);</li>
<li></li>
<li>int status = system(command_p);</li>
<li>if (WEXITSTATUS(status) || WIFSIGNALED(status)) {NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_GCC_EXECUTION_FAILED)}</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+NH_MAKE_RESULT nh_make_buildnhwebbrowser() +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>char projDir_p[2048] = {'\0'};</li>
<li>NH_MAKE_CHECK(NH_MAKE_ERROR_GET_PROJECT_DIRECTORY, nh_make_getProjectDir(projDir_p, 2048))</li>
<li></li>
<li>// set -no-pie because of <a href="https://stackoverflow.com/questions/41398444/gcc-creates-mime-type-application-x-sharedlib-instead-of-application-x-applicati">https://stackoverflow.com/questions/41398444/gcc-creates-mime-type-application-x-sharedlib-instead-of-application-x-applicati</a></li>
<li>static char command_p[2048] = {'\0'};</li>
<li>sprintf(command_p, "gcc -std=gnu99 -Wl,-rpath=%s/lib:/usr/local/lib -o%s/bin/nhwebbrowser -no-pie -L%s/lib -lnetzhaut %s/src/bin/nhwebbrowser/WebBrowser.c", projDir_p, projDir_p, projDir_p, projDir_p);</li>
<li></li>
<li>int status = system(command_p);</li>
<li>if (WEXITSTATUS(status) || WIFSIGNALED(status)) {NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_GCC_EXECUTION_FAILED)}</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+// INSTALL BINARY ==================================================================================</li>
<li>+NH_MAKE_RESULT nh_make_installnhterminal() +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>char wrkDir_p[2048] = {'\0'};</li>
<li>NH_MAKE_CHECK_NULL(NH_MAKE_ERROR_GET_WORK_DIRECTORY, getcwd(wrkDir_p, 2048))</li>
<li></li>
<li>char projDir_p[2048] = {'\0'};</li>
<li>NH_MAKE_CHECK(NH_MAKE_ERROR_GET_PROJECT_DIRECTORY, nh_make_getProjectDir(projDir_p, 2048))</li>
<li></li>
<li>chdir(projDir_p);</li>
<li></li>
<li>const char *homedir_p = nh_make_getHomeDir();</li>
<li>char dest_p[512] = {'\0'};</li>
<li></li>
<li>sprintf(dest_p, "%s/.local/share/applications/", homedir_p);</li>
<li>NH_MAKE_CHECK(NH_MAKE_ERROR_COPY_FAILED, nh_make_copy("src/bin/nhterminal/Common/Data/nhterminal.desktop", dest_p, NH_MAKE_FALSE, NH_MAKE_FALSE))</li>
<li>NH_MAKE_CHECK(NH_MAKE_ERROR_COPY_FAILED, nh_make_copy("bin/nhterminal", "/usr/local/bin", NH_MAKE_FALSE, NH_MAKE_TRUE))</li>
<li></li>
<li>chdir(wrkDir_p);</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+NH_MAKE_RESULT nh_make_installnhwebbrowser() +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>char wrkDir_p[2048] = {'\0'};</li>
<li>NH_MAKE_CHECK_NULL(NH_MAKE_ERROR_GET_WORK_DIRECTORY, getcwd(wrkDir_p, 2048))</li>
<li></li>
<li>char projDir_p[2048] = {'\0'};</li>
<li>NH_MAKE_CHECK(NH_MAKE_ERROR_GET_PROJECT_DIRECTORY, nh_make_getProjectDir(projDir_p, 2048))</li>
<li></li>
<li>chdir(projDir_p);</li>
<li></li>
<li>const char *homedir_p = nh_make_getHomeDir();</li>
<li>char dest_p[512] = {'\0'};</li>
<li></li>
<li>sprintf(dest_p, "%s/.local/share/applications/", homedir_p);</li>
<li>NH_MAKE_CHECK(NH_MAKE_ERROR_COPY_FAILED, nh_make_copy("src/bin/nhwebbrowser/Common/Data/nhwebbrowser.desktop", dest_p, NH_MAKE_FALSE, NH_MAKE_FALSE))</li>
<li>NH_MAKE_CHECK(NH_MAKE_ERROR_COPY_FAILED, nh_make_copy("bin/nhwebbrowser", "/usr/local/bin", NH_MAKE_FALSE, NH_MAKE_TRUE))</li>
<li></li>
<li>chdir(wrkDir_p);</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+// INSTALL LOGO ====================================================================================</li>
<li>+NH_MAKE_RESULT nh_make_installLogo() +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>char wrkDir_p[2048] = {'\0'};</li>
<li>NH_MAKE_CHECK_NULL(NH_MAKE_ERROR_GET_WORK_DIRECTORY, getcwd(wrkDir_p, 2048))</li>
<li></li>
<li>char projDir_p[2048] = {'\0'};</li>
<li>NH_MAKE_CHECK(NH_MAKE_ERROR_GET_PROJECT_DIRECTORY, nh_make_getProjectDir(projDir_p, 2048))</li>
<li></li>
<li>chdir(projDir_p);</li>
<li></li>
<li>const char *homedir_p = nh_make_getHomeDir();</li>
<li>char dest_p[512] = {'\0'};</li>
<li></li>
<li>sprintf(dest_p, "%s/.local/share/icons/hicolor/32x32/apps", homedir_p);</li>
<li>NH_MAKE_CHECK(NH_MAKE_ERROR_COPY_FAILED, nh_make_copy("docs/Logo/32x32/netzhaut.png", dest_p, NH_MAKE_FALSE, NH_MAKE_TRUE))</li>
<li></li>
<li>memset(dest_p, '\0', sizeof(char) * 512);</li>
<li>sprintf(dest_p, "%s/.local/share/icons/hicolor/64x64/apps", homedir_p);</li>
<li>NH_MAKE_CHECK(NH_MAKE_ERROR_COPY_FAILED, nh_make_copy("docs/Logo/64x64/netzhaut.png", dest_p, NH_MAKE_FALSE, NH_MAKE_TRUE))</li>
<li></li>
<li>memset(dest_p, '\0', sizeof(char) * 512);</li>
<li>sprintf(dest_p, "%s/.local/share/icons/hicolor/128x128/apps", homedir_p);</li>
<li>NH_MAKE_CHECK(NH_MAKE_ERROR_COPY_FAILED, nh_make_copy("docs/Logo/128x128/netzhaut.png", dest_p, NH_MAKE_FALSE, NH_MAKE_TRUE))</li>
<li></li>
<li>memset(dest_p, '\0', sizeof(char) * 512);</li>
<li>sprintf(dest_p, "%s/.local/share/icons/hicolor/256x256/apps", homedir_p);</li>
<li>NH_MAKE_CHECK(NH_MAKE_ERROR_COPY_FAILED, nh_make_copy("docs/Logo/256x256/netzhaut.png", dest_p, NH_MAKE_FALSE, NH_MAKE_TRUE))</li>
<li></li>
<li>memset(dest_p, '\0', sizeof(char) * 512);</li>
<li>sprintf(dest_p, "%s/.local/share/icons/hicolor/512x512/apps", homedir_p);</li>
<li>NH_MAKE_CHECK(NH_MAKE_ERROR_COPY_FAILED, nh_make_copy("docs/Logo/512x512/netzhaut.png", dest_p, NH_MAKE_FALSE, NH_MAKE_TRUE))</li>
<li></li>
<li>chdir(wrkDir_p);</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>diff --git a/src/lib/nhmake/Core/Build.c b/src/lib/nhmake/Core/Build.c new file mode 100644 index 0000000..f8d34b7 --- /dev/null +++ b/src/lib/nhmake/Core/Build.c @ -0,0 +1,350 @ +// LICENSE NOTICE ==================================================================================</li>
<li>+/**</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>+// INCLUDE =========================================================================================</li>
<li>+#include "Build.h" +#include "Utils.h"</li>
<li>+#include "../UI/Message.h" +#include "../Common/Macros/Macros.h"</li>
<li>+#include NH_MAKE_FLOW +#include NH_MAKE_DEFAULT_CHECK</li>
<li>+#include &amp;ltstdio.h&gt; +#include &amp;ltstdlib.h&gt; +#include &amp;ltstring.h&gt; +#include &amp;ltunistd.h&gt; +#include &amp;ltpthread.h&gt; +#include &amp;ltdirent.h&gt; +#include &amp;lterrno.h&gt;</li>
<li>+// CREATE BINARY ===================================================================================</li>
<li>+static NH_MAKE_RESULT nh_make_createBinary(</li>
<li>nh_make_Runtime *Runtime_p, nh_make_SourceContext *SourceContext_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>chdir(SourceContext_p-&gt;path_p);</li>
<li></li>
<li>NH_BYTE binPath_p[256] = {'\0'};</li>
<li>sprintf(binPath_p, "%s/%s", nh_make_getVariable(&amp;Runtime_p-&gt;VariableArray, "BIN_DEST")-&gt;values_pp[0], SourceContext_p-&gt;name_p);</li>
<li>if (SourceContext_p-&gt;outputPath_p) {</li>
<li>sprintf(binPath_p, "%s/%s", SourceContext_p-&gt;outputPath_p, SourceContext_p-&gt;name_p);</li>
<li>}</li>
<li></li>
<li>int length = 0;</li>
<li>for (int i = 0; i &amp;lt Runtime_p-&gt;SourceArray.length; ++i) {</li>
<li>nh_make_Source *Source_p = &amp;Runtime_p-&gt;SourceArray.Sources_p[i];</li>
<li>if (Source_p-&gt;Context_p == SourceContext_p) {</li>
<li>length += strlen(Source_p-&gt;path_p) + 1;</li>
<li>}</li>
<li>}</li>
<li></li>
<li>NH_BYTE *sources_p = malloc(length + 1);</li>
<li>NH_MAKE_CHECK_NULL(sources_p)</li>
<li>memset(sources_p, 0, length + 1);</li>
<li></li>
<li>int offset = 0;</li>
<li>for (int i = 0; i &amp;lt Runtime_p-&gt;SourceArray.length; ++i) {</li>
<li>nh_make_Source *Source_p = &amp;Runtime_p-&gt;SourceArray.Sources_p[i];</li>
<li>if (Source_p-&gt;Context_p == SourceContext_p) {</li>
<li>sprintf(sources_p + strlen(sources_p), "%s ", Source_p-&gt;path_p);</li>
<li>}</li>
<li>}</li>
<li></li>
<li>int compileArgsLength = SourceContext_p-&gt;compileArgs_p ? strlen(SourceContext_p-&gt;compileArgs_p) : 0;</li>
<li>int linkArgsLength = SourceContext_p-&gt;linkArgs_p ? strlen(SourceContext_p-&gt;linkArgs_p) : 0;</li>
<li>int commandLength = strlen(sources_p) + compileArgsLength + linkArgsLength + strlen(binPath_p) + 128;</li>
<li>NH_BYTE *command_p = malloc(commandLength);</li>
<li>NH_MAKE_CHECK_NULL(command_p)</li>
<li>memset(command_p, 0, commandLength);</li>
<li></li>
<li>NH_BYTE empty = 0;</li>
<li>NH_BYTE *linkArgs_p = SourceContext_p-&gt;linkArgs_p ? SourceContext_p-&gt;linkArgs_p : &empty;</li>
<li>NH_BYTE *compileArgs_p = SourceContext_p-&gt;compileArgs_p ? SourceContext_p-&gt;compileArgs_p : &empty;</li>
<li></li>
<li>// set -no-pie because of <a href="https://stackoverflow.com/questions/41398444/gcc-creates-mime-type-application-x-sharedlib-instead-of-application-x-applicati">https://stackoverflow.com/questions/41398444/gcc-creates-mime-type-application-x-sharedlib-instead-of-application-x-applicati</a></li>
<li>sprintf(command_p, "gcc %s -o%s -no-pie %s %s", compileArgs_p, binPath_p, linkArgs_p, sources_p);</li>
<li>nh_make_messagef(command_p);</li>
<li></li>
<li>int status = system(command_p);</li>
<li>if (WEXITSTATUS(status) || WIFSIGNALED(status)) {NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_GCC_EXECUTION_FAILED)}</li>
<li></li>
<li>chdir(nh_make_getVariable(&amp;Runtime_p-&gt;VariableArray, "WRK_DIR")-&gt;values_pp[0]);</li>
<li></li>
<li>free(command_p);</li>
<li>free(sources_p);</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+// CREATE LIBRARY ==================================================================================</li>
<li>+static NH_MAKE_RESULT nh_make_createSharedLibraryUsingGCC(</li>
<li>const NH_BYTE *objects_p, const NH_BYTE *out_p, NH_BYTE *compile_p, const NH_BYTE *link_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>static NH_BYTE command_p[16384] = {'\0'};</li>
<li></li>
<li>sprintf(command_p, "gcc -shared %s %s %s -o %s", objects_p, compile_p, link_p, out_p);</li>
<li>nh_make_messagef(command_p);</li>
<li></li>
<li>int status = system(command_p);</li>
<li>if (WEXITSTATUS(status) || WIFSIGNALED(status)) {NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_GCC_EXECUTION_FAILED)}</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+static NH_MAKE_RESULT nh_make_createLibrary(</li>
<li>nh_make_Runtime *Runtime_p, nh_make_SourceContext *Context_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>NH_BYTE empty = 0;</li>
<li>NH_BYTE *libName_p = Context_p-&gt;name_p;</li>
<li>NH_BYTE *linkArgs_p = Context_p-&gt;linkArgs_p ? Context_p-&gt;linkArgs_p : &empty;</li>
<li>NH_BYTE *compileArgs_p = Context_p-&gt;compileArgs_p ? Context_p-&gt;compileArgs_p : &empty;</li>
<li></li>
<li>int api = Context_p-&gt;Version.api;</li>
<li>int major = Context_p-&gt;Version.major;</li>
<li>int minor = Context_p-&gt;Version.minor;</li>
<li>int patch = Context_p-&gt;Version.patch;</li>
<li></li>
<li>NH_BYTE tmp_p[255] = {0};</li>
<li>sprintf(tmp_p, "/tmp/%s", nh_make_getVariable(&amp;Runtime_p-&gt;VariableArray, "NAME")-&gt;values_pp[0]);</li>
<li>chdir(tmp_p);</li>
<li>+#if defined(__linux__) || defined(__APPLE__)</li>
<li></li>
<li>int index = 0;</li>
<li>NH_BYTE objects_p[16384] = {'\0'};</li>
<li></li>
<li>DIR *dir;</li>
<li>struct dirent *ent;</li>
<li></li>
<li>if ((dir = opendir(tmp_p)) != NULL)</li>
<li>{</li>
<li>while ((ent = readdir(dir)) != NULL) {</li>
<li>for (int i = 0; ent-&gt;d_name[i] != '\0' &amp;&amp; ent-&gt;d_name[0] != '.'; ++i) {</li>
<li>objects_p[index++] = ent-&gt;d_name[i];</li>
<li>}</li>
<li>objects_p[index++] = ' ';</li>
<li>}</li>
<li>closedir(dir);</li>
<li>}</li>
<li>else {NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_CANT_OPEN_DIR)}</li>
<li></li>
<li>NH_BYTE *dest_p = nh_make_getVariable(&amp;Runtime_p-&gt;VariableArray, "LIB_DEST")-&gt;values_pp[0];</li>
<li>if (Context_p-&gt;outputPath_p) {dest_p = Context_p-&gt;outputPath_p;}</li>
<li></li>
<li>NH_BYTE libPath_p[256] = {'\0'};</li>
<li>sprintf(libPath_p, "%s/lib%s.so.%d.%d.%d.%d", dest_p, libName_p, api, major, minor, patch);</li>
<li>NH_BYTE symPath1_p[256] = {'\0'};</li>
<li>sprintf(symPath1_p, "%s/lib%s.so.%d", dest_p, libName_p, api);</li>
<li>NH_BYTE symPath2_p[256] = {'\0'};</li>
<li>sprintf(symPath2_p, "%s/lib%s.so", dest_p, libName_p);</li>
<li></li>
<li>NH_MAKE_CHECK(nh_make_createSharedLibraryUsingGCC(objects_p, libPath_p, compileArgs_p, linkArgs_p))</li>
<li></li>
<li>memset(libPath_p, 0, 256);</li>
<li>sprintf(libPath_p, "lib%s.so.%d.%d.%d.%d", libName_p, api, major, minor, patch);</li>
<li>nh_make_createSymLink(libPath_p, symPath1_p, NH_MAKE_FALSE);</li>
<li>nh_make_createSymLink(libPath_p, symPath2_p, NH_MAKE_FALSE);</li>
<li>+#endif</li>
<li></li>
<li>chdir(nh_make_getVariable(&amp;Runtime_p-&gt;VariableArray, "WRK_DIR")-&gt;values_pp[0]);</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+// COMPILE =========================================================================================</li>
<li>+static void nh_make_getObjectFileName(</li>
<li>nh_make_Source *Source_p, NH_BYTE *name_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>NH_BYTE path_p[255] = {0};</li>
<li>strcpy(path_p, Source_p-&gt;path_p);</li>
<li></li>
<li>int index = strlen(path_p) - 1;</li>
<li>while (path_p[index] != '/' &amp;&amp; index) {index--;}</li>
<li></li>
<li>NH_BYTE fileName_p[255] = {0};</li>
<li>strcpy(fileName_p, index ? path_p + index + 1 : path_p);</li>
<li></li>
<li>int tmp = index ? index - 1 : 0;</li>
<li>while (path_p[tmp] != '/' &amp;&amp; tmp) {tmp--;}</li>
<li></li>
<li>if (index) {</li>
<li>path_p[index] = '\0';</li>
<li>sprintf(name_p, "%s%s.o", path_p + tmp, fileName_p);</li>
<li>}</li>
<li>else {</li>
<li>sprintf(name_p, "%s.o", fileName_p);</li>
<li>}</li>
<li>+NH_MAKE_SILENT_END() +}</li>
<li>+static NH_MAKE_RESULT nh_make_createPICObjectFileUsingGCC(</li>
<li>const NH_BYTE *in_p, const NH_BYTE *out_p, NH_BYTE *compileArgs_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>NH_BYTE realout_p[1024] = {'\0'};</li>
<li>realpath(out_p, realout_p);</li>
<li></li>
<li>NH_BYTE command_p[1024] = {'\0'};</li>
<li></li>
<li>if (compileArgs_p != NULL) {sprintf(command_p, "gcc -fPIC %s -c %s -o %s", compileArgs_p, in_p, out_p);}</li>
<li>else {sprintf(command_p, "gcc -fPIC -c %s -o %s", in_p, out_p);}</li>
<li></li>
<li>nh_make_messagef(command_p);</li>
<li></li>
<li>int status = system(command_p);</li>
<li>if (WEXITSTATUS(status) || WIFSIGNALED(status)) {NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_GCC_EXECUTION_FAILED)}</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+static NH_MAKE_RESULT nh_make_compileFiles(</li>
<li>nh_make_Runtime *Runtime_p, nh_make_SourceContext *Context_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>chdir(Context_p-&gt;path_p);</li>
<li></li>
<li>for (int i = 0; i &amp;lt Runtime_p-&gt;SourceArray.length; ++i)</li>
<li>{</li>
<li>nh_make_Source *Source_p = &amp;Runtime_p-&gt;SourceArray.Sources_p[i];</li>
<li></li>
<li>if (Source_p-&gt;Context_p == Context_p)</li>
<li>{</li>
<li>NH_BYTE tmp_p[255] = {0};</li>
<li>NH_BYTE fileName_p[255] = {0};</li>
<li>nh_make_getObjectFileName(Source_p, fileName_p);</li>
<li></li>
<li>sprintf(tmp_p, "/tmp/%s/%s", nh_make_getVariable(&amp;Runtime_p-&gt;VariableArray, "NAME")-&gt;values_pp[0], fileName_p);</li>
<li>NH_BYTE empty = 0;</li>
<li></li>
<li>if (Context_p-&gt;type == NH_MAKE_SOURCE_CONTEXT_SHARED_LIBRARY) {</li>
<li>NH_MAKE_CHECK(nh_make_createPICObjectFileUsingGCC(</li>
<li>Source_p-&gt;path_p, tmp_p, Context_p-&gt;compileArgs_p ? Context_p-&gt;compileArgs_p : &amp;empty</li>
<li>))</li>
<li>}</li>
<li>}</li>
<li>}</li>
<li></li>
<li>chdir(nh_make_getVariable(&amp;Runtime_p-&gt;VariableArray, "WRK_DIR")-&gt;values_pp[0]);</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+// INSTALL =========================================================================================</li>
<li>+//static NH_MAKE_RESULT nh_make_installLibrary( +// NH_BYTE *libName_p, int major, int minor, int patch) +//{ +//NH_MAKE_BEGIN() +// +// NH_BYTE wrkDir_p[2048] = {'\0'}; +// NH_MAKE_CHECK_NULL(NH_MAKE_ERROR_GET_WORK_DIRECTORY, getcwd(wrkDir_p, 2048)) +// +// NH_BYTE projDir_p[2048] = {'\0'}; +// NH_MAKE_CHECK(NH_MAKE_ERROR_GET_PROJECT_DIRECTORY, nh_make_getProjectDir(projDir_p, 2048)) +// +// chdir(projDir_p); +// +// NH_BYTE libPath_p[512] = {'\0'}; +// sprintf(libPath_p, "lib/lib%s.so.%d.%d.%d", libName_p, major, minor, patch); +// +// NH_MAKE_CHECK(NH_MAKE_ERROR_COPY_FAILED, nh_make_copy(libPath_p, "/usr/local/lib", NH_MAKE_FALSE, NH_MAKE_TRUE)) +// +// chdir("/usr/local/lib"); +// +// NH_BYTE cpyPath_p[256] = {'\0'}; +// sprintf(cpyPath_p, "lib%s.so.%d.%d.%d", libName_p, major, minor, patch); +// NH_BYTE symPath1_p[256] = {'\0'}; +// sprintf(symPath1_p, "lib%s.so.%d", libName_p, major); +// NH_BYTE symPath2_p[256] = {'\0'}; +// sprintf(symPath2_p, "lib%s.so", libName_p); +// +// nh_make_createSymLink(cpyPath_p, symPath1_p, NH_MAKE_TRUE); +// nh_make_createSymLink(cpyPath_p, symPath2_p, NH_MAKE_TRUE); +// +// chdir(wrkDir_p); +// +//NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +//}</li>
<li>+// BUILD ===========================================================================================</li>
<li>+static NH_MAKE_RESULT nh_make_buildSourceContext(</li>
<li>nh_make_Runtime *Runtime_p, nh_make_SourceContext *Context_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>NH_BYTE empty = 0;</li>
<li>NH_BYTE tmp_p[255];</li>
<li>sprintf(tmp_p, "/tmp/%s", nh_make_getVariable(&amp;Runtime_p-&gt;VariableArray, "NAME")-&gt;values_pp[0]);</li>
<li></li>
<li>// make sure that we start with a fresh/empty directory</li>
<li>nh_make_removeDir(tmp_p);</li>
<li>NH_MAKE_CHECK(nh_make_createDir(tmp_p))</li>
<li></li>
<li>if (Runtime_p-&gt;beforeBuildCallback_f) {</li>
<li>NH_MAKE_CHECK(Runtime_p-&gt;beforeBuildCallback_f(Runtime_p, Context_p))</li>
<li>}</li>
<li></li>
<li>if (Context_p-&gt;type == NH_MAKE_SOURCE_CONTEXT_BINARY) {</li>
<li>NH_MAKE_CHECK(nh_make_createBinary(Runtime_p, Context_p))</li>
<li>}</li>
<li>else {</li>
<li>NH_MAKE_CHECK(nh_make_compileFiles(Runtime_p, Context_p))</li>
<li>NH_MAKE_CHECK(nh_make_createLibrary(Runtime_p, Context_p))</li>
<li>}</li>
<li></li>
<li>if (Runtime_p-&gt;afterBuildCallback_f) {</li>
<li>NH_MAKE_CHECK(Runtime_p-&gt;afterBuildCallback_f(Runtime_p, Context_p))</li>
<li>}</li>
<li>+// if (install) { +// NH_MAKE_CHECK(NH_MAKE_ERROR_BAD_STATE, nh_make_installLibrary( +// Library_p-&gt;name_p, 0, 0, 0 +// )) +// }</li>
<li></li>
<li>NH_MAKE_CHECK(nh_make_removeDir(tmp_p))</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+NH_MAKE_RESULT nh_make_build(</li>
<li>nh_make_Runtime *Runtime_p, NH_BYTE *name_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>for (int i = 0; i &amp;lt Runtime_p-&gt;SourceContextArray.length; ++i) {</li>
<li>nh_make_SourceContext *SourceContext_p = &amp;Runtime_p-&gt;SourceContextArray.SourceContexts_p[i];</li>
<li>if (!strcmp(SourceContext_p-&gt;name_p, name_p)) {</li>
<li>nh_make_messagef("");</li>
<li>nh_make_messagef(SourceContext_p-&gt;type == NH_MAKE_SOURCE_CONTEXT_BINARY ? "-- BINARY --" : "-- LIBRARY --");</li>
<li>nh_make_messagef("");</li>
<li>NH_MAKE_CHECK(nh_make_buildSourceContext(Runtime_p, SourceContext_p))</li>
<li>}</li>
<li>}</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>diff --git a/src/lib/nhmake/Core/Build.h b/src/lib/nhmake/Core/Build.h new file mode 100644 index 0000000..ae3203d --- /dev/null +++ b/src/lib/nhmake/Core/Build.h @ -0,0 +1,27 @ +#ifndef NH_MAKE_BUILD_H +#define NH_MAKE_BUILD_H</li>
<li>+#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>+/**</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>+#include "../Parser/Functions.h" +#include "../Common/Types/Private.h"</li>
<li>+#endif</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_build(</li>
<li>nh_make_Runtime *Runtime_p, NH_BYTE *name_p</li>
<li>);</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>nh_make_ChangesNode *nh_make_parseChangesFile(</li>
<li>NH_BYTE *path_p</li>
<li>);</li>
<li></li>
<li>nh_make_Changes *nh_make_getChanges(</li>
<li>nh_make_ChangesNode *Root_p, int *changes_p</li>
<li>);</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>NH_MAKE_BOOL nh_make_canFindSharedLib(</li>
<li>const NH_BYTE *lib_p</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_copy(</li>
<li>nh_make_VariableArray *Array_p, NH_BYTE *in_p, NH_BYTE *out_p, NH_MAKE_BOOL recursive, NH_MAKE_BOOL sudo</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_createSymLink(</li>
<li>NH_BYTE *filePath_p, NH_BYTE *symLinkPath_p, NH_MAKE_BOOL sudo</li>
<li>);</li>
<li></li>
<li>NH_MAKE_BOOL nh_make_fileExists(</li>
<li>NH_BYTE *filename_p</li>
<li>);</li>
<li></li>
<li>void nh_make_initFileArray(</li>
<li>nh_make_FileArray *Array_p</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_appendFile(</li>
<li>nh_make_FileArray *Array_p, NH_BYTE *path_p</li>
<li>);</li>
<li></li>
<li>nh_make_File nh_make_initFile(</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_setFileData(</li>
<li>nh_make_File *File_p, NH_BYTE *path_p</li>
<li>);</li>
<li></li>
<li>void nh_make_freeFileData(</li>
<li>nh_make_File *File_p</li>
<li>);</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li>+#endif diff --git a/src/lib/nhmake/Core/Options.c b/src/lib/nhmake/Core/Options.c new file mode 100644 index 0000000..a549545 --- /dev/null +++ b/src/lib/nhmake/Core/Options.c @ -0,0 +1,463 @ +// LICENSE NOTICE ==================================================================================</li>
<li>+/**</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>+// INCLUDE =========================================================================================</li>
<li>+#include "Options.h" +#include "Thread.h" +#include "File.h" +#include "Build.h"</li>
<li>+#include "../Parser/Functions.h" +#include "../Parser/Variables.h"</li>
<li>+#include "../Common/Macros/Macros.h" +#include NH_MAKE_FLOW +#include NH_MAKE_DEFAULT_CHECK</li>
<li>+#include &amp;ltstdio.h&gt; +#include &amp;ltstring.h&gt; +#include &amp;ltstdlib.h&gt; +#include &amp;ltctype.h&gt;</li>
<li>+// HELPER ==========================================================================================</li>
<li>+static NH_BYTE *nh_make_offsetBuildArgumentPrefix(</li>
<li>nh_make_Runtime *Runtime_p, NH_BYTE *name_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>nh_make_Variable *Prefix_p = nh_make_getVariable(&amp;Runtime_p-&gt;VariableArray, "PREFIX");</li>
<li></li>
<li>if (Prefix_p) {</li>
<li>int offset = 0;</li>
<li>for (offset = 0; offset &amp;lt strlen(Prefix_p-&gt;values_pp[0]) &amp;&amp; offset &amp;lt strlen(name_p)</li>
<li>&amp;&amp; Prefix_p-&gt;values_pp[0][offset] == name_p[offset]; ++offset) {};</li>
<li>if (offset == strlen(Prefix_p-&gt;values_pp[0])) {</li>
<li>NH_MAKE_END(name_p + offset)</li>
<li>}</li>
<li>}</li>
<li>+NH_MAKE_END(name_p) +}</li>
<li>+// GET OPTION ======================================================================================</li>
<li>+static nh_make_Option *nh_make_getOptionFromBlock(</li>
<li>nh_make_Runtime *Runtime_p, nh_make_Block *Block_p, NH_BYTE *name_p, NH_BYTE **argv_pp, int args) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>for (int d = 0; d &amp;lt Block_p-&gt;definitions; ++d)</li>
<li>{</li>
<li>switch (Block_p-&gt;Definitions_p[d].type)</li>
<li>{</li>
<li>case NH_MAKE_DEFINITION_IF :</li>
<li>if (nh_make_compareIf(Runtime_p, &amp;Block_p-&gt;Definitions_p[d].If, NH_MAKE_TRUE)) {</li>
<li>nh_make_Option *Option_p = nh_make_getOptionFromBlock(Runtime_p, &amp;Block_p-&gt;Definitions_p[d].If.Block_p-&gt;Block, name_p, argv_pp, args);</li>
<li>if (Option_p) {NH_MAKE_END(Option_p)}</li>
<li>}</li>
<li>break;</li>
<li></li>
<li>case NH_MAKE_DEFINITION_OPTION :</li>
<li>if (!strcmp(Block_p-&gt;Definitions_p[d].Option.name_p, name_p)</li>
<li>&amp;&amp; Block_p-&gt;Definitions_p[d].Option.arguments == args) {</li>
<li>NH_MAKE_BOOL sameArguments = NH_MAKE_TRUE;</li>
<li>for (int i = 0; i &amp;lt args; ++i) {</li>
<li>NH_BYTE *argument_p = Block_p-&gt;Definitions_p[d].Option.arguments_pp[i];</li>
<li>NH_BYTE *offsetArgument_p = argument_p;</li>
<li>if (Block_p-&gt;Definitions_p[d].Option.name_p[0] == 'b' || Block_p-&gt;Definitions_p[d].Option.name_p[0] == 't') {</li>
<li>offsetArgument_p = nh_make_offsetBuildArgumentPrefix(Runtime_p, argument_p);</li>
<li>}</li>
<li>if (strcmp(argument_p, argv_pp[i]) &amp;&amp; strcmp(offsetArgument_p, argv_pp[i])) {</li>
<li>sameArguments = NH_MAKE_FALSE;</li>
<li>break;</li>
<li>}</li>
<li>}</li>
<li>if (sameArguments) {</li>
<li>NH_MAKE_END(&amp;Block_p-&gt;Definitions_p[d].Option)</li>
<li>}</li>
<li>}</li>
<li>break;</li>
<li>}</li>
<li>}</li>
<li>+NH_MAKE_END(NULL) +}</li>
<li>+static nh_make_Option *nh_make_getOptionFromParser(</li>
<li>nh_make_Runtime *Runtime_p, nh_make_Parser *Parser_p, NH_BYTE *name_p, NH_BYTE **argv_pp, int args) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>nh_make_Block Block;</li>
<li>Block.definitions = Parser_p-&gt;definitions;</li>
<li>Block.Definitions_p = Parser_p-&gt;Definitions_p;</li>
<li>+NH_MAKE_END(nh_make_getOptionFromBlock(Runtime_p, &amp;Block, name_p, argv_pp, args)) +}</li>
<li>+static nh_make_Option *nh_make_getShortOptions(</li>
<li>nh_make_Runtime *Runtime_p, NH_BYTE *name_p, NH_BYTE **argv_pp, int args, int *options_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>*options_p = 0;</li>
<li></li>
<li>nh_make_Option *Options_p = NULL;</li>
<li>NH_BYTE c = 0;</li>
<li></li>
<li>for (int i = 0; i &amp;lt strlen(name_p); ++i)</li>
<li>{</li>
<li>if (i + 1 &amp;lt strlen(name_p)) {</li>
<li>c = name_p[i+1];</li>
<li>name_p[i+1] = 0;</li>
<li>}</li>
<li></li>
<li>nh_make_Option *Option_p = NULL;</li>
<li>for (int j = 0; j &amp;lt Runtime_p-&gt;ParserArray.length; ++j) {</li>
<li>nh_make_Parser *Parser_p = &amp;Runtime_p-&gt;ParserArray.Parsers_p[j];</li>
<li>Option_p = nh_make_getOptionFromParser(Runtime_p, Parser_p, name_p+i, argv_pp, args);</li>
<li>if (Option_p) {break;}</li>
<li>}</li>
<li></li>
<li>if (Option_p) {</li>
<li>if (*options_p == 0) {</li>
<li>Options_p = Option_p;</li>
<li>}</li>
<li>else if (*options_p == 1) {</li>
<li>nh_make_Option *Tmp_p = malloc(sizeof(nh_make_Option)*2);</li>
<li>Tmp_p[0] = *Options_p;</li>
<li>Tmp_p[1] = *Option_p;</li>
<li>Options_p = Tmp_p;</li>
<li>}</li>
<li>else {</li>
<li>Options_p = realloc(Options_p, sizeof(nh_make_Option)*(*options_p+1));</li>
<li>Options_p[*options_p] = *Option_p;</li>
<li>}</li>
<li>*options_p += 1;</li>
<li>}</li>
<li></li>
<li>if (c != 0) {</li>
<li>name_p[i+1] = c;</li>
<li>c = 0;</li>
<li>}</li>
<li>}</li>
<li>+NH_MAKE_END(Options_p) +}</li>
<li>+static nh_make_Option *nh_make_getOption(</li>
<li>nh_make_Runtime *Runtime_p, NH_BYTE *name_p, int args, NH_BYTE **argv_pp) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>nh_make_Option *Option_p = NULL;</li>
<li></li>
<li>for (int j = 0; j &amp;lt Runtime_p-&gt;ParserArray.length; ++j) {</li>
<li>nh_make_Parser *Parser_p = &amp;Runtime_p-&gt;ParserArray.Parsers_p[j];</li>
<li>Option_p = nh_make_getOptionFromParser(Runtime_p, Parser_p, name_p, argv_pp, args);</li>
<li>if (Option_p) {break;}</li>
<li>}</li>
<li>+NH_MAKE_END(Option_p) +}</li>
<li>+// OPTION NAME =====================================================================================</li>
<li>+static NH_MAKE_BOOL nh_make_optionNameExistsInBlock(</li>
<li>nh_make_Runtime *Runtime_p, nh_make_Block *Block_p, NH_BYTE *name_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>for (int d = 0; d &amp;lt Block_p-&gt;definitions; ++d) {</li>
<li>switch (Block_p-&gt;Definitions_p[d].type) {</li>
<li>case NH_MAKE_DEFINITION_OPTION :</li>
<li>if (!strcmp(Block_p-&gt;Definitions_p[d].Option.name_p, name_p)) {</li>
<li>NH_MAKE_END(NH_MAKE_TRUE)</li>
<li>}</li>
<li>break;</li>
<li>case NH_MAKE_DEFINITION_IF :</li>
<li>if (nh_make_compareIf(Runtime_p, &amp;Block_p-&gt;Definitions_p[d].If, NH_MAKE_TRUE)) {</li>
<li>if (nh_make_optionNameExistsInBlock(Runtime_p, &amp;Block_p-&gt;Definitions_p[d].If.Block_p-&gt;Block, name_p)) {</li>
<li>NH_MAKE_END(NH_MAKE_TRUE)</li>
<li>}</li>
<li>}</li>
<li>break;</li>
<li>}</li>
<li></li>
<li>}</li>
<li>+NH_MAKE_END(NH_MAKE_FALSE) +}</li>
<li>+static NH_MAKE_BOOL nh_make_optionNameExists(</li>
<li>nh_make_Runtime *Runtime_p, NH_BYTE *name_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>for (int i = 0; i &amp;lt Runtime_p-&gt;ParserArray.length; ++i) {</li>
<li>nh_make_Parser *Parser_p = &amp;Runtime_p-&gt;ParserArray.Parsers_p[i];</li>
<li>nh_make_Block Block;</li>
<li>Block.definitions = Parser_p-&gt;definitions;</li>
<li>Block.Definitions_p = Parser_p-&gt;Definitions_p;</li>
<li>if (nh_make_optionNameExistsInBlock(Runtime_p, &amp;Block, name_p)) {</li>
<li>NH_MAKE_END(NH_MAKE_TRUE)</li>
<li>}</li>
<li>}</li>
<li>+NH_MAKE_END(NH_MAKE_FALSE) +}</li>
<li>+// EXECUTE OPTION ==================================================================================</li>
<li>+static NH_MAKE_RESULT nh_make_printOption(</li>
<li>nh_make_Option *Option_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>NH_BYTE args_p[1024]; // TODO malloc</li>
<li>memset(args_p, 0, 1024);</li>
<li>for (int i = 0; i &amp;lt Option_p-&gt;arguments; ++i) {</li>
<li>sprintf(args_p + strlen(args_p), "%s ", Option_p-&gt;arguments_pp[i]);</li>
<li>}</li>
<li></li>
<li>nh_make_operationf(Option_p-&gt;longOption ? "--%s %s'%s'" : "-%s %s'%s'", Option_p-&gt;name_p, args_p, Option_p-&gt;description_p);</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+static NH_MAKE_RESULT nh_make_executeOption(</li>
<li>nh_make_Runtime *Runtime_p, nh_make_Option *Option_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>NH_MAKE_CHECK(nh_make_printOption(Option_p))</li>
<li></li>
<li>if (!Option_p-&gt;Block_p) {</li>
<li>if (!strcmp(Option_p-&gt;name_p, "b")) {</li>
<li>NH_MAKE_CHECK(nh_make_build(Runtime_p, Option_p-&gt;arguments_pp[0]))</li>
<li>}</li>
<li>else if (!strcmp(Option_p-&gt;name_p, "i")) {</li>
<li>}</li>
<li>else if (!strcmp(Option_p-&gt;name_p, "t")) {</li>
<li>NH_MAKE_CHECK(nh_make_test(Runtime_p, Option_p-&gt;arguments_pp[0]))</li>
<li>}</li>
<li>else {NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_BAD_STATE)}</li>
<li>}</li>
<li>else {</li>
<li>NH_MAKE_CHECK(nh_make_executeBlock(Runtime_p, &amp;Option_p-&gt;Block_p-&gt;Block))</li>
<li>}</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+// BUILD OPTIONS ===================================================================================</li>
<li>+static NH_MAKE_BOOL nh_make_buildOptionOverride(</li>
<li>nh_make_Runtime *Runtime_p, NH_BYTE *name_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>for (int j = 0; j &amp;lt Runtime_p-&gt;ParserArray.length; ++j)</li>
<li>{</li>
<li>nh_make_Parser *Parser_p = &amp;Runtime_p-&gt;ParserArray.Parsers_p[j];</li>
<li></li>
<li>for (int i = 0; i &amp;lt Parser_p-&gt;definitions; ++i)</li>
<li>{</li>
<li>nh_make_Definition *Definition_p = &amp;Parser_p-&gt;Definitions_p[i];</li>
<li></li>
<li>if (Definition_p-&gt;type == NH_MAKE_DEFINITION_OPTION</li>
<li>&amp;&amp; !Definition_p-&gt;Option.longOption</li>
<li>&amp;&amp; !strcmp(Definition_p-&gt;Option.name_p, "b")</li>
<li>&amp;&amp; Definition_p-&gt;Option.arguments == 1</li>
<li>&amp;&amp; (!strcmp(Definition_p-&gt;Option.arguments_pp[0], name_p) || !strcmp(nh_make_offsetBuildArgumentPrefix(Runtime_p, Definition_p-&gt;Option.arguments_pp[0]), name_p))) {</li>
<li>NH_MAKE_END(NH_MAKE_TRUE)</li>
<li>}</li>
<li>}</li>
<li>}</li>
<li>+NH_MAKE_END(NH_MAKE_FALSE) +}</li>
<li>+NH_MAKE_RESULT nh_make_addBuildOption(</li>
<li>nh_make_Runtime *Runtime_p, NH_BYTE *name_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>if (nh_make_buildOptionOverride(Runtime_p, name_p)) {NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS)}</li>
<li></li>
<li>static NH_BYTE *option_p = "b";</li>
<li></li>
<li>nh_make_Parser *Parser_p = &amp;Runtime_p-&gt;ParserArray.Parsers_p[0];</li>
<li></li>
<li>Parser_p-&gt;Definitions_p = realloc(Parser_p-&gt;Definitions_p, sizeof(nh_make_Definition) * (Parser_p-&gt;definitions + 1));</li>
<li>NH_MAKE_CHECK_NULL(Parser_p-&gt;Definitions_p)</li>
<li></li>
<li>nh_make_Definition *Definition_p = &amp;Parser_p-&gt;Definitions_p[Parser_p-&gt;definitions++];</li>
<li></li>
<li>NH_BYTE *description_p = malloc(strlen(name_p) + 7);</li>
<li>NH_MAKE_CHECK_NULL(description_p)</li>
<li>sprintf(description_p, "build %s", name_p);</li>
<li></li>
<li>NH_BYTE *argument_p = malloc(strlen(name_p) + 1);</li>
<li>NH_MAKE_CHECK_NULL(argument_p)</li>
<li>strcpy(argument_p, name_p);</li>
<li></li>
<li>NH_BYTE **arguments_pp = malloc(sizeof(NH_BYTE*));</li>
<li>NH_MAKE_CHECK_NULL(arguments_pp)</li>
<li>arguments_pp[0] = argument_p;</li>
<li></li>
<li>Definition_p-&gt;type = NH_MAKE_DEFINITION_OPTION;</li>
<li>Definition_p-&gt;Option.arguments = 1;</li>
<li>Definition_p-&gt;Option.arguments_pp = arguments_pp;</li>
<li>Definition_p-&gt;Option.longOption = NH_MAKE_FALSE;</li>
<li>Definition_p-&gt;Option.name_p = option_p;</li>
<li>Definition_p-&gt;Option.description_p = description_p;</li>
<li>Definition_p-&gt;Option.Block_p = NULL;</li>
<li></li>
<li>nh_make_messagef("Generate Option '-b %s'", name_p);</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+NH_MAKE_RESULT nh_make_addTestOption(</li>
<li>nh_make_Runtime *Runtime_p, NH_BYTE *name_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>static NH_BYTE *option_p = "t";</li>
<li></li>
<li>nh_make_Parser *Parser_p = &amp;Runtime_p-&gt;ParserArray.Parsers_p[0];</li>
<li></li>
<li>Parser_p-&gt;Definitions_p = realloc(Parser_p-&gt;Definitions_p, sizeof(nh_make_Definition) * (Parser_p-&gt;definitions + 1));</li>
<li>NH_MAKE_CHECK_NULL(Parser_p-&gt;Definitions_p)</li>
<li></li>
<li>nh_make_Definition *Definition_p = &amp;Parser_p-&gt;Definitions_p[Parser_p-&gt;definitions++];</li>
<li></li>
<li>NH_BYTE *description_p = malloc(strlen(name_p) + 7);</li>
<li>NH_MAKE_CHECK_NULL(description_p)</li>
<li>sprintf(description_p, "test %s", name_p);</li>
<li></li>
<li>NH_BYTE *argument_p = malloc(strlen(name_p) + 1);</li>
<li>NH_MAKE_CHECK_NULL(argument_p)</li>
<li>strcpy(argument_p, name_p);</li>
<li></li>
<li>NH_BYTE **arguments_pp = malloc(sizeof(NH_BYTE*));</li>
<li>NH_MAKE_CHECK_NULL(arguments_pp)</li>
<li>arguments_pp[0] = argument_p;</li>
<li></li>
<li>Definition_p-&gt;type = NH_MAKE_DEFINITION_OPTION;</li>
<li>Definition_p-&gt;Option.arguments = 1;</li>
<li>Definition_p-&gt;Option.arguments_pp = arguments_pp;</li>
<li>Definition_p-&gt;Option.longOption = NH_MAKE_FALSE;</li>
<li>Definition_p-&gt;Option.name_p = option_p;</li>
<li>Definition_p-&gt;Option.description_p = description_p;</li>
<li>Definition_p-&gt;Option.Block_p = NULL;</li>
<li></li>
<li>nh_make_messagef("Generate Option '-t %s'", name_p);</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+// PARSE ===========================================================================================</li>
<li>+static NH_MAKE_RESULT nh_make_parseShortOption(</li>
<li>nh_make_Runtime *Runtime_p, NH_BYTE *name_p, int optArgsCount, NH_BYTE **optArgs_pp, int *parsedOptArgs_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>for (int i = 0; i &amp;lt optArgsCount; ++i)</li>
<li>{</li>
<li>int options = 0;</li>
<li>nh_make_Option *Options_p = nh_make_getShortOptions(Runtime_p, name_p, &amp;optArgs_pp[i], 1, &amp;options);</li>
<li>if (Options_p) {</li>
<li>for (int j = 0; j &amp;lt options; ++j) {</li>
<li>NH_MAKE_CHECK(nh_make_executeOption(Runtime_p, Options_p+j))</li>
<li>}</li>
<li>if (options &gt; 1) {free(Options_p);}</li>
<li>}</li>
<li>*parsedOptArgs_p += 1;</li>
<li>}</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+static NH_MAKE_RESULT nh_make_parseLongOption(</li>
<li>nh_make_Runtime *Runtime_p, NH_BYTE *name_p, int optArgsCount, NH_BYTE **optArgs_pp, int *parsedOptArgs_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>nh_make_Option *Option_p = NULL;</li>
<li></li>
<li>// Get trivial option.</li>
<li>if (optArgsCount == 0) {</li>
<li>Option_p = nh_make_getOption(Runtime_p, name_p, 0, NULL);</li>
<li>if (!Option_p) {</li>
<li>NH_MAKE_END(NH_MAKE_ERROR_INVALID_OPTION)</li>
<li>}</li>
<li>*parsedOptArgs_p = 0;</li>
<li>}</li>
<li></li>
<li>// Get option which matches the most arguments.</li>
<li>for (int i = optArgsCount; i &gt; 0; --i) {</li>
<li>Option_p = nh_make_getOption(Runtime_p, name_p, i, optArgs_pp);</li>
<li>if (Option_p) {</li>
<li>*parsedOptArgs_p = i;</li>
<li>break;</li>
<li>}</li>
<li>}</li>
<li></li>
<li>if (!Option_p) {</li>
<li>NH_MAKE_END(NH_MAKE_ERROR_INVALID_OPTION)</li>
<li>}</li>
<li></li>
<li>NH_MAKE_CHECK(nh_make_executeOption(Runtime_p, Option_p))</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+NH_MAKE_RESULT nh_make_parseOption(</li>
<li>nh_make_Runtime *Runtime_p, int optionLength, NH_BYTE **option_pp, int *advance_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>for (int i = 0, advance = 0; i &amp;lt optionLength; i += advance)</li>
<li>{</li>
<li>NH_BYTE **optArgs_pp = NULL;</li>
<li>int optArgsCount = 0;</li>
<li>if (i == 0) {</li>
<li>if (optionLength &gt; 1) {</li>
<li>optArgs_pp = option_pp+1;</li>
<li>optArgsCount = optionLength-1;</li>
<li>}</li>
<li>}</li>
<li>else {</li>
<li>optArgs_pp = option_pp+i;</li>
<li>optArgsCount = optionLength - i;</li>
<li>}</li>
<li></li>
<li>int parsedOptArgs = 0;</li>
<li></li>
<li>if (option_pp[0][0] == '-' &amp;&amp; option_pp[0][1] != '-') {</li>
<li>NH_MAKE_CHECK(nh_make_parseShortOption(Runtime_p, option_pp[0]+1, optArgsCount, optArgs_pp, &amp;parsedOptArgs))</li>
<li>}</li>
<li>else if (option_pp[0][0] == '-' &amp;&amp; option_pp[0][1] == '-') {</li>
<li>NH_MAKE_CHECK(nh_make_parseLongOption(Runtime_p, option_pp[0]+2, optArgsCount, optArgs_pp, &amp;parsedOptArgs))</li>
<li>}</li>
<li>else {</li>
<li>NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_INVALID_OPTION)</li>
<li>}</li>
<li></li>
<li>advance = i ? parsedOptArgs : parsedOptArgs + 1;</li>
<li>*advance_p += advance;</li>
<li>}</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>diff --git a/src/lib/nhmake/Core/Options.h b/src/lib/nhmake/Core/Options.h new file mode 100644 index 0000000..38f38b6 --- /dev/null +++ b/src/lib/nhmake/Core/Options.h @ -0,0 +1,39 @ +#ifndef NH_MAKE_OPTIONS_H +#define NH_MAKE_OPTIONS_H</li>
<li>+#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>+/**</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>+#include "Source.h"</li>
<li>+#include "../Common/Types/Private.h"</li>
<li>+#include "../Parser/Parser.h" +#include "../Parser/Variables.h"</li>
<li>+#endif</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_addBuildOption(</li>
<li>nh_make_Runtime *Runtime_p, NH_BYTE *name_p</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_addTestOption(</li>
<li>nh_make_Runtime *Runtime_p, NH_BYTE *name_p</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_parseOption(</li>
<li>nh_make_Runtime *Runtime_p, int optionLength, NH_BYTE **argv_pp, int *advance_p</li>
<li>);</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_executeRuntime(</li>
<li>nh_make_Runtime *Runtime_p, NH_BYTE **args_pp, int args</li>
<li>);</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>void nh_make_initSourceArray(</li>
<li>nh_make_SourceArray *Array_p</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_addSource(</li>
<li>nh_make_SourceContextArray *ContextArray_p, nh_make_SourceArray *SourceArray_p, nh_make_Function *Function_p,</li>
<li>NH_MAKE_SOURCE_CONTEXT type</li>
<li>);</li>
<li></li>
<li>void nh_make_initSourceContextArray(</li>
<li>nh_make_SourceContextArray *Array_p</li>
<li>);</li>
<li></li>
<li>void nh_make_getIndentAfterSourceContext(</li>
<li>NH_BYTE *name_p, NH_BYTE *buffer_p, int size, nh_make_SourceContextArray *Array_p</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_addSourceContext(</li>
<li>nh_make_Runtime *Runtime_p, nh_make_Function *Function_p, NH_MAKE_SOURCE_CONTEXT type, int offset</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_addCompileArguments(</li>
<li>nh_make_SourceContextArray *ContextArray_p, nh_make_Function *Function_p, NH_MAKE_SOURCE_CONTEXT type</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_addLinkArguments(</li>
<li>nh_make_SourceContextArray *Array_p, nh_make_Function *Function_p, NH_MAKE_SOURCE_CONTEXT type</li>
<li>);</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>void nh_make_initThreadPool(</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_runThread(</li>
<li>nh_make_Runtime *Runtime_p, NH_BYTE **args_pp, int args</li>
<li>);</li>
<li></li>
<li>nh_make_Thread *_nh_make_getThread(</li>
<li>);</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>const NH_BYTE *nh_make_getHomeDir(</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_createDir(</li>
<li>NH_BYTE *path_p</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_removeDir(</li>
<li>NH_BYTE *path_p</li>
<li>);</li>
<li></li>
<li>NH_MAKE_BOOL nh_make_canRunCommand(</li>
<li>const NH_BYTE *cmd</li>
<li>);</li>
<li></li>
<li>NH_BYTE *nh_make_getWorkDirectory(</li>
<li>);</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>nh_make_Version nh_make_initVersion(</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_computeVersion(</li>
<li>nh_make_Runtime *Runtime_p, nh_make_SourceContext *Context_p</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_updateVersions(</li>
<li>nh_make_Runtime *Runtime_p</li>
<li>);</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li>+#endif diff --git a/src/lib/nhmake/Parser/Functions.c b/src/lib/nhmake/Parser/Functions.c new file mode 100644 index 0000000..3041ebc --- /dev/null +++ b/src/lib/nhmake/Parser/Functions.c @ -0,0 +1,275 @ +// LICENSE NOTICE ==================================================================================</li>
<li>+/**</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>+// INCLUDE =========================================================================================</li>
<li>+#include "Functions.h" +#include "Variables.h"</li>
<li>+#include "../Core/Build.h" +#include "../Core/Utils.h" +#include "../UI/Message.h" +#include "../Common/Macros/Macros.h" +#include NH_MAKE_FLOW +#include NH_MAKE_DEFAULT_CHECK</li>
<li>+#include &amp;ltstdio.h&gt; +#include &amp;ltstdlib.h&gt; +#include &amp;ltstring.h&gt; +#include &amp;ltunistd.h&gt; +#include &amp;ltctype.h&gt;</li>
<li>+#include &amp;ltsys/types.h&gt; +#include &amp;ltsys/stat.h&gt;</li>
<li>+// HELPER ==========================================================================================</li>
<li>+static NH_MAKE_BOOL nh_make_caseInsensitiveMatch(</li>
<li>NH_BYTE *str1_p, NH_BYTE *str2_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>if (strlen(str1_p) != strlen(str2_p)) {NH_MAKE_END(NH_MAKE_FALSE)}</li>
<li></li>
<li>for (int i = 0; i &amp;lt strlen(str1_p); ++i) {</li>
<li>int d = tolower((unsigned char)str1_p[i]) - tolower((unsigned char)str2_p[i]);</li>
<li>if (d != 0) {</li>
<li>NH_MAKE_END(NH_MAKE_FALSE)</li>
<li>}</li>
<li>}</li>
<li>+NH_MAKE_END(NH_MAKE_TRUE) +}</li>
<li>+// EXECUTE =========================================================================================</li>
<li>+static NH_MAKE_RESULT nh_make_executeCopyFunction(</li>
<li>nh_make_Runtime *Runtime_p, nh_make_Function *Function_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>if (Function_p-&gt;arguments &amp;lt= 0 || Function_p-&gt;arguments &gt; 4) {NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_BAD_STATE)}</li>
<li></li>
<li>switch(Function_p-&gt;arguments)</li>
<li>{</li>
<li>case 2 :</li>
<li>nh_make_copy(&amp;Runtime_p-&gt;VariableArray, Function_p-&gt;arguments_pp[0], Function_p-&gt;arguments_pp[1], NH_MAKE_FALSE, NH_MAKE_FALSE);</li>
<li>break;</li>
<li>case 3 :</li>
<li>nh_make_copy(&amp;Runtime_p-&gt;VariableArray, Function_p-&gt;arguments_pp[0], Function_p-&gt;arguments_pp[1], !strcmp(Function_p-&gt;arguments_pp[2], "true") ? NH_MAKE_TRUE : NH_MAKE_FALSE, NH_MAKE_FALSE);</li>
<li>break;</li>
<li>case 4 :</li>
<li>nh_make_copy(&amp;Runtime_p-&gt;VariableArray, Function_p-&gt;arguments_pp[0], Function_p-&gt;arguments_pp[1], !strcmp(Function_p-&gt;arguments_pp[2], "true") ? NH_MAKE_TRUE : NH_MAKE_FALSE, !strcmp(Function_p-&gt;arguments_pp[3], "true") ? NH_MAKE_TRUE : NH_MAKE_FALSE);</li>
<li>break;</li>
<li>}</li>
<li>+NH_MAKE_END(NH_MAKE_SUCCESS) +}</li>
<li>+static NH_MAKE_RESULT nh_make_executeChdirFunction(</li>
<li>nh_make_Runtime *Runtime_p, nh_make_Function *Function_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>if (Function_p-&gt;arguments == 0) {</li>
<li>nh_make_updateVariable(&amp;Runtime_p-&gt;VariableArray, "WRK_DIR", nh_make_getVariable(&amp;Runtime_p-&gt;VariableArray, "PROJ_DIR")-&gt;values_pp, 1);</li>
<li>}</li>
<li>else {</li>
<li>nh_make_updateVariable(&amp;Runtime_p-&gt;VariableArray, "WRK_DIR", Function_p-&gt;arguments_pp, 1);</li>
<li>}</li>
<li></li>
<li>nh_make_messagef("chdir %s", nh_make_getVariable(&amp;Runtime_p-&gt;VariableArray, "WRK_DIR")-&gt;values_pp[0]);</li>
<li>+NH_MAKE_END(NH_MAKE_SUCCESS) +}</li>
<li>+static NH_MAKE_RESULT nh_make_executeMkdirFunction(</li>
<li>nh_make_Function *Function_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>if (Function_p-&gt;arguments != 1) {NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS)}</li>
<li></li>
<li>struct stat st = {0};</li>
<li>if (stat(Function_p-&gt;arguments_pp[0], &amp;st) == -1) {</li>
<li>int err = mkdir(Function_p-&gt;arguments_pp[0], 0755); // 0755 -&gt; drwxr-xr-x</li>
<li>if (err != 0) {</li>
<li>NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_CANT_CREATE_DIRECTORY)</li>
<li>}</li>
<li>}</li>
<li></li>
<li>nh_make_messagef("mkdir %s", Function_p-&gt;arguments_pp[0]);</li>
<li>+NH_MAKE_END(NH_MAKE_SUCCESS) +}</li>
<li>+static NH_MAKE_RESULT nh_make_executeSystemFunction(</li>
<li>nh_make_Function *Function_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>if (Function_p-&gt;arguments != 1) {NH_MAKE_DIAGNOSTIC_END(NH_MAKE_ERROR_BAD_STATE)}</li>
<li>nh_make_messagef("system %s", Function_p-&gt;arguments_pp[0]);</li>
<li>system(Function_p-&gt;arguments_pp[0]);</li>
<li>+NH_MAKE_END(NH_MAKE_SUCCESS) +}</li>
<li>+NH_MAKE_RESULT nh_make_executeFunction(</li>
<li>nh_make_Runtime *Runtime_p, nh_make_Function *Function_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>NH_BYTE **arguments_pp = malloc(sizeof(NH_BYTE*) * Function_p-&gt;arguments);</li>
<li>memcpy(arguments_pp, Function_p-&gt;arguments_pp, sizeof(NH_BYTE*) * Function_p-&gt;arguments);</li>
<li></li>
<li>for (int i = 0; i &amp;lt Function_p-&gt;arguments; ++i) {</li>
<li>Function_p-&gt;arguments_pp[i] = nh_make_substituteVariables(&amp;Runtime_p-&gt;VariableArray, arguments_pp[i]);</li>
<li>NH_MAKE_CHECK_NULL(Function_p-&gt;arguments_pp[i])</li>
<li>}</li>
<li>NH_MAKE_RESULT result = NH_MAKE_SUCCESS;</li>
<li></li>
<li>if (nh_make_caseInsensitiveMatch(Function_p-&gt;name_p, "lib")) {</li>
<li>if (!strcmp(Function_p-&gt;arguments_pp[0], "SHARED")) {</li>
<li>result = nh_make_addSourceContext(Runtime_p, Function_p, NH_MAKE_SOURCE_CONTEXT_SHARED_LIBRARY, 1);</li>
<li>}</li>
<li>else if (!strcmp(Function_p-&gt;arguments_pp[0], "STATIC")) {</li>
<li>result = nh_make_addSourceContext(Runtime_p, Function_p, NH_MAKE_SOURCE_CONTEXT_STATIC_LIBRARY, 1);</li>
<li>}</li>
<li>else {</li>
<li>result = nh_make_addSourceContext(Runtime_p, Function_p, NH_MAKE_SOURCE_CONTEXT_SHARED_LIBRARY, 0);</li>
<li>}</li>
<li>if (!result &amp;&amp; Runtime_p-&gt;sourceContextCallback_f) {</li>
<li>result = Runtime_p-&gt;sourceContextCallback_f(</li>
<li>Runtime_p, &amp;Runtime_p-&gt;SourceContextArray.SourceContexts_p[Runtime_p-&gt;SourceContextArray.length - 1]</li>
<li>);</li>
<li>}</li>
<li>}</li>
<li>else if (nh_make_caseInsensitiveMatch(Function_p-&gt;name_p, "bin")) {</li>
<li>result = nh_make_addSourceContext(Runtime_p, Function_p, NH_MAKE_SOURCE_CONTEXT_BINARY, 0);</li>
<li>if (!result &amp;&amp; Runtime_p-&gt;sourceContextCallback_f) {</li>
<li>result = Runtime_p-&gt;sourceContextCallback_f(</li>
<li>Runtime_p, &amp;Runtime_p-&gt;SourceContextArray.SourceContexts_p[Runtime_p-&gt;SourceContextArray.length - 1]</li>
<li>);</li>
<li>}</li>
<li>}</li>
<li>else if (nh_make_caseInsensitiveMatch(Function_p-&gt;name_p, "compile")) {</li>
<li>result = nh_make_addCompileArguments(&amp;Runtime_p-&gt;SourceContextArray, Function_p, NH_MAKE_SOURCE_CONTEXT_UNDEFINED);</li>
<li>}</li>
<li>else if (nh_make_caseInsensitiveMatch(Function_p-&gt;name_p, "compile_lib")) {</li>
<li>result = nh_make_addCompileArguments(&amp;Runtime_p-&gt;SourceContextArray, Function_p, NH_MAKE_SOURCE_CONTEXT_SHARED_LIBRARY);</li>
<li>}</li>
<li>else if (nh_make_caseInsensitiveMatch(Function_p-&gt;name_p, "compile_bin")) {</li>
<li>result = nh_make_addCompileArguments(&amp;Runtime_p-&gt;SourceContextArray, Function_p, NH_MAKE_SOURCE_CONTEXT_BINARY);</li>
<li>}</li>
<li>else if (nh_make_caseInsensitiveMatch(Function_p-&gt;name_p, "link")) {</li>
<li>result = nh_make_addLinkArguments(&amp;Runtime_p-&gt;SourceContextArray, Function_p, NH_MAKE_SOURCE_CONTEXT_UNDEFINED);</li>
<li>}</li>
<li>else if (nh_make_caseInsensitiveMatch(Function_p-&gt;name_p, "link_lib")) {</li>
<li>result = nh_make_addLinkArguments(&amp;Runtime_p-&gt;SourceContextArray, Function_p, NH_MAKE_SOURCE_CONTEXT_SHARED_LIBRARY);</li>
<li>}</li>
<li>else if (nh_make_caseInsensitiveMatch(Function_p-&gt;name_p, "link_bin")) {</li>
<li>result = nh_make_addLinkArguments(&amp;Runtime_p-&gt;SourceContextArray, Function_p, NH_MAKE_SOURCE_CONTEXT_BINARY);</li>
<li>}</li>
<li>else if (nh_make_caseInsensitiveMatch(Function_p-&gt;name_p, "source")) {</li>
<li>result = nh_make_addSource(&amp;Runtime_p-&gt;SourceContextArray, &amp;Runtime_p-&gt;SourceArray, Function_p, NH_MAKE_SOURCE_CONTEXT_UNDEFINED);</li>
<li>}</li>
<li>else if (nh_make_caseInsensitiveMatch(Function_p-&gt;name_p, "source_lib")) {</li>
<li>result = nh_make_addSource(&amp;Runtime_p-&gt;SourceContextArray, &amp;Runtime_p-&gt;SourceArray, Function_p, NH_MAKE_SOURCE_CONTEXT_SHARED_LIBRARY);</li>
<li>}</li>
<li>else if (nh_make_caseInsensitiveMatch(Function_p-&gt;name_p, "source_bin")) {</li>
<li>result = nh_make_addSource(&amp;Runtime_p-&gt;SourceContextArray, &amp;Runtime_p-&gt;SourceArray, Function_p, NH_MAKE_SOURCE_CONTEXT_BINARY);</li>
<li>}</li>
<li>else if (nh_make_caseInsensitiveMatch(Function_p-&gt;name_p, "test")) {</li>
<li>result = nh_make_addTest(&amp;Runtime_p-&gt;SourceContextArray, &amp;Runtime_p-&gt;TestArray, Function_p);</li>
<li>}</li>
<li>else if (nh_make_caseInsensitiveMatch(Function_p-&gt;name_p, "copy")) {</li>
<li>result = nh_make_executeCopyFunction(Runtime_p, Function_p);</li>
<li>}</li>
<li>else if (nh_make_caseInsensitiveMatch(Function_p-&gt;name_p, "build")) {</li>
<li>result = nh_make_build(Runtime_p, Function_p-&gt;arguments_pp[0]);</li>
<li>}</li>
<li>else if (nh_make_caseInsensitiveMatch(Function_p-&gt;name_p, "chdir")) {</li>
<li>result = nh_make_executeChdirFunction(Runtime_p, Function_p);</li>
<li>}</li>
<li>else if (nh_make_caseInsensitiveMatch(Function_p-&gt;name_p, "mkdir")) {</li>
<li>result = nh_make_executeMkdirFunction(Function_p);</li>
<li>}</li>
<li>else if (nh_make_caseInsensitiveMatch(Function_p-&gt;name_p, "system")) {</li>
<li>result = nh_make_executeSystemFunction(Function_p);</li>
<li>}</li>
<li>else if (nh_make_caseInsensitiveMatch(Function_p-&gt;name_p, "system")) {</li>
<li>result = nh_make_executeSystemFunction(Function_p);</li>
<li>}</li>
<li>else if (nh_make_caseInsensitiveMatch(Function_p-&gt;name_p, "set")) {</li>
<li>result = nh_make_updateVariable(</li>
<li>&amp;Runtime_p-&gt;VariableArray, Function_p-&gt;arguments_pp[0], Function_p-&gt;arguments_pp + 1,</li>
<li>Function_p-&gt;arguments - 1</li>
<li>);</li>
<li>}</li>
<li></li>
<li>if (!result &amp;&amp; Runtime_p-&gt;functionCallback_f) {</li>
<li>result = Runtime_p-&gt;functionCallback_f(Runtime_p, Function_p);</li>
<li>}</li>
<li></li>
<li>for (int i = 0; i &amp;lt Function_p-&gt;arguments; ++i) {</li>
<li>free(Function_p-&gt;arguments_pp[i]);</li>
<li>}</li>
<li></li>
<li>memcpy(Function_p-&gt;arguments_pp, arguments_pp, sizeof(NH_BYTE*) * Function_p-&gt;arguments);</li>
<li>free(arguments_pp);</li>
<li>+NH_MAKE_DIAGNOSTIC_END(result) +}</li>
<li>+NH_MAKE_BOOL nh_make_compareIf(</li>
<li>nh_make_Runtime *Runtime_p, nh_make_If *If_p, NH_MAKE_BOOL b) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>nh_make_Variable *Var_p = nh_make_getVariable(&amp;Runtime_p-&gt;VariableArray, If_p-&gt;string_p);</li>
<li>if (Var_p &amp;&amp; Var_p-&gt;valueCount &gt; 0) {</li>
<li>if (!strcmp(*Var_p-&gt;values_pp, "true") &amp;&amp; b == NH_MAKE_TRUE) {NH_MAKE_END(NH_MAKE_TRUE)}</li>
<li>if (!strcmp(*Var_p-&gt;values_pp, "false") &amp;&amp; b == NH_MAKE_FALSE) {NH_MAKE_END(NH_MAKE_TRUE)}</li>
<li>}</li>
<li>+NH_MAKE_END(NH_MAKE_FALSE) +}</li>
<li>+NH_MAKE_RESULT nh_make_executeIf(</li>
<li>nh_make_Runtime *Runtime_p, nh_make_If *If_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>nh_make_Variable *Var_p = nh_make_getVariable(&amp;Runtime_p-&gt;VariableArray, If_p-&gt;string_p);</li>
<li>if (Var_p &amp;&amp; Var_p-&gt;valueCount &gt; 0 &amp;&amp; !strcmp(*Var_p-&gt;values_pp, "true")) {</li>
<li>NH_MAKE_CHECK(nh_make_executeBlock(Runtime_p, &amp;If_p-&gt;Block_p-&gt;Block))</li>
<li>}</li>
<li>+NH_MAKE_DIAGNOSTIC_END(NH_MAKE_SUCCESS) +}</li>
<li>+// EXECUTE BLOCK ===================================================================================</li>
<li>+NH_MAKE_RESULT nh_make_executeBlock(</li>
<li>nh_make_Runtime *Runtime_p, nh_make_Block *Block_p) +{ +NH_MAKE_BEGIN()</li>
<li></li>
<li>for (int d = 0; d &amp;lt Block_p-&gt;definitions; ++d) {</li>
<li>switch (Block_p-&gt;Definitions_p[d].type) {</li>
<li>case NH_MAKE_DEFINITION_FUNCTION :</li>
<li>NH_MAKE_CHECK(nh_make_executeFunction(Runtime_p, &amp;Block_p-&gt;Definitions_p[d].Function))</li>
<li>case NH_MAKE_DEFINITION_IF :</li>
<li>NH_MAKE_CHECK(nh_make_executeIf(Runtime_p, &amp;Block_p-&gt;Definitions_p[d].If))</li>
<li>}</li>
<li>}</li>
<li>+NH_MAKE_END(NH_MAKE_SUCCESS) +}</li>
<li>diff --git a/src/lib/nhmake/Parser/Functions.h b/src/lib/nhmake/Parser/Functions.h new file mode 100644 index 0000000..2ed24a3 --- /dev/null +++ b/src/lib/nhmake/Parser/Functions.h @ -0,0 +1,38 @ +#ifndef NH_MAKE_FUNCTIONS_H +#define NH_MAKE_FUNCTIONS_H</li>
<li>+#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>+/**</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>+#include "Parser.h"</li>
<li>+#include "../Core/Runtime.h"</li>
<li>+#include "../Common/Types/Private.h"</li>
<li>+#endif</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_executeFunction(</li>
<li>nh_make_Runtime *Runtime_p, nh_make_Function *Function_p</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_executeBlock(</li>
<li>nh_make_Runtime *Runtime_p, nh_make_Block *Block_p</li>
<li>);</li>
<li></li>
<li>NH_MAKE_BOOL nh_make_compareIf(</li>
<li>nh_make_Runtime *Runtime_p, nh_make_If *If_p, NH_MAKE_BOOL b</li>
<li>);</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>void nh_make_initParserArray(</li>
<li>nh_make_ParserArray *Array_p</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_appendParser(</li>
<li>nh_make_ParserArray *Array_p, nh_make_File *File_p, NH_MAKE_BOOL showParseTree</li>
<li>);</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>nh_make_Tokenizer nh_make_initTokenizer(</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_tokenizeFile(</li>
<li>nh_make_Tokenizer *Tokenizer_p, nh_make_File *File_p</li>
<li>);</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>void nh_make_initVariableArray(</li>
<li>nh_make_VariableArray *Array_p</li>
<li>);</li>
<li></li>
<li>nh_make_Variable *nh_make_getVariable(</li>
<li>nh_make_VariableArray *Array_p, NH_BYTE *name_p</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_appendToVariable(</li>
<li>nh_make_VariableArray *Array_p, NH_BYTE *variable_p, NH_BYTE **values_pp, int valueCount</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_updateVariable(</li>
<li>nh_make_VariableArray *Array_p, NH_BYTE *variable_p, NH_BYTE **values_pp, int valueCount</li>
<li>);</li>
<li></li>
<li>NH_BYTE *nh_make_substituteVariables(</li>
<li>nh_make_VariableArray *Array_p, NH_BYTE *string_p</li>
<li>);</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li><p class="startli">+#endif diff --git a/external/selfmake/src/lib/Test/Library.c b/src/lib/nhmake/Test/Library.c similarity index 77% rename from external/selfmake/src/lib/Test/Library.c rename to src/lib/nhmake/Test/Library.c index 11576c3..7e7b2e9 100644 --- a/external/selfmake/src/lib/Test/Library.c +++ b/src/lib/nhmake/Test/Library.c @ -1,8 +1,8 @ // LICENSE NOTICE ==================================================================================</p>
<p class="startli">/**</p>
</li>
<li>* selfmake - Script Language</li>
<li>* Copyright (C) 2021 The selfmake Authors</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors<ul>
<li>Published under MIT */</li>
</ul>
</li>
</ul>
<p >@ -10,10 +10,9 @</p>
<p >#include "Library.h"</p>
<p >-#include "../Common/Types.h" #include "../Common/Macros/Macros.h" -#include SM_FLOW -#include SM_DEFAULT_CHECK +#include NH_MAKE_FLOW +#include NH_MAKE_DEFAULT_CHECK</p>
<p >#include &amp;ltunistd.h&gt; #include &amp;ltdlfcn.h&gt; @ -28,12 +27,12 @</p>
<p >// TEST ============================================================================================</p>
<p >-void *sm_openLibrary(</p><ul>
<li>SM_BYTE *path_p) +void *nh_make_openLibrary(</li>
<li>NH_BYTE *path_p) { #if defined(__linux__) || defined(__APPLE__)</li>
<li>SM_BYTE *error_p;</li>
<li><p class="startli">NH_BYTE *error_p; dlerror();</p>
<p class="startli">void *dl_p = dlopen(path_p, RTLD_NOW | RTLD_GLOBAL); @ -48,7 +47,7 @ void *sm_openLibrary( #endif }</p>
</li>
</ul>
<p >-void sm_closeLibrary( +void nh_make_closeLibrary(
     void *lib_p) { #if defined(__linux__) || defined(__APPLE__) @ -58,13 +57,13 @ void sm_closeLibrary( #endif }</p>
<p >-SM_RESULT sm_getExeDir(</p><ul>
<li>SM_BYTE *buffer_p, size_t size) +NH_MAKE_RESULT nh_make_getExeDir(</li>
<li>NH_BYTE *buffer_p, size_t size) { #if defined(__linux__) if (readlink("/proc/self/exe", buffer_p, size) == -1 &amp;&amp; readlink("/proc/curproc/file", buffer_p, size) == -1</li>
<li>&amp;&amp; readlink("/proc/self/path/a.out", buffer_p, size) == -1) {SM_END(SM_ERROR_BAD_STATE)}</li>
<li><p class="startli">&amp;&amp; readlink("/proc/self/path/a.out", buffer_p, size) == -1) {NH_MAKE_END(NH_MAKE_ERROR_BAD_STATE)} #elif defined(__APPLE__) size = 0; _NSGetExecutablePath(NULL, &amp;size); @ -72,20 +71,20 @ SM_RESULT sm_getExeDir(</p>
<p class="startli">int i; for (i = strlen(buffer_p); i &gt; -1 &amp;&amp; buffer_p[i] != '/'; --i) {}</p>
</li>
<li>if (i == -1) {return SM_ERROR_BAD_STATE;}</li>
<li><p class="startli">if (i == -1) {return NH_MAKE_ERROR_BAD_STATE;}</p>
<p class="startli">buffer_p[i] = '\0'; // remove exe name</p>
</li>
<li>return SM_SUCCESS;</li>
<li><p class="startli">return NH_MAKE_SUCCESS;</p>
<p class="startli">#endif }</p>
</li>
</ul>
<p >-void *sm_loadSymbol(</p><ul>
<li>void *lib_p, const SM_BYTE *name_p) +void *nh_make_loadSymbol(</li>
<li>void *lib_p, const NH_BYTE *name_p) { #if defined(__linux__) || defined(__APPLE__)</li>
<li>SM_BYTE *error_p;</li>
<li><p class="startli">NH_BYTE *error_p; dlerror(); // clear any existing error</p>
<p class="startli">void *function_p = dlsym(lib_p, name_p); diff --git a/src/lib/nhmake/Test/Library.h b/src/lib/nhmake/Test/Library.h new file mode 100644 index 0000000..93d9334 --- /dev/null +++ b/src/lib/nhmake/Test/Library.h @ -0,0 +1,40 @ +#ifndef NH_MAKE_LIBRARY_H +#define NH_MAKE_LIBRARY_H</p>
</li>
<li>+#ifndef DOXYGEN_SHOULD_SKIP_THIS</li>
<li>+/**</li>
<li>* netzhaut - Web Browser Engine</li>
<li>* Copyright (C) 2021 The netzhaut Authors</li>
<li>* Published under MIT</li>
<li>*/</li>
<li>+#include "../Common/Types/Private.h"</li>
<li>+#include &amp;ltstddef.h&gt;</li>
<li>+#endif</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>void *nh_make_openLibrary(</li>
<li>NH_BYTE *path_p</li>
<li>);</li>
<li></li>
<li>void nh_make_closeLibrary(</li>
<li>void *lib_p</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_getExeDir(</li>
<li>NH_BYTE *buffer_p, size_t size</li>
<li>);</li>
<li></li>
<li>void *nh_make_loadSymbol(</li>
<li>void *lib_p, const NH_BYTE *name_p</li>
<li>);</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>nh_make_Process nh_make_fork(</li>
<li>);</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>void nh_make_initTestArray(</li>
<li>nh_make_TestArray *Array_p</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_addTest(</li>
<li>nh_make_SourceContextArray *ContextArray_p, nh_make_TestArray *TestArray_p, nh_make_Function *Function_p</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_test(</li>
<li>nh_make_Runtime *Runtime_p, NH_BYTE *name_p</li>
<li>);</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_runGUI(</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_handleGUIExpose(</li>
<li>);</li>
<li></li>
<li>void nh_make_handleGUIExit(</li>
<li>);</li>
<li><p class="startli">+/**</p>
<p class="startli">*/</p>
</li>
<li>+/**</li>
<li>*</li>
<li>*/</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_operationf(</li>
<li>NH_BYTE *format_p, ...</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_messagef(</li>
<li>NH_BYTE *format_p, ...</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_noticef(</li>
<li>NH_BYTE *format_p, ...</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_externalMessage(</li>
<li>NH_BYTE *prepend_p, NH_BYTE *message_p</li>
<li>);</li>
<li></li>
<li>NH_MAKE_RESULT nh_make_exitMessage(</li>
<li>NH_MAKE_RESULT result</li>
<li>);</li>
<li>+/**<ul>
<li>*/</li>
</ul>
</li>
<li>SM_RESULT sm_X11_createWindow(</li>
<li>NH_MAKE_RESULT nh_make_X11_createWindow(
         char *title, int width, int heigh
     );</li>
<li>SM_RESULT sm_X11_destroyWindow(</li>
<li>NH_MAKE_RESULT nh_make_X11_destroyWindow(
     );</li>
<li>SM_RESULT sm_X11_getInput(</li>
<li>NH_MAKE_RESULT nh_make_X11_getInput(
     );</li>
<li>void sm_X11_drawTextLine(</li>
<li>void nh_make_X11_drawTextLine(
         int x, int y, char *text_p
     );</li>
<li>void sm_X11_drawLine(</li>
<li>void nh_make_X11_drawLine(
        int x1, int y1, int x2, int y2
     );</li>
<li>void sm_X11_fillRectangle(</li>
<li>void nh_make_X11_fillRectangle(
        int x1, int y1, int x2, int y2
     );</li>
<li>void sm_X11_clearWindow(</li>
<li><p class="startli">void nh_make_X11_clearWindow(
     );</p>
<p class="startli">/** </p>
</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
  <!-- HTML footer for doxygen 1.8.15-->
  <!-- start footer part -->
  <div id="nav-path" class="navpath">
    <!--  -->
    <!-- <li class="footer">Generated by -->
    <!-- <a href="http://www.doxygen.org/index.html"> -->
    <!-- <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li> -->
    <div id="foot"> 
      <div style="color:#24bbc4;text-align:center;margin:auto;font-size:16px;">
        <b>
<!-- NH_MAKE_INSERT_STAGE_BEGIN -->
prototype.1
<!-- NH_MAKE_INSERT_STAGE_END -->
-
<!-- NH_MAKE_INSERT_API_VERSION_BEGIN -->
ver.0.2.3.0
<!-- NH_MAKE_INSERT_API_VERSION_END -->
-
<!-- NH_MAKE_INSERT_REVISION_BEGIN -->
rev.08400
<!-- NH_MAKE_INSERT_REVISION_END -->
          </b>
        </div>
      </div>
    </div>
  </body>
  <style>
    #foot {display: flex; padding-top:13px; padding-bottom:14px; background: #151515; border-top: 3px solid #24bbc4; justify-content: space-between;}
  </style>
</html>
