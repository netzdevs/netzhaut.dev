<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.9.2"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Netzhaut | Web Browser Engine | Patches</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="resize.js"></script>
    <script type="text/javascript" src="navtreedata.js"></script>
    <script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/searchdata.js"></script>
    <script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript">
    /* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
      $(document).ready(function() { init_search(); });
    /* @license-end */
    </script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link rel="icon" href="../../logo/favicon.png">
    <link href="../../theme/custom.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>  
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <div style="height: 56px;">
          <div style="left:10px;top:5px;position:absolute;">
            <b>Netzhaut</b>
            <br>
            <b>Web Browser Engine</b>
          </div>
          <div id="projectlogo"><img alt="netzhaut logo" src="../../logo/netzhaut.png"/></div>
          <div style="height:56px;text-align:right;right:10px;top:4px;position:absolute;">
<b>
<!-- NH_MAKE_INSERT_API_VERSION_BEGIN -->
ver.0.2.6.0
<!-- NH_MAKE_INSERT_API_VERSION_END -->
<br>
<!-- NH_MAKE_INSERT_REVISION_BEGIN -->
rev.010553
<!-- NH_MAKE_INSERT_REVISION_END -->
</b>
          </div>
        </div>
      </div>
      <div id="titlearea">
        <div class="topnav">
          <a href="../../index.html">Home</a>
          <a href="../../general/html/index.html">General</a>
          <a href="../../guides/html/index.html">Guides</a>
          <a href="../../architecture/html/index.html">Architecture</a>
          <a href="../../design/html/index.html">Design</a>
          <a href="../../internals/html/index.html">Internals</a>
          <a href="../../api/html/index.html">API</a>
          <a href="../../changelogs/html/index.html">Changelogs</a>
          <a class="active" href="../../patches/html/index.html">Patches</a>
        </div>
      </div>
    </div>
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_pages_6811cfdd57cf3fd4a0dbec076ef11a8723f5787a.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">6811cfdd57cf3fd4a0dbec076ef11a8723f5787a </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p > 

<pre>
From 6811cfdd57cf3fd4a0dbec076ef11a8723f5787a Mon Sep 17 00:00:00 2001
From: Dajo Frey &ltdajo.frey@gmail.com>
Date: Mon, 23 May 2022 23:44:57 +0200
Subject: [PATCH] Continue work on OpenGL implementation.

---
 CHANGES.txt                                   |   2 +
 build/.nhmake/options.nhmake                  |   8 +-
 build/.nhmake/source.nhmake                   |   6 +-
 external/glx/glx.h                            | 519 ++++++++++
 external/glx/glxext.h                         | 964 ++++++++++++++++++
 external/netzhaut.dev                         |   2 +-
 .../examples/x11/x11-example.c                |  71 +-
 .../simple-opengl-loader.h                    |   4 +-
 src/bin/nhmake/Changelogs.c                   |   4 +-
 src/bin/nhtty/Main.c                          |  22 +-
 src/lib/nhgfx/Base/Surface.c                  |  62 +-
 src/lib/nhgfx/Base/Viewport.c                 |  18 +-
 src/lib/nhgfx/Common/IndexMap.c               |   2 +-
 src/lib/nhgfx/Common/Initialize.c             |   5 +
 src/lib/nhgfx/Common/Terminate.c              |   2 +
 src/lib/nhgfx/Common/Types/Private.h          |  19 +-
 src/lib/nhgfx/Fonts/Text.c                    |   4 +-
 src/lib/nhgfx/OpenGL/API.c                    |  35 +-
 src/lib/nhgfx/OpenGL/API.h                    |  16 +
 src/lib/nhgfx/OpenGL/CommandBuffer.c          |  69 +-
 src/lib/nhgfx/OpenGL/CommandBuffer.h          |   8 +
 src/lib/nhgfx/OpenGL/Commands.c               | 247 ++++-
 src/lib/nhgfx/OpenGL/Data.c                   | 133 ++-
 src/lib/nhgfx/OpenGL/Data.h                   |  55 +-
 src/lib/nhgfx/OpenGL/OpenGL.c                 |  32 +
 src/lib/nhgfx/OpenGL/OpenGL.h                 |  34 +
 src/lib/nhgfx/OpenGL/Render.c                 |  67 +-
 src/lib/nhgfx/OpenGL/Render.h                 |   3 +-
 src/lib/nhgfx/OpenGL/Surface.c                |   4 +-
 src/lib/nhgfx/OpenGL/Viewport.c               | 128 +--
 src/lib/nhgfx/OpenGL/Viewport.h               |   3 +-
 src/lib/nhgfx/Vulkan/Driver.c                 |  15 +-
 src/lib/nhgfx/Vulkan/Host.h                   |   1 +
 src/lib/nhgfx/Vulkan/Render.c                 |  65 +-
 src/lib/nhgfx/Vulkan/Render.h                 |   2 +-
 src/lib/nhterminal/OpenGL/Render.c            |  56 +-
 src/lib/nhterminal/OpenGL/Text.c              | 147 +++
 src/lib/nhterminal/OpenGL/Text.h              |  48 +
 src/lib/nhterminal/Terminal/Graphics.c        |  16 +-
 src/lib/nhterminal/Terminal/Graphics.h        |  13 +-
 src/lib/nhterminal/Terminal/Terminal.c        |   2 -
 src/lib/nhwsi/Main/Window.h                   |   4 +
 src/lib/nhwsi/Platforms/X11.c                 |  12 +-
 43 files changed, 2500 insertions(+), 429 deletions(-)
 create mode 100644 CHANGES.txt
 create mode 100644 external/glx/glx.h
 create mode 100644 external/glx/glxext.h
 create mode 100644 src/lib/nhgfx/OpenGL/OpenGL.c
 create mode 100644 src/lib/nhgfx/OpenGL/OpenGL.h
 create mode 100644 src/lib/nhterminal/OpenGL/Text.c
 create mode 100644 src/lib/nhterminal/OpenGL/Text.h

diff --git a/CHANGES.txt b/CHANGES.txt
new file mode 100644
index 0000000..ef0b75e
--- /dev/null
+++ b/CHANGES.txt
@@ -0,0 +1,2 @@
+changes{date:"2021-05-23"summary:"Continue work on OpenGL implementation."workload{lib:"nhgfx","nhterminal","nhwsi"scope:"minor"}author{name:"Dajo Frey"contact:"https://github.com/dajofrey"}}
+
diff --git a/build/.nhmake/options.nhmake b/build/.nhmake/options.nhmake
index a3238f4..ecbc095 100644
--- a/build/.nhmake/options.nhmake
+++ b/build/.nhmake/options.nhmake
@@ -13,9 +13,9 @@
     system("wget -O tmp.zip https://github.com/zeux/volk/archive/master.zip")
     system("unzip -o tmp.zip")
 
-    // Download OpenGL meta loader.
-    system("wget -O tmp.zip https://github.com/tsherif/simple-opengl-loader/archive/master.zip")
-    system("unzip -o tmp.zip")
+    // Download OpenGL meta loader. Currently disabled because we made changes to it that are not in upstream.
+    // system("wget -O tmp.zip https://github.com/tsherif/simple-opengl-loader/archive/master.zip")
+    // system("unzip -o tmp.zip")
 
     // Clean downloads.
     system("rm tmp.zip")
@@ -31,6 +31,8 @@
     // Copy OpenGL related includes.
     chdir()
     copy("external/simple-opengl-loader-master/simple-opengl-loader.h", "src/lib/nhgfx/Common/OpenGL")
+    copy("external/glx/glx.h", "src/lib/nhgfx/Common/OpenGL")
+    copy("external/glx/glxext.h", "src/lib/nhgfx/Common/OpenGL")
  
     // Compile xxd.
     chdir("external/xxd")
diff --git a/build/.nhmake/source.nhmake b/build/.nhmake/source.nhmake
index f377b90..4da2c3e 100644
--- a/build/.nhmake/source.nhmake
+++ b/build/.nhmake/source.nhmake
@@ -202,9 +202,11 @@ source_lib(
         "Terminal/Grid.c"
         "Terminal/Parser.c"
         "Terminal/Graphics.c"
-        "Vulkan/Text.c"
         "Vulkan/Pipeline.c"
+        "Vulkan/Text.c"
         "Vulkan/Render.c"
+        "OpenGL/Text.c"
+        "OpenGL/Render.c"
         "Common/Result.c"
         "Common/About.c"
         "Common/Log.c"
@@ -298,6 +300,8 @@ source_lib(
         "OpenGL/API.c"
         "OpenGL/Commands.c"
         "OpenGL/Viewport.c"
+        "OpenGL/Render.c"
+        "OpenGL/OpenGL.c"
         "Fonts/FontManager.c"
         "Fonts/FontFamily.c"
         "Fonts/FontStyle.c"
diff --git a/external/glx/glx.h b/external/glx/glx.h
new file mode 100644
index 0000000..b34d2a0
--- /dev/null
+++ b/external/glx/glx.h
@@ -0,0 +1,519 @@
+/*
+ * Mesa 3-D graphics library
+ * 
+ * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+
+#ifndef GLX_H
+#define GLX_H
+
+
+#include &ltX11/Xlib.h>
+#include &ltX11/Xutil.h>
+
+// Changed by Netzhaut. {
+//#include &ltGL/gl.h>
+#include "simple-opengl-loader.h"
+// }
+
+#if defined(USE_MGL_NAMESPACE)
+#include "glx_mangle.h"
+#endif
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#define GLX_VERSION_1_1        1
+#define GLX_VERSION_1_2        1
+#define GLX_VERSION_1_3        1
+#define GLX_VERSION_1_4        1
+
+#define GLX_EXTENSION_NAME   "GLX"
+
+
+
+/*
+ * Tokens for glXChooseVisual and glXGetConfig:
+ */
+#define GLX_USE_GL     1
+#define GLX_BUFFER_SIZE        2
+#define GLX_LEVEL      3
+#define GLX_RGBA       4
+#define GLX_DOUBLEBUFFER   5
+#define GLX_STEREO     6
+#define GLX_AUX_BUFFERS        7
+#define GLX_RED_SIZE       8
+#define GLX_GREEN_SIZE     9
+#define GLX_BLUE_SIZE      10
+#define GLX_ALPHA_SIZE     11
+#define GLX_DEPTH_SIZE     12
+#define GLX_STENCIL_SIZE   13
+#define GLX_ACCUM_RED_SIZE 14
+#define GLX_ACCUM_GREEN_SIZE   15
+#define GLX_ACCUM_BLUE_SIZE    16
+#define GLX_ACCUM_ALPHA_SIZE   17
+
+
+/*
+ * Error codes returned by glXGetConfig:
+ */
+#define GLX_BAD_SCREEN     1
+#define GLX_BAD_ATTRIBUTE  2
+#define GLX_NO_EXTENSION   3
+#define GLX_BAD_VISUAL     4
+#define GLX_BAD_CONTEXT        5
+#define GLX_BAD_VALUE          6
+#define GLX_BAD_ENUM       7
+
+
+/*
+ * GLX 1.1 and later:
+ */
+#define GLX_VENDOR     1
+#define GLX_VERSION        2
+#define GLX_EXTENSIONS         3
+
+
+/*
+ * GLX 1.3 and later:
+ */
+#define GLX_CONFIG_CAVEAT      0x20
+#define GLX_DONT_CARE          0xFFFFFFFF
+#define GLX_X_VISUAL_TYPE      0x22
+#define GLX_TRANSPARENT_TYPE       0x23
+#define GLX_TRANSPARENT_INDEX_VALUE    0x24
+#define GLX_TRANSPARENT_RED_VALUE  0x25
+#define GLX_TRANSPARENT_GREEN_VALUE    0x26
+#define GLX_TRANSPARENT_BLUE_VALUE 0x27
+#define GLX_TRANSPARENT_ALPHA_VALUE    0x28
+#define GLX_WINDOW_BIT         0x00000001
+#define GLX_PIXMAP_BIT         0x00000002
+#define GLX_PBUFFER_BIT            0x00000004
+#define GLX_AUX_BUFFERS_BIT        0x00000010
+#define GLX_FRONT_LEFT_BUFFER_BIT  0x00000001
+#define GLX_FRONT_RIGHT_BUFFER_BIT 0x00000002
+#define GLX_BACK_LEFT_BUFFER_BIT   0x00000004
+#define GLX_BACK_RIGHT_BUFFER_BIT  0x00000008
+#define GLX_DEPTH_BUFFER_BIT       0x00000020
+#define GLX_STENCIL_BUFFER_BIT     0x00000040
+#define GLX_ACCUM_BUFFER_BIT       0x00000080
+#define GLX_NONE           0x8000
+#define GLX_SLOW_CONFIG            0x8001
+#define GLX_TRUE_COLOR         0x8002
+#define GLX_DIRECT_COLOR       0x8003
+#define GLX_PSEUDO_COLOR       0x8004
+#define GLX_STATIC_COLOR       0x8005
+#define GLX_GRAY_SCALE         0x8006
+#define GLX_STATIC_GRAY            0x8007
+#define GLX_TRANSPARENT_RGB        0x8008
+#define GLX_TRANSPARENT_INDEX      0x8009
+#define GLX_VISUAL_ID          0x800B
+#define GLX_SCREEN         0x800C
+#define GLX_NON_CONFORMANT_CONFIG  0x800D
+#define GLX_DRAWABLE_TYPE      0x8010
+#define GLX_RENDER_TYPE            0x8011
+#define GLX_X_RENDERABLE       0x8012
+#define GLX_FBCONFIG_ID            0x8013
+#define GLX_RGBA_TYPE          0x8014
+#define GLX_COLOR_INDEX_TYPE       0x8015
+#define GLX_MAX_PBUFFER_WIDTH      0x8016
+#define GLX_MAX_PBUFFER_HEIGHT     0x8017
+#define GLX_MAX_PBUFFER_PIXELS     0x8018
+#define GLX_PRESERVED_CONTENTS     0x801B
+#define GLX_LARGEST_PBUFFER        0x801C
+#define GLX_WIDTH          0x801D
+#define GLX_HEIGHT         0x801E
+#define GLX_EVENT_MASK         0x801F
+#define GLX_DAMAGED            0x8020
+#define GLX_SAVED          0x8021
+#define GLX_WINDOW         0x8022
+#define GLX_PBUFFER            0x8023
+#define GLX_PBUFFER_HEIGHT              0x8040
+#define GLX_PBUFFER_WIDTH               0x8041
+#define GLX_RGBA_BIT           0x00000001
+#define GLX_COLOR_INDEX_BIT        0x00000002
+#define GLX_PBUFFER_CLOBBER_MASK   0x08000000
+
+
+/*
+ * GLX 1.4 and later:
+ */
+#define GLX_SAMPLE_BUFFERS              0x186a0 /*100000*/
+#define GLX_SAMPLES                     0x186a1 /*100001*/
+
+
+
+typedef struct __GLXcontextRec *GLXContext;
+typedef XID GLXPixmap;
+typedef XID GLXDrawable;
+/* GLX 1.3 and later */
+typedef struct __GLXFBConfigRec *GLXFBConfig;
+typedef XID GLXFBConfigID;
+typedef XID GLXContextID;
+typedef XID GLXWindow;
+typedef XID GLXPbuffer;
+
+
+/*
+** Events.
+** __GLX_NUMBER_EVENTS is set to 17 to account for the BufferClobberSGIX
+**  event - this helps initialization if the server supports the pbuffer
+**  extension and the client doesn't.
+*/
+#define GLX_PbufferClobber 0
+#define GLX_BufferSwapComplete 1
+
+#define __GLX_NUMBER_EVENTS 17
+
+extern XVisualInfo* glXChooseVisual( Display *dpy, int screen,
+                    int *attribList );
+
+extern GLXContext glXCreateContext( Display *dpy, XVisualInfo *vis,
+                   GLXContext shareList, Bool direct );
+
+extern void glXDestroyContext( Display *dpy, GLXContext ctx );
+
+extern Bool glXMakeCurrent( Display *dpy, GLXDrawable drawable,
+               GLXContext ctx);
+
+extern void glXCopyContext( Display *dpy, GLXContext src, GLXContext dst,
+               unsigned long mask );
+
+extern void glXSwapBuffers( Display *dpy, GLXDrawable drawable );
+
+extern GLXPixmap glXCreateGLXPixmap( Display *dpy, XVisualInfo *visual,
+                    Pixmap pixmap );
+
+extern void glXDestroyGLXPixmap( Display *dpy, GLXPixmap pixmap );
+
+extern Bool glXQueryExtension( Display *dpy, int *errorb, int *event );
+
+extern Bool glXQueryVersion( Display *dpy, int *maj, int *min );
+
+extern Bool glXIsDirect( Display *dpy, GLXContext ctx );
+
+extern int glXGetConfig( Display *dpy, XVisualInfo *visual,
+            int attrib, int *value );
+
+extern GLXContext glXGetCurrentContext( void );
+
+extern GLXDrawable glXGetCurrentDrawable( void );
+
+extern void glXWaitGL( void );
+
+extern void glXWaitX( void );
+
+extern void glXUseXFont( Font font, int first, int count, int list );
+
+
+
+/* GLX 1.1 and later */
+extern const char *glXQueryExtensionsString( Display *dpy, int screen );
+
+extern const char *glXQueryServerString( Display *dpy, int screen, int name );
+
+extern const char *glXGetClientString( Display *dpy, int name );
+
+
+/* GLX 1.2 and later */
+extern Display *glXGetCurrentDisplay( void );
+
+
+/* GLX 1.3 and later */
+extern GLXFBConfig *glXChooseFBConfig( Display *dpy, int screen,
+                                       const int *attribList, int *nitems );
+
+extern int glXGetFBConfigAttrib( Display *dpy, GLXFBConfig config,
+                                 int attribute, int *value );
+
+extern GLXFBConfig *glXGetFBConfigs( Display *dpy, int screen,
+                                     int *nelements );
+
+extern XVisualInfo *glXGetVisualFromFBConfig( Display *dpy,
+                                              GLXFBConfig config );
+
+extern GLXWindow glXCreateWindow( Display *dpy, GLXFBConfig config,
+                                  Window win, const int *attribList );
+
+extern void glXDestroyWindow( Display *dpy, GLXWindow window );
+
+extern GLXPixmap glXCreatePixmap( Display *dpy, GLXFBConfig config,
+                                  Pixmap pixmap, const int *attribList );
+
+extern void glXDestroyPixmap( Display *dpy, GLXPixmap pixmap );
+
+extern GLXPbuffer glXCreatePbuffer( Display *dpy, GLXFBConfig config,
+                                    const int *attribList );
+
+extern void glXDestroyPbuffer( Display *dpy, GLXPbuffer pbuf );
+
+extern void glXQueryDrawable( Display *dpy, GLXDrawable draw, int attribute,
+                              unsigned int *value );
+
+extern GLXContext glXCreateNewContext( Display *dpy, GLXFBConfig config,
+                                       int renderType, GLXContext shareList,
+                                       Bool direct );
+
+extern Bool glXMakeContextCurrent( Display *dpy, GLXDrawable draw,
+                                   GLXDrawable read, GLXContext ctx );
+
+extern GLXDrawable glXGetCurrentReadDrawable( void );
+
+extern int glXQueryContext( Display *dpy, GLXContext ctx, int attribute,
+                            int *value );
+
+extern void glXSelectEvent( Display *dpy, GLXDrawable drawable,
+                            unsigned long mask );
+
+extern void glXGetSelectedEvent( Display *dpy, GLXDrawable drawable,
+                                 unsigned long *mask );
+
+/* GLX 1.3 function pointer typedefs */
+typedef GLXFBConfig * (* PFNGLXGETFBCONFIGSPROC) (Display *dpy, int screen, int *nelements);
+typedef GLXFBConfig * (* PFNGLXCHOOSEFBCONFIGPROC) (Display *dpy, int screen, const int *attrib_list, int *nelements);
+typedef int (* PFNGLXGETFBCONFIGATTRIBPROC) (Display *dpy, GLXFBConfig config, int attribute, int *value);
+typedef XVisualInfo * (* PFNGLXGETVISUALFROMFBCONFIGPROC) (Display *dpy, GLXFBConfig config);
+typedef GLXWindow (* PFNGLXCREATEWINDOWPROC) (Display *dpy, GLXFBConfig config, Window win, const int *attrib_list);
+typedef void (* PFNGLXDESTROYWINDOWPROC) (Display *dpy, GLXWindow win);
+typedef GLXPixmap (* PFNGLXCREATEPIXMAPPROC) (Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attrib_list);
+typedef void (* PFNGLXDESTROYPIXMAPPROC) (Display *dpy, GLXPixmap pixmap);
+typedef GLXPbuffer (* PFNGLXCREATEPBUFFERPROC) (Display *dpy, GLXFBConfig config, const int *attrib_list);
+typedef void (* PFNGLXDESTROYPBUFFERPROC) (Display *dpy, GLXPbuffer pbuf);
+typedef void (* PFNGLXQUERYDRAWABLEPROC) (Display *dpy, GLXDrawable draw, int attribute, unsigned int *value);
+typedef GLXContext (* PFNGLXCREATENEWCONTEXTPROC) (Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct);
+typedef Bool (* PFNGLXMAKECONTEXTCURRENTPROC) (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
+typedef GLXDrawable (* PFNGLXGETCURRENTREADDRAWABLEPROC) (void);
+typedef Display * (* PFNGLXGETCURRENTDISPLAYPROC) (void);
+typedef int (* PFNGLXQUERYCONTEXTPROC) (Display *dpy, GLXContext ctx, int attribute, int *value);
+typedef void (* PFNGLXSELECTEVENTPROC) (Display *dpy, GLXDrawable draw, unsigned long event_mask);
+typedef void (* PFNGLXGETSELECTEDEVENTPROC) (Display *dpy, GLXDrawable draw, unsigned long *event_mask);
+
+
+/*
+ * ARB 2. GLX_ARB_get_proc_address
+ */
+#ifndef GLX_ARB_get_proc_address
+#define GLX_ARB_get_proc_address 1
+
+typedef void (*__GLXextFuncPtr)(void);
+extern __GLXextFuncPtr glXGetProcAddressARB (const GLubyte *);
+
+#endif /* GLX_ARB_get_proc_address */
+
+
+
+/* GLX 1.4 and later */
+extern void (*glXGetProcAddress(const GLubyte *procname))( void );
+
+/* GLX 1.4 function pointer typedefs */
+typedef __GLXextFuncPtr (* PFNGLXGETPROCADDRESSPROC) (const GLubyte *procName);
+
+
+#ifndef GLX_GLXEXT_LEGACY
+
+// Changed by Netzhaut. {
+//#include &ltGL/glxext.h>
+#include "glxext.h"
+// }
+
+#endif /* GLX_GLXEXT_LEGACY */
+
+
+/**
+ ** The following aren't in glxext.h yet.
+ **/
+
+
+/*
+ * ???. GLX_NV_vertex_array_range
+ */
+#ifndef GLX_NV_vertex_array_range
+#define GLX_NV_vertex_array_range
+
+extern void *glXAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority);
+extern void glXFreeMemoryNV(GLvoid *pointer);
+typedef void * ( * PFNGLXALLOCATEMEMORYNVPROC) (GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority);
+typedef void ( * PFNGLXFREEMEMORYNVPROC) (GLvoid *pointer);
+
+#endif /* GLX_NV_vertex_array_range */
+
+
+/*
+ * ARB ?. GLX_ARB_render_texture
+ * XXX This was never finalized!
+ */
+#ifndef GLX_ARB_render_texture
+#define GLX_ARB_render_texture 1
+
+extern Bool glXBindTexImageARB(Display *dpy, GLXPbuffer pbuffer, int buffer);
+extern Bool glXReleaseTexImageARB(Display *dpy, GLXPbuffer pbuffer, int buffer);
+extern Bool glXDrawableAttribARB(Display *dpy, GLXDrawable draw, const int *attribList);
+
+#endif /* GLX_ARB_render_texture */
+
+
+/*
+ * Remove this when glxext.h is updated.
+ */
+#ifndef GLX_NV_float_buffer
+#define GLX_NV_float_buffer 1
+
+#define GLX_FLOAT_COMPONENTS_NV         0x20B0
+
+#endif /* GLX_NV_float_buffer */
+
+
+
+/*
+ * #?. GLX_MESA_swap_frame_usage
+ */
+#ifndef GLX_MESA_swap_frame_usage
+#define GLX_MESA_swap_frame_usage 1
+
+extern int glXGetFrameUsageMESA(Display *dpy, GLXDrawable drawable, float *usage);
+extern int glXBeginFrameTrackingMESA(Display *dpy, GLXDrawable drawable);
+extern int glXEndFrameTrackingMESA(Display *dpy, GLXDrawable drawable);
+extern int glXQueryFrameTrackingMESA(Display *dpy, GLXDrawable drawable, int64_t *swapCount, int64_t *missedFrames, float *lastMissedUsage);
+
+typedef int (*PFNGLXGETFRAMEUSAGEMESAPROC) (Display *dpy, GLXDrawable drawable, float *usage);
+typedef int (*PFNGLXBEGINFRAMETRACKINGMESAPROC)(Display *dpy, GLXDrawable drawable);
+typedef int (*PFNGLXENDFRAMETRACKINGMESAPROC)(Display *dpy, GLXDrawable drawable);
+typedef int (*PFNGLXQUERYFRAMETRACKINGMESAPROC)(Display *dpy, GLXDrawable drawable, int64_t *swapCount, int64_t *missedFrames, float *lastMissedUsage);
+
+#endif /* GLX_MESA_swap_frame_usage */
+
+
+
+/*
+ * #?. GLX_MESA_swap_control
+ */
+#ifndef GLX_MESA_swap_control
+#define GLX_MESA_swap_control 1
+
+extern int glXSwapIntervalMESA(unsigned int interval);
+extern int glXGetSwapIntervalMESA(void);
+
+typedef int (*PFNGLXSWAPINTERVALMESAPROC)(unsigned int interval);
+typedef int (*PFNGLXGETSWAPINTERVALMESAPROC)(void);
+
+#endif /* GLX_MESA_swap_control */
+
+
+
+/*
+ * #?. GLX_EXT_texture_from_pixmap
+ * XXX not finished?
+ */
+#ifndef GLX_EXT_texture_from_pixmap
+#define GLX_EXT_texture_from_pixmap 1
+
+#define GLX_BIND_TO_TEXTURE_RGB_EXT        0x20D0
+#define GLX_BIND_TO_TEXTURE_RGBA_EXT       0x20D1
+#define GLX_BIND_TO_MIPMAP_TEXTURE_EXT     0x20D2
+#define GLX_BIND_TO_TEXTURE_TARGETS_EXT    0x20D3
+#define GLX_Y_INVERTED_EXT                 0x20D4
+
+#define GLX_TEXTURE_FORMAT_EXT             0x20D5
+#define GLX_TEXTURE_TARGET_EXT             0x20D6
+#define GLX_MIPMAP_TEXTURE_EXT             0x20D7
+
+#define GLX_TEXTURE_FORMAT_NONE_EXT        0x20D8
+#define GLX_TEXTURE_FORMAT_RGB_EXT         0x20D9
+#define GLX_TEXTURE_FORMAT_RGBA_EXT        0x20DA
+
+#define GLX_TEXTURE_1D_BIT_EXT             0x00000001
+#define GLX_TEXTURE_2D_BIT_EXT             0x00000002
+#define GLX_TEXTURE_RECTANGLE_BIT_EXT      0x00000004
+
+#define GLX_TEXTURE_1D_EXT                 0x20DB
+#define GLX_TEXTURE_2D_EXT                 0x20DC
+#define GLX_TEXTURE_RECTANGLE_EXT          0x20DD
+
+#define GLX_FRONT_LEFT_EXT                 0x20DE
+#define GLX_FRONT_RIGHT_EXT                0x20DF
+#define GLX_BACK_LEFT_EXT                  0x20E0
+#define GLX_BACK_RIGHT_EXT                 0x20E1
+#define GLX_FRONT_EXT                      GLX_FRONT_LEFT_EXT
+#define GLX_BACK_EXT                       GLX_BACK_LEFT_EXT
+#define GLX_AUX0_EXT                       0x20E2
+#define GLX_AUX1_EXT                       0x20E3 
+#define GLX_AUX2_EXT                       0x20E4 
+#define GLX_AUX3_EXT                       0x20E5 
+#define GLX_AUX4_EXT                       0x20E6 
+#define GLX_AUX5_EXT                       0x20E7 
+#define GLX_AUX6_EXT                       0x20E8
+#define GLX_AUX7_EXT                       0x20E9 
+#define GLX_AUX8_EXT                       0x20EA 
+#define GLX_AUX9_EXT                       0x20EB
+
+extern void glXBindTexImageEXT(Display *dpy, GLXDrawable drawable, int buffer, const int *attrib_list);
+extern void glXReleaseTexImageEXT(Display *dpy, GLXDrawable drawable, int buffer);
+
+#endif /* GLX_EXT_texture_from_pixmap */
+
+
+
+
+/*** Should these go here, or in another header? */
+/*
+** GLX Events
+*/
+typedef struct {
+    int event_type;        /* GLX_DAMAGED or GLX_SAVED */
+    int draw_type;     /* GLX_WINDOW or GLX_PBUFFER */
+    unsigned long serial;  /* # of last request processed by server */
+    Bool send_event;       /* true if this came for SendEvent request */
+    Display *display;      /* display the event was read from */
+    GLXDrawable drawable;  /* XID of Drawable */
+    unsigned int buffer_mask;  /* mask indicating which buffers are affected */
+    unsigned int aux_buffer;   /* which aux buffer was affected */
+    int x, y;
+    int width, height;
+    int count;         /* if nonzero, at least this many more */
+} GLXPbufferClobberEvent;
+
+typedef struct {
+    int type;
+    unsigned long serial;  /* # of last request processed by server */
+    Bool send_event;       /* true if this came from a SendEvent request */
+    Display *display;      /* Display the event was read from */
+    GLXDrawable drawable;  /* drawable on which event was requested in event mask */
+    int event_type;
+    int64_t ust;
+    int64_t msc;
+    int64_t sbc;
+} GLXBufferSwapComplete;
+
+typedef union __GLXEvent {
+    GLXPbufferClobberEvent glxpbufferclobber;
+    GLXBufferSwapComplete glxbufferswapcomplete;
+    long pad[24];
+} GLXEvent;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/external/glx/glxext.h b/external/glx/glxext.h
new file mode 100644
index 0000000..b5d21be
--- /dev/null
+++ b/external/glx/glxext.h
@@ -0,0 +1,964 @@
+#ifndef __glx_glxext_h_
+#define __glx_glxext_h_ 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+** Copyright (c) 2013-2018 The Khronos Group Inc.
+**
+** Permission is hereby granted, free of charge, to any person obtaining a
+** copy of this software and/or associated documentation files (the
+** "Materials"), to deal in the Materials without restriction, including
+** without limitation the rights to use, copy, modify, merge, publish,
+** distribute, sublicense, and/or sell copies of the Materials, and to
+** permit persons to whom the Materials are furnished to do so, subject to
+** the following conditions:
+**
+** The above copyright notice and this permission notice shall be included
+** in all copies or substantial portions of the Materials.
+**
+** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
+*/
+/*
+** This header is generated from the Khronos OpenGL / OpenGL ES XML
+** API Registry. The current version of the Registry, generator scripts
+** used to make the header, and the header can be found at
+**   https://github.com/KhronosGroup/OpenGL-Registry
+*/
+
+#define GLX_GLXEXT_VERSION 20190728
+
+/* Generated C header for:
+ * API: glx
+ * Versions considered: .*
+ * Versions emitted: 1\.[3-9]
+ * Default extensions included: glx
+ * Additional extensions included: _nomatch_^
+ * Extensions removed: _nomatch_^
+ */
+
+// Changed by Netzhaut. {
+#include "../OpenGL/simple-opengl-loader.h"
+// }
+
+#ifndef GLX_VERSION_1_3
+#define GLX_VERSION_1_3 1
+typedef XID GLXContextID;
+typedef struct __GLXFBConfigRec *GLXFBConfig;
+typedef XID GLXWindow;
+typedef XID GLXPbuffer;
+#define GLX_WINDOW_BIT                    0x00000001
+#define GLX_PIXMAP_BIT                    0x00000002
+#define GLX_PBUFFER_BIT                   0x00000004
+#define GLX_RGBA_BIT                      0x00000001
+#define GLX_COLOR_INDEX_BIT               0x00000002
+#define GLX_PBUFFER_CLOBBER_MASK          0x08000000
+#define GLX_FRONT_LEFT_BUFFER_BIT         0x00000001
+#define GLX_FRONT_RIGHT_BUFFER_BIT        0x00000002
+#define GLX_BACK_LEFT_BUFFER_BIT          0x00000004
+#define GLX_BACK_RIGHT_BUFFER_BIT         0x00000008
+#define GLX_AUX_BUFFERS_BIT               0x00000010
+#define GLX_DEPTH_BUFFER_BIT              0x00000020
+#define GLX_STENCIL_BUFFER_BIT            0x00000040
+#define GLX_ACCUM_BUFFER_BIT              0x00000080
+#define GLX_CONFIG_CAVEAT                 0x20
+#define GLX_X_VISUAL_TYPE                 0x22
+#define GLX_TRANSPARENT_TYPE              0x23
+#define GLX_TRANSPARENT_INDEX_VALUE       0x24
+#define GLX_TRANSPARENT_RED_VALUE         0x25
+#define GLX_TRANSPARENT_GREEN_VALUE       0x26
+#define GLX_TRANSPARENT_BLUE_VALUE        0x27
+#define GLX_TRANSPARENT_ALPHA_VALUE       0x28
+#define GLX_DONT_CARE                     0xFFFFFFFF
+#define GLX_NONE                          0x8000
+#define GLX_SLOW_CONFIG                   0x8001
+#define GLX_TRUE_COLOR                    0x8002
+#define GLX_DIRECT_COLOR                  0x8003
+#define GLX_PSEUDO_COLOR                  0x8004
+#define GLX_STATIC_COLOR                  0x8005
+#define GLX_GRAY_SCALE                    0x8006
+#define GLX_STATIC_GRAY                   0x8007
+#define GLX_TRANSPARENT_RGB               0x8008
+#define GLX_TRANSPARENT_INDEX             0x8009
+#define GLX_VISUAL_ID                     0x800B
+#define GLX_SCREEN                        0x800C
+#define GLX_NON_CONFORMANT_CONFIG         0x800D
+#define GLX_DRAWABLE_TYPE                 0x8010
+#define GLX_RENDER_TYPE                   0x8011
+#define GLX_X_RENDERABLE                  0x8012
+#define GLX_FBCONFIG_ID                   0x8013
+#define GLX_RGBA_TYPE                     0x8014
+#define GLX_COLOR_INDEX_TYPE              0x8015
+#define GLX_MAX_PBUFFER_WIDTH             0x8016
+#define GLX_MAX_PBUFFER_HEIGHT            0x8017
+#define GLX_MAX_PBUFFER_PIXELS            0x8018
+#define GLX_PRESERVED_CONTENTS            0x801B
+#define GLX_LARGEST_PBUFFER               0x801C
+#define GLX_WIDTH                         0x801D
+#define GLX_HEIGHT                        0x801E
+#define GLX_EVENT_MASK                    0x801F
+#define GLX_DAMAGED                       0x8020
+#define GLX_SAVED                         0x8021
+#define GLX_WINDOW                        0x8022
+#define GLX_PBUFFER                       0x8023
+#define GLX_PBUFFER_HEIGHT                0x8040
+#define GLX_PBUFFER_WIDTH                 0x8041
+typedef GLXFBConfig *( *PFNGLXGETFBCONFIGSPROC) (Display *dpy, int screen, int *nelements);
+typedef GLXFBConfig *( *PFNGLXCHOOSEFBCONFIGPROC) (Display *dpy, int screen, const int *attrib_list, int *nelements);
+typedef int ( *PFNGLXGETFBCONFIGATTRIBPROC) (Display *dpy, GLXFBConfig config, int attribute, int *value);
+typedef XVisualInfo *( *PFNGLXGETVISUALFROMFBCONFIGPROC) (Display *dpy, GLXFBConfig config);
+typedef GLXWindow ( *PFNGLXCREATEWINDOWPROC) (Display *dpy, GLXFBConfig config, Window win, const int *attrib_list);
+typedef void ( *PFNGLXDESTROYWINDOWPROC) (Display *dpy, GLXWindow win);
+typedef GLXPixmap ( *PFNGLXCREATEPIXMAPPROC) (Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attrib_list);
+typedef void ( *PFNGLXDESTROYPIXMAPPROC) (Display *dpy, GLXPixmap pixmap);
+typedef GLXPbuffer ( *PFNGLXCREATEPBUFFERPROC) (Display *dpy, GLXFBConfig config, const int *attrib_list);
+typedef void ( *PFNGLXDESTROYPBUFFERPROC) (Display *dpy, GLXPbuffer pbuf);
+typedef void ( *PFNGLXQUERYDRAWABLEPROC) (Display *dpy, GLXDrawable draw, int attribute, unsigned int *value);
+typedef GLXContext ( *PFNGLXCREATENEWCONTEXTPROC) (Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct);
+typedef Bool ( *PFNGLXMAKECONTEXTCURRENTPROC) (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
+typedef GLXDrawable ( *PFNGLXGETCURRENTREADDRAWABLEPROC) (void);
+typedef int ( *PFNGLXQUERYCONTEXTPROC) (Display *dpy, GLXContext ctx, int attribute, int *value);
+typedef void ( *PFNGLXSELECTEVENTPROC) (Display *dpy, GLXDrawable draw, unsigned long event_mask);
+typedef void ( *PFNGLXGETSELECTEDEVENTPROC) (Display *dpy, GLXDrawable draw, unsigned long *event_mask);
+#ifdef GLX_GLXEXT_PROTOTYPES
+GLXFBConfig *glXGetFBConfigs (Display *dpy, int screen, int *nelements);
+GLXFBConfig *glXChooseFBConfig (Display *dpy, int screen, const int *attrib_list, int *nelements);
+int glXGetFBConfigAttrib (Display *dpy, GLXFBConfig config, int attribute, int *value);
+XVisualInfo *glXGetVisualFromFBConfig (Display *dpy, GLXFBConfig config);
+GLXWindow glXCreateWindow (Display *dpy, GLXFBConfig config, Window win, const int *attrib_list);
+void glXDestroyWindow (Display *dpy, GLXWindow win);
+GLXPixmap glXCreatePixmap (Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attrib_list);
+void glXDestroyPixmap (Display *dpy, GLXPixmap pixmap);
+GLXPbuffer glXCreatePbuffer (Display *dpy, GLXFBConfig config, const int *attrib_list);
+void glXDestroyPbuffer (Display *dpy, GLXPbuffer pbuf);
+void glXQueryDrawable (Display *dpy, GLXDrawable draw, int attribute, unsigned int *value);
+GLXContext glXCreateNewContext (Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct);
+Bool glXMakeContextCurrent (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
+GLXDrawable glXGetCurrentReadDrawable (void);
+int glXQueryContext (Display *dpy, GLXContext ctx, int attribute, int *value);
+void glXSelectEvent (Display *dpy, GLXDrawable draw, unsigned long event_mask);
+void glXGetSelectedEvent (Display *dpy, GLXDrawable draw, unsigned long *event_mask);
+#endif
+#endif /* GLX_VERSION_1_3 */
+
+#ifndef GLX_VERSION_1_4
+#define GLX_VERSION_1_4 1
+typedef void ( *__GLXextFuncPtr)(void);
+#define GLX_SAMPLE_BUFFERS                100000
+#define GLX_SAMPLES                       100001
+typedef __GLXextFuncPtr ( *PFNGLXGETPROCADDRESSPROC) (const GLubyte *procName);
+#ifdef GLX_GLXEXT_PROTOTYPES
+__GLXextFuncPtr glXGetProcAddress (const GLubyte *procName);
+#endif
+#endif /* GLX_VERSION_1_4 */
+
+#ifndef GLX_ARB_context_flush_control
+#define GLX_ARB_context_flush_control 1
+#define GLX_CONTEXT_RELEASE_BEHAVIOR_ARB  0x2097
+#define GLX_CONTEXT_RELEASE_BEHAVIOR_NONE_ARB 0
+#define GLX_CONTEXT_RELEASE_BEHAVIOR_FLUSH_ARB 0x2098
+#endif /* GLX_ARB_context_flush_control */
+
+#ifndef GLX_ARB_create_context
+#define GLX_ARB_create_context 1
+#define GLX_CONTEXT_DEBUG_BIT_ARB         0x00000001
+#define GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB 0x00000002
+#define GLX_CONTEXT_MAJOR_VERSION_ARB     0x2091
+#define GLX_CONTEXT_MINOR_VERSION_ARB     0x2092
+#define GLX_CONTEXT_FLAGS_ARB             0x2094
+typedef GLXContext ( *PFNGLXCREATECONTEXTATTRIBSARBPROC) (Display *dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *attrib_list);
+#ifdef GLX_GLXEXT_PROTOTYPES
+GLXContext glXCreateContextAttribsARB (Display *dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *attrib_list);
+#endif
+#endif /* GLX_ARB_create_context */
+
+#ifndef GLX_ARB_create_context_no_error
+#define GLX_ARB_create_context_no_error 1
+#define GLX_CONTEXT_OPENGL_NO_ERROR_ARB   0x31B3
+#endif /* GLX_ARB_create_context_no_error */
+
+#ifndef GLX_ARB_create_context_profile
+#define GLX_ARB_create_context_profile 1
+#define GLX_CONTEXT_CORE_PROFILE_BIT_ARB  0x00000001
+#define GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB 0x00000002
+#define GLX_CONTEXT_PROFILE_MASK_ARB      0x9126
+#endif /* GLX_ARB_create_context_profile */
+
+#ifndef GLX_ARB_create_context_robustness
+#define GLX_ARB_create_context_robustness 1
+#define GLX_CONTEXT_ROBUST_ACCESS_BIT_ARB 0x00000004
+#define GLX_LOSE_CONTEXT_ON_RESET_ARB     0x8252
+#define GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB 0x8256
+#define GLX_NO_RESET_NOTIFICATION_ARB     0x8261
+#endif /* GLX_ARB_create_context_robustness */
+
+#ifndef GLX_ARB_fbconfig_float
+#define GLX_ARB_fbconfig_float 1
+#define GLX_RGBA_FLOAT_TYPE_ARB           0x20B9
+#define GLX_RGBA_FLOAT_BIT_ARB            0x00000004
+#endif /* GLX_ARB_fbconfig_float */
+
+#ifndef GLX_ARB_framebuffer_sRGB
+#define GLX_ARB_framebuffer_sRGB 1
+#define GLX_FRAMEBUFFER_SRGB_CAPABLE_ARB  0x20B2
+#endif /* GLX_ARB_framebuffer_sRGB */
+
+#ifndef GLX_ARB_get_proc_address
+#define GLX_ARB_get_proc_address 1
+typedef __GLXextFuncPtr ( *PFNGLXGETPROCADDRESSARBPROC) (const GLubyte *procName);
+#ifdef GLX_GLXEXT_PROTOTYPES
+__GLXextFuncPtr glXGetProcAddressARB (const GLubyte *procName);
+#endif
+#endif /* GLX_ARB_get_proc_address */
+
+#ifndef GLX_ARB_multisample
+#define GLX_ARB_multisample 1
+#define GLX_SAMPLE_BUFFERS_ARB            100000
+#define GLX_SAMPLES_ARB                   100001
+#endif /* GLX_ARB_multisample */
+
+#ifndef GLX_ARB_robustness_application_isolation
+#define GLX_ARB_robustness_application_isolation 1
+#define GLX_CONTEXT_RESET_ISOLATION_BIT_ARB 0x00000008
+#endif /* GLX_ARB_robustness_application_isolation */
+
+#ifndef GLX_ARB_robustness_share_group_isolation
+#define GLX_ARB_robustness_share_group_isolation 1
+#endif /* GLX_ARB_robustness_share_group_isolation */
+
+#ifndef GLX_ARB_vertex_buffer_object
+#define GLX_ARB_vertex_buffer_object 1
+#define GLX_CONTEXT_ALLOW_BUFFER_BYTE_ORDER_MISMATCH_ARB 0x2095
+#endif /* GLX_ARB_vertex_buffer_object */
+
+#ifndef GLX_3DFX_multisample
+#define GLX_3DFX_multisample 1
+#define GLX_SAMPLE_BUFFERS_3DFX           0x8050
+#define GLX_SAMPLES_3DFX                  0x8051
+#endif /* GLX_3DFX_multisample */
+
+#ifndef GLX_AMD_gpu_association
+#define GLX_AMD_gpu_association 1
+#define GLX_GPU_VENDOR_AMD                0x1F00
+#define GLX_GPU_RENDERER_STRING_AMD       0x1F01
+#define GLX_GPU_OPENGL_VERSION_STRING_AMD 0x1F02
+#define GLX_GPU_FASTEST_TARGET_GPUS_AMD   0x21A2
+#define GLX_GPU_RAM_AMD                   0x21A3
+#define GLX_GPU_CLOCK_AMD                 0x21A4
+#define GLX_GPU_NUM_PIPES_AMD             0x21A5
+#define GLX_GPU_NUM_SIMD_AMD              0x21A6
+#define GLX_GPU_NUM_RB_AMD                0x21A7
+#define GLX_GPU_NUM_SPI_AMD               0x21A8
+typedef unsigned int ( *PFNGLXGETGPUIDSAMDPROC) (unsigned int maxCount, unsigned int *ids);
+typedef int ( *PFNGLXGETGPUINFOAMDPROC) (unsigned int id, int property, GLenum dataType, unsigned int size, void *data);
+typedef unsigned int ( *PFNGLXGETCONTEXTGPUIDAMDPROC) (GLXContext ctx);
+typedef GLXContext ( *PFNGLXCREATEASSOCIATEDCONTEXTAMDPROC) (unsigned int id, GLXContext share_list);
+typedef GLXContext ( *PFNGLXCREATEASSOCIATEDCONTEXTATTRIBSAMDPROC) (unsigned int id, GLXContext share_context, const int *attribList);
+typedef Bool ( *PFNGLXDELETEASSOCIATEDCONTEXTAMDPROC) (GLXContext ctx);
+typedef Bool ( *PFNGLXMAKEASSOCIATEDCONTEXTCURRENTAMDPROC) (GLXContext ctx);
+typedef GLXContext ( *PFNGLXGETCURRENTASSOCIATEDCONTEXTAMDPROC) (void);
+typedef void ( *PFNGLXBLITCONTEXTFRAMEBUFFERAMDPROC) (GLXContext dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
+#ifdef GLX_GLXEXT_PROTOTYPES
+unsigned int glXGetGPUIDsAMD (unsigned int maxCount, unsigned int *ids);
+int glXGetGPUInfoAMD (unsigned int id, int property, GLenum dataType, unsigned int size, void *data);
+unsigned int glXGetContextGPUIDAMD (GLXContext ctx);
+GLXContext glXCreateAssociatedContextAMD (unsigned int id, GLXContext share_list);
+GLXContext glXCreateAssociatedContextAttribsAMD (unsigned int id, GLXContext share_context, const int *attribList);
+Bool glXDeleteAssociatedContextAMD (GLXContext ctx);
+Bool glXMakeAssociatedContextCurrentAMD (GLXContext ctx);
+GLXContext glXGetCurrentAssociatedContextAMD (void);
+void glXBlitContextFramebufferAMD (GLXContext dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
+#endif
+#endif /* GLX_AMD_gpu_association */
+
+#ifndef GLX_EXT_buffer_age
+#define GLX_EXT_buffer_age 1
+#define GLX_BACK_BUFFER_AGE_EXT           0x20F4
+#endif /* GLX_EXT_buffer_age */
+
+#ifndef GLX_EXT_context_priority
+#define GLX_EXT_context_priority 1
+#define GLX_CONTEXT_PRIORITY_LEVEL_EXT    0x3100
+#define GLX_CONTEXT_PRIORITY_HIGH_EXT     0x3101
+#define GLX_CONTEXT_PRIORITY_MEDIUM_EXT   0x3102
+#define GLX_CONTEXT_PRIORITY_LOW_EXT      0x3103
+#endif /* GLX_EXT_context_priority */
+
+#ifndef GLX_EXT_create_context_es2_profile
+#define GLX_EXT_create_context_es2_profile 1
+#define GLX_CONTEXT_ES2_PROFILE_BIT_EXT   0x00000004
+#endif /* GLX_EXT_create_context_es2_profile */
+
+#ifndef GLX_EXT_create_context_es_profile
+#define GLX_EXT_create_context_es_profile 1
+#define GLX_CONTEXT_ES_PROFILE_BIT_EXT    0x00000004
+#endif /* GLX_EXT_create_context_es_profile */
+
+#ifndef GLX_EXT_fbconfig_packed_float
+#define GLX_EXT_fbconfig_packed_float 1
+#define GLX_RGBA_UNSIGNED_FLOAT_TYPE_EXT  0x20B1
+#define GLX_RGBA_UNSIGNED_FLOAT_BIT_EXT   0x00000008
+#endif /* GLX_EXT_fbconfig_packed_float */
+
+#ifndef GLX_EXT_framebuffer_sRGB
+#define GLX_EXT_framebuffer_sRGB 1
+#define GLX_FRAMEBUFFER_SRGB_CAPABLE_EXT  0x20B2
+#endif /* GLX_EXT_framebuffer_sRGB */
+
+#ifndef GLX_EXT_import_context
+#define GLX_EXT_import_context 1
+#define GLX_SHARE_CONTEXT_EXT             0x800A
+#define GLX_VISUAL_ID_EXT                 0x800B
+#define GLX_SCREEN_EXT                    0x800C
+typedef Display *( *PFNGLXGETCURRENTDISPLAYEXTPROC) (void);
+typedef int ( *PFNGLXQUERYCONTEXTINFOEXTPROC) (Display *dpy, GLXContext context, int attribute, int *value);
+typedef GLXContextID ( *PFNGLXGETCONTEXTIDEXTPROC) (const GLXContext context);
+typedef GLXContext ( *PFNGLXIMPORTCONTEXTEXTPROC) (Display *dpy, GLXContextID contextID);
+typedef void ( *PFNGLXFREECONTEXTEXTPROC) (Display *dpy, GLXContext context);
+#ifdef GLX_GLXEXT_PROTOTYPES
+Display *glXGetCurrentDisplayEXT (void);
+int glXQueryContextInfoEXT (Display *dpy, GLXContext context, int attribute, int *value);
+GLXContextID glXGetContextIDEXT (const GLXContext context);
+GLXContext glXImportContextEXT (Display *dpy, GLXContextID contextID);
+void glXFreeContextEXT (Display *dpy, GLXContext context);
+#endif
+#endif /* GLX_EXT_import_context */
+
+#ifndef GLX_EXT_libglvnd
+#define GLX_EXT_libglvnd 1
+#define GLX_VENDOR_NAMES_EXT              0x20F6
+#endif /* GLX_EXT_libglvnd */
+
+#ifndef GLX_EXT_no_config_context
+#define GLX_EXT_no_config_context 1
+#endif /* GLX_EXT_no_config_context */
+
+#ifndef GLX_EXT_stereo_tree
+#define GLX_EXT_stereo_tree 1
+typedef struct {
+    int type;
+    unsigned long serial;
+    Bool send_event;
+    Display *display;
+    int extension;
+    int evtype;
+    GLXDrawable window;
+    Bool stereo_tree;
+} GLXStereoNotifyEventEXT;
+#define GLX_STEREO_TREE_EXT               0x20F5
+#define GLX_STEREO_NOTIFY_MASK_EXT        0x00000001
+#define GLX_STEREO_NOTIFY_EXT             0x00000000
+#endif /* GLX_EXT_stereo_tree */
+
+#ifndef GLX_EXT_swap_control
+#define GLX_EXT_swap_control 1
+#define GLX_SWAP_INTERVAL_EXT             0x20F1
+#define GLX_MAX_SWAP_INTERVAL_EXT         0x20F2
+typedef void ( *PFNGLXSWAPINTERVALEXTPROC) (Display *dpy, GLXDrawable drawable, int interval);
+#ifdef GLX_GLXEXT_PROTOTYPES
+void glXSwapIntervalEXT (Display *dpy, GLXDrawable drawable, int interval);
+#endif
+#endif /* GLX_EXT_swap_control */
+
+#ifndef GLX_EXT_swap_control_tear
+#define GLX_EXT_swap_control_tear 1
+#define GLX_LATE_SWAPS_TEAR_EXT           0x20F3
+#endif /* GLX_EXT_swap_control_tear */
+
+#ifndef GLX_EXT_texture_from_pixmap
+#define GLX_EXT_texture_from_pixmap 1
+#define GLX_TEXTURE_1D_BIT_EXT            0x00000001
+#define GLX_TEXTURE_2D_BIT_EXT            0x00000002
+#define GLX_TEXTURE_RECTANGLE_BIT_EXT     0x00000004
+#define GLX_BIND_TO_TEXTURE_RGB_EXT       0x20D0
+#define GLX_BIND_TO_TEXTURE_RGBA_EXT      0x20D1
+#define GLX_BIND_TO_MIPMAP_TEXTURE_EXT    0x20D2
+#define GLX_BIND_TO_TEXTURE_TARGETS_EXT   0x20D3
+#define GLX_Y_INVERTED_EXT                0x20D4
+#define GLX_TEXTURE_FORMAT_EXT            0x20D5
+#define GLX_TEXTURE_TARGET_EXT            0x20D6
+#define GLX_MIPMAP_TEXTURE_EXT            0x20D7
+#define GLX_TEXTURE_FORMAT_NONE_EXT       0x20D8
+#define GLX_TEXTURE_FORMAT_RGB_EXT        0x20D9
+#define GLX_TEXTURE_FORMAT_RGBA_EXT       0x20DA
+#define GLX_TEXTURE_1D_EXT                0x20DB
+#define GLX_TEXTURE_2D_EXT                0x20DC
+#define GLX_TEXTURE_RECTANGLE_EXT         0x20DD
+#define GLX_FRONT_LEFT_EXT                0x20DE
+#define GLX_FRONT_RIGHT_EXT               0x20DF
+#define GLX_BACK_LEFT_EXT                 0x20E0
+#define GLX_BACK_RIGHT_EXT                0x20E1
+#define GLX_FRONT_EXT                     0x20DE
+#define GLX_BACK_EXT                      0x20E0
+#define GLX_AUX0_EXT                      0x20E2
+#define GLX_AUX1_EXT                      0x20E3
+#define GLX_AUX2_EXT                      0x20E4
+#define GLX_AUX3_EXT                      0x20E5
+#define GLX_AUX4_EXT                      0x20E6
+#define GLX_AUX5_EXT                      0x20E7
+#define GLX_AUX6_EXT                      0x20E8
+#define GLX_AUX7_EXT                      0x20E9
+#define GLX_AUX8_EXT                      0x20EA
+#define GLX_AUX9_EXT                      0x20EB
+typedef void ( *PFNGLXBINDTEXIMAGEEXTPROC) (Display *dpy, GLXDrawable drawable, int buffer, const int *attrib_list);
+typedef void ( *PFNGLXRELEASETEXIMAGEEXTPROC) (Display *dpy, GLXDrawable drawable, int buffer);
+#ifdef GLX_GLXEXT_PROTOTYPES
+void glXBindTexImageEXT (Display *dpy, GLXDrawable drawable, int buffer, const int *attrib_list);
+void glXReleaseTexImageEXT (Display *dpy, GLXDrawable drawable, int buffer);
+#endif
+#endif /* GLX_EXT_texture_from_pixmap */
+
+#ifndef GLX_EXT_visual_info
+#define GLX_EXT_visual_info 1
+#define GLX_X_VISUAL_TYPE_EXT             0x22
+#define GLX_TRANSPARENT_TYPE_EXT          0x23
+#define GLX_TRANSPARENT_INDEX_VALUE_EXT   0x24
+#define GLX_TRANSPARENT_RED_VALUE_EXT     0x25
+#define GLX_TRANSPARENT_GREEN_VALUE_EXT   0x26
+#define GLX_TRANSPARENT_BLUE_VALUE_EXT    0x27
+#define GLX_TRANSPARENT_ALPHA_VALUE_EXT   0x28
+#define GLX_NONE_EXT                      0x8000
+#define GLX_TRUE_COLOR_EXT                0x8002
+#define GLX_DIRECT_COLOR_EXT              0x8003
+#define GLX_PSEUDO_COLOR_EXT              0x8004
+#define GLX_STATIC_COLOR_EXT              0x8005
+#define GLX_GRAY_SCALE_EXT                0x8006
+#define GLX_STATIC_GRAY_EXT               0x8007
+#define GLX_TRANSPARENT_RGB_EXT           0x8008
+#define GLX_TRANSPARENT_INDEX_EXT         0x8009
+#endif /* GLX_EXT_visual_info */
+
+#ifndef GLX_EXT_visual_rating
+#define GLX_EXT_visual_rating 1
+#define GLX_VISUAL_CAVEAT_EXT             0x20
+#define GLX_SLOW_VISUAL_EXT               0x8001
+#define GLX_NON_CONFORMANT_VISUAL_EXT     0x800D
+#endif /* GLX_EXT_visual_rating */
+
+#ifndef GLX_INTEL_swap_event
+#define GLX_INTEL_swap_event 1
+#define GLX_BUFFER_SWAP_COMPLETE_INTEL_MASK 0x04000000
+#define GLX_EXCHANGE_COMPLETE_INTEL       0x8180
+#define GLX_COPY_COMPLETE_INTEL           0x8181
+#define GLX_FLIP_COMPLETE_INTEL           0x8182
+#endif /* GLX_INTEL_swap_event */
+
+#ifndef GLX_MESA_agp_offset
+#define GLX_MESA_agp_offset 1
+typedef unsigned int ( *PFNGLXGETAGPOFFSETMESAPROC) (const void *pointer);
+#ifdef GLX_GLXEXT_PROTOTYPES
+unsigned int glXGetAGPOffsetMESA (const void *pointer);
+#endif
+#endif /* GLX_MESA_agp_offset */
+
+#ifndef GLX_MESA_copy_sub_buffer
+#define GLX_MESA_copy_sub_buffer 1
+typedef void ( *PFNGLXCOPYSUBBUFFERMESAPROC) (Display *dpy, GLXDrawable drawable, int x, int y, int width, int height);
+#ifdef GLX_GLXEXT_PROTOTYPES
+void glXCopySubBufferMESA (Display *dpy, GLXDrawable drawable, int x, int y, int width, int height);
+#endif
+#endif /* GLX_MESA_copy_sub_buffer */
+
+#ifndef GLX_MESA_pixmap_colormap
+#define GLX_MESA_pixmap_colormap 1
+typedef GLXPixmap ( *PFNGLXCREATEGLXPIXMAPMESAPROC) (Display *dpy, XVisualInfo *visual, Pixmap pixmap, Colormap cmap);
+#ifdef GLX_GLXEXT_PROTOTYPES
+GLXPixmap glXCreateGLXPixmapMESA (Display *dpy, XVisualInfo *visual, Pixmap pixmap, Colormap cmap);
+#endif
+#endif /* GLX_MESA_pixmap_colormap */
+
+#ifndef GLX_MESA_query_renderer
+#define GLX_MESA_query_renderer 1
+#define GLX_RENDERER_VENDOR_ID_MESA       0x8183
+#define GLX_RENDERER_DEVICE_ID_MESA       0x8184
+#define GLX_RENDERER_VERSION_MESA         0x8185
+#define GLX_RENDERER_ACCELERATED_MESA     0x8186
+#define GLX_RENDERER_VIDEO_MEMORY_MESA    0x8187
+#define GLX_RENDERER_UNIFIED_MEMORY_ARCHITECTURE_MESA 0x8188
+#define GLX_RENDERER_PREFERRED_PROFILE_MESA 0x8189
+#define GLX_RENDERER_OPENGL_CORE_PROFILE_VERSION_MESA 0x818A
+#define GLX_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION_MESA 0x818B
+#define GLX_RENDERER_OPENGL_ES_PROFILE_VERSION_MESA 0x818C
+#define GLX_RENDERER_OPENGL_ES2_PROFILE_VERSION_MESA 0x818D
+typedef Bool ( *PFNGLXQUERYCURRENTRENDERERINTEGERMESAPROC) (int attribute, unsigned int *value);
+typedef const char *( *PFNGLXQUERYCURRENTRENDERERSTRINGMESAPROC) (int attribute);
+typedef Bool ( *PFNGLXQUERYRENDERERINTEGERMESAPROC) (Display *dpy, int screen, int renderer, int attribute, unsigned int *value);
+typedef const char *( *PFNGLXQUERYRENDERERSTRINGMESAPROC) (Display *dpy, int screen, int renderer, int attribute);
+#ifdef GLX_GLXEXT_PROTOTYPES
+Bool glXQueryCurrentRendererIntegerMESA (int attribute, unsigned int *value);
+const char *glXQueryCurrentRendererStringMESA (int attribute);
+Bool glXQueryRendererIntegerMESA (Display *dpy, int screen, int renderer, int attribute, unsigned int *value);
+const char *glXQueryRendererStringMESA (Display *dpy, int screen, int renderer, int attribute);
+#endif
+#endif /* GLX_MESA_query_renderer */
+
+#ifndef GLX_MESA_release_buffers
+#define GLX_MESA_release_buffers 1
+typedef Bool ( *PFNGLXRELEASEBUFFERSMESAPROC) (Display *dpy, GLXDrawable drawable);
+#ifdef GLX_GLXEXT_PROTOTYPES
+Bool glXReleaseBuffersMESA (Display *dpy, GLXDrawable drawable);
+#endif
+#endif /* GLX_MESA_release_buffers */
+
+#ifndef GLX_MESA_set_3dfx_mode
+#define GLX_MESA_set_3dfx_mode 1
+#define GLX_3DFX_WINDOW_MODE_MESA         0x1
+#define GLX_3DFX_FULLSCREEN_MODE_MESA     0x2
+typedef GLboolean ( *PFNGLXSET3DFXMODEMESAPROC) (GLint mode);
+#ifdef GLX_GLXEXT_PROTOTYPES
+GLboolean glXSet3DfxModeMESA (GLint mode);
+#endif
+#endif /* GLX_MESA_set_3dfx_mode */
+
+#ifndef GLX_MESA_swap_control
+#define GLX_MESA_swap_control 1
+typedef int ( *PFNGLXGETSWAPINTERVALMESAPROC) (void);
+typedef int ( *PFNGLXSWAPINTERVALMESAPROC) (unsigned int interval);
+#ifdef GLX_GLXEXT_PROTOTYPES
+int glXGetSwapIntervalMESA (void);
+int glXSwapIntervalMESA (unsigned int interval);
+#endif
+#endif /* GLX_MESA_swap_control */
+
+#ifndef GLX_NV_copy_buffer
+#define GLX_NV_copy_buffer 1
+typedef void ( *PFNGLXCOPYBUFFERSUBDATANVPROC) (Display *dpy, GLXContext readCtx, GLXContext writeCtx, GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
+typedef void ( *PFNGLXNAMEDCOPYBUFFERSUBDATANVPROC) (Display *dpy, GLXContext readCtx, GLXContext writeCtx, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
+#ifdef GLX_GLXEXT_PROTOTYPES
+void glXCopyBufferSubDataNV (Display *dpy, GLXContext readCtx, GLXContext writeCtx, GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
+void glXNamedCopyBufferSubDataNV (Display *dpy, GLXContext readCtx, GLXContext writeCtx, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
+#endif
+#endif /* GLX_NV_copy_buffer */
+
+#ifndef GLX_NV_copy_image
+#define GLX_NV_copy_image 1
+typedef void ( *PFNGLXCOPYIMAGESUBDATANVPROC) (Display *dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
+#ifdef GLX_GLXEXT_PROTOTYPES
+void glXCopyImageSubDataNV (Display *dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
+#endif
+#endif /* GLX_NV_copy_image */
+
+#ifndef GLX_NV_delay_before_swap
+#define GLX_NV_delay_before_swap 1
+typedef Bool ( *PFNGLXDELAYBEFORESWAPNVPROC) (Display *dpy, GLXDrawable drawable, GLfloat seconds);
+#ifdef GLX_GLXEXT_PROTOTYPES
+Bool glXDelayBeforeSwapNV (Display *dpy, GLXDrawable drawable, GLfloat seconds);
+#endif
+#endif /* GLX_NV_delay_before_swap */
+
+#ifndef GLX_NV_float_buffer
+#define GLX_NV_float_buffer 1
+#define GLX_FLOAT_COMPONENTS_NV           0x20B0
+#endif /* GLX_NV_float_buffer */
+
+#ifndef GLX_NV_multisample_coverage
+#define GLX_NV_multisample_coverage 1
+#define GLX_COVERAGE_SAMPLES_NV           100001
+#define GLX_COLOR_SAMPLES_NV              0x20B3
+#endif /* GLX_NV_multisample_coverage */
+
+#ifndef GLX_NV_present_video
+#define GLX_NV_present_video 1
+#define GLX_NUM_VIDEO_SLOTS_NV            0x20F0
+typedef unsigned int *( *PFNGLXENUMERATEVIDEODEVICESNVPROC) (Display *dpy, int screen, int *nelements);
+typedef int ( *PFNGLXBINDVIDEODEVICENVPROC) (Display *dpy, unsigned int video_slot, unsigned int video_device, const int *attrib_list);
+#ifdef GLX_GLXEXT_PROTOTYPES
+unsigned int *glXEnumerateVideoDevicesNV (Display *dpy, int screen, int *nelements);
+int glXBindVideoDeviceNV (Display *dpy, unsigned int video_slot, unsigned int video_device, const int *attrib_list);
+#endif
+#endif /* GLX_NV_present_video */
+
+#ifndef GLX_NV_robustness_video_memory_purge
+#define GLX_NV_robustness_video_memory_purge 1
+#define GLX_GENERATE_RESET_ON_VIDEO_MEMORY_PURGE_NV 0x20F7
+#endif /* GLX_NV_robustness_video_memory_purge */
+
+#ifndef GLX_NV_swap_group
+#define GLX_NV_swap_group 1
+typedef Bool ( *PFNGLXJOINSWAPGROUPNVPROC) (Display *dpy, GLXDrawable drawable, GLuint group);
+typedef Bool ( *PFNGLXBINDSWAPBARRIERNVPROC) (Display *dpy, GLuint group, GLuint barrier);
+typedef Bool ( *PFNGLXQUERYSWAPGROUPNVPROC) (Display *dpy, GLXDrawable drawable, GLuint *group, GLuint *barrier);
+typedef Bool ( *PFNGLXQUERYMAXSWAPGROUPSNVPROC) (Display *dpy, int screen, GLuint *maxGroups, GLuint *maxBarriers);
+typedef Bool ( *PFNGLXQUERYFRAMECOUNTNVPROC) (Display *dpy, int screen, GLuint *count);
+typedef Bool ( *PFNGLXRESETFRAMECOUNTNVPROC) (Display *dpy, int screen);
+#ifdef GLX_GLXEXT_PROTOTYPES
+Bool glXJoinSwapGroupNV (Display *dpy, GLXDrawable drawable, GLuint group);
+Bool glXBindSwapBarrierNV (Display *dpy, GLuint group, GLuint barrier);
+Bool glXQuerySwapGroupNV (Display *dpy, GLXDrawable drawable, GLuint *group, GLuint *barrier);
+Bool glXQueryMaxSwapGroupsNV (Display *dpy, int screen, GLuint *maxGroups, GLuint *maxBarriers);
+Bool glXQueryFrameCountNV (Display *dpy, int screen, GLuint *count);
+Bool glXResetFrameCountNV (Display *dpy, int screen);
+#endif
+#endif /* GLX_NV_swap_group */
+
+#ifndef GLX_NV_video_capture
+#define GLX_NV_video_capture 1
+typedef XID GLXVideoCaptureDeviceNV;
+#define GLX_DEVICE_ID_NV                  0x20CD
+#define GLX_UNIQUE_ID_NV                  0x20CE
+#define GLX_NUM_VIDEO_CAPTURE_SLOTS_NV    0x20CF
+typedef int ( *PFNGLXBINDVIDEOCAPTUREDEVICENVPROC) (Display *dpy, unsigned int video_capture_slot, GLXVideoCaptureDeviceNV device);
+typedef GLXVideoCaptureDeviceNV *( *PFNGLXENUMERATEVIDEOCAPTUREDEVICESNVPROC) (Display *dpy, int screen, int *nelements);
+typedef void ( *PFNGLXLOCKVIDEOCAPTUREDEVICENVPROC) (Display *dpy, GLXVideoCaptureDeviceNV device);
+typedef int ( *PFNGLXQUERYVIDEOCAPTUREDEVICENVPROC) (Display *dpy, GLXVideoCaptureDeviceNV device, int attribute, int *value);
+typedef void ( *PFNGLXRELEASEVIDEOCAPTUREDEVICENVPROC) (Display *dpy, GLXVideoCaptureDeviceNV device);
+#ifdef GLX_GLXEXT_PROTOTYPES
+int glXBindVideoCaptureDeviceNV (Display *dpy, unsigned int video_capture_slot, GLXVideoCaptureDeviceNV device);
+GLXVideoCaptureDeviceNV *glXEnumerateVideoCaptureDevicesNV (Display *dpy, int screen, int *nelements);
+void glXLockVideoCaptureDeviceNV (Display *dpy, GLXVideoCaptureDeviceNV device);
+int glXQueryVideoCaptureDeviceNV (Display *dpy, GLXVideoCaptureDeviceNV device, int attribute, int *value);
+void glXReleaseVideoCaptureDeviceNV (Display *dpy, GLXVideoCaptureDeviceNV device);
+#endif
+#endif /* GLX_NV_video_capture */
+
+#ifndef GLX_NV_video_out
+#define GLX_NV_video_out 1
+typedef unsigned int GLXVideoDeviceNV;
+#define GLX_VIDEO_OUT_COLOR_NV            0x20C3
+#define GLX_VIDEO_OUT_ALPHA_NV            0x20C4
+#define GLX_VIDEO_OUT_DEPTH_NV            0x20C5
+#define GLX_VIDEO_OUT_COLOR_AND_ALPHA_NV  0x20C6
+#define GLX_VIDEO_OUT_COLOR_AND_DEPTH_NV  0x20C7
+#define GLX_VIDEO_OUT_FRAME_NV            0x20C8
+#define GLX_VIDEO_OUT_FIELD_1_NV          0x20C9
+#define GLX_VIDEO_OUT_FIELD_2_NV          0x20CA
+#define GLX_VIDEO_OUT_STACKED_FIELDS_1_2_NV 0x20CB
+#define GLX_VIDEO_OUT_STACKED_FIELDS_2_1_NV 0x20CC
+typedef int ( *PFNGLXGETVIDEODEVICENVPROC) (Display *dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *pVideoDevice);
+typedef int ( *PFNGLXRELEASEVIDEODEVICENVPROC) (Display *dpy, int screen, GLXVideoDeviceNV VideoDevice);
+typedef int ( *PFNGLXBINDVIDEOIMAGENVPROC) (Display *dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int iVideoBuffer);
+typedef int ( *PFNGLXRELEASEVIDEOIMAGENVPROC) (Display *dpy, GLXPbuffer pbuf);
+typedef int ( *PFNGLXSENDPBUFFERTOVIDEONVPROC) (Display *dpy, GLXPbuffer pbuf, int iBufferType, unsigned long *pulCounterPbuffer, GLboolean bBlock);
+typedef int ( *PFNGLXGETVIDEOINFONVPROC) (Display *dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo);
+#ifdef GLX_GLXEXT_PROTOTYPES
+int glXGetVideoDeviceNV (Display *dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *pVideoDevice);
+int glXReleaseVideoDeviceNV (Display *dpy, int screen, GLXVideoDeviceNV VideoDevice);
+int glXBindVideoImageNV (Display *dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int iVideoBuffer);
+int glXReleaseVideoImageNV (Display *dpy, GLXPbuffer pbuf);
+int glXSendPbufferToVideoNV (Display *dpy, GLXPbuffer pbuf, int iBufferType, unsigned long *pulCounterPbuffer, GLboolean bBlock);
+int glXGetVideoInfoNV (Display *dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo);
+#endif
+#endif /* GLX_NV_video_out */
+
+#ifndef GLX_OML_swap_method
+#define GLX_OML_swap_method 1
+#define GLX_SWAP_METHOD_OML               0x8060
+#define GLX_SWAP_EXCHANGE_OML             0x8061
+#define GLX_SWAP_COPY_OML                 0x8062
+#define GLX_SWAP_UNDEFINED_OML            0x8063
+#endif /* GLX_OML_swap_method */
+
+#ifndef GLX_OML_sync_control
+#define GLX_OML_sync_control 1
+#ifndef GLEXT_64_TYPES_DEFINED
+/* This code block is duplicated in glext.h, so must be protected */
+#define GLEXT_64_TYPES_DEFINED
+/* Define int32_t, int64_t, and uint64_t types for UST/MSC */
+/* (as used in the GLX_OML_sync_control extension). */
+#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+#include &ltinttypes.h>
+#elif defined(__sun__) || defined(__digital__)
+#include &ltinttypes.h>
+#if defined(__STDC__)
+#if defined(__arch64__) || defined(_LP64)
+typedef long int int64_t;
+typedef unsigned long int uint64_t;
+#else
+typedef long long int int64_t;
+typedef unsigned long long int uint64_t;
+#endif /* __arch64__ */
+#endif /* __STDC__ */
+#elif defined( __VMS ) || defined(__sgi)
+#include &ltinttypes.h>
+#elif defined(__SCO__) || defined(__USLC__)
+#include &ltstdint.h>
+#elif defined(__UNIXOS2__) || defined(__SOL64__)
+typedef long int int32_t;
+typedef long long int int64_t;
+typedef unsigned long long int uint64_t;
+#elif defined(_WIN32) && defined(__GNUC__)
+#include &ltstdint.h>
+#elif defined(_WIN32)
+typedef __int32 int32_t;
+typedef __int64 int64_t;
+typedef unsigned __int64 uint64_t;
+#else
+/* Fallback if nothing above works */
+#include &ltinttypes.h>
+#endif
+#endif
+typedef Bool ( *PFNGLXGETSYNCVALUESOMLPROC) (Display *dpy, GLXDrawable drawable, int64_t *ust, int64_t *msc, int64_t *sbc);
+typedef Bool ( *PFNGLXGETMSCRATEOMLPROC) (Display *dpy, GLXDrawable drawable, int32_t *numerator, int32_t *denominator);
+typedef int64_t ( *PFNGLXSWAPBUFFERSMSCOMLPROC) (Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder);
+typedef Bool ( *PFNGLXWAITFORMSCOMLPROC) (Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *ust, int64_t *msc, int64_t *sbc);
+typedef Bool ( *PFNGLXWAITFORSBCOMLPROC) (Display *dpy, GLXDrawable drawable, int64_t target_sbc, int64_t *ust, int64_t *msc, int64_t *sbc);
+#ifdef GLX_GLXEXT_PROTOTYPES
+Bool glXGetSyncValuesOML (Display *dpy, GLXDrawable drawable, int64_t *ust, int64_t *msc, int64_t *sbc);
+Bool glXGetMscRateOML (Display *dpy, GLXDrawable drawable, int32_t *numerator, int32_t *denominator);
+int64_t glXSwapBuffersMscOML (Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder);
+Bool glXWaitForMscOML (Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *ust, int64_t *msc, int64_t *sbc);
+Bool glXWaitForSbcOML (Display *dpy, GLXDrawable drawable, int64_t target_sbc, int64_t *ust, int64_t *msc, int64_t *sbc);
+#endif
+#endif /* GLX_OML_sync_control */
+
+#ifndef GLX_SGIS_blended_overlay
+#define GLX_SGIS_blended_overlay 1
+#define GLX_BLENDED_RGBA_SGIS             0x8025
+#endif /* GLX_SGIS_blended_overlay */
+
+#ifndef GLX_SGIS_multisample
+#define GLX_SGIS_multisample 1
+#define GLX_SAMPLE_BUFFERS_SGIS           100000
+#define GLX_SAMPLES_SGIS                  100001
+#endif /* GLX_SGIS_multisample */
+
+#ifndef GLX_SGIS_shared_multisample
+#define GLX_SGIS_shared_multisample 1
+#define GLX_MULTISAMPLE_SUB_RECT_WIDTH_SGIS 0x8026
+#define GLX_MULTISAMPLE_SUB_RECT_HEIGHT_SGIS 0x8027
+#endif /* GLX_SGIS_shared_multisample */
+
+#ifndef GLX_SGIX_dmbuffer
+#define GLX_SGIX_dmbuffer 1
+typedef XID GLXPbufferSGIX;
+#ifdef _DM_BUFFER_H_
+#define GLX_DIGITAL_MEDIA_PBUFFER_SGIX    0x8024
+typedef Bool ( *PFNGLXASSOCIATEDMPBUFFERSGIXPROC) (Display *dpy, GLXPbufferSGIX pbuffer, DMparams *params, DMbuffer dmbuffer);
+#ifdef GLX_GLXEXT_PROTOTYPES
+Bool glXAssociateDMPbufferSGIX (Display *dpy, GLXPbufferSGIX pbuffer, DMparams *params, DMbuffer dmbuffer);
+#endif
+#endif /* _DM_BUFFER_H_ */
+#endif /* GLX_SGIX_dmbuffer */
+
+#ifndef GLX_SGIX_fbconfig
+#define GLX_SGIX_fbconfig 1
+typedef struct __GLXFBConfigRec *GLXFBConfigSGIX;
+#define GLX_WINDOW_BIT_SGIX               0x00000001
+#define GLX_PIXMAP_BIT_SGIX               0x00000002
+#define GLX_RGBA_BIT_SGIX                 0x00000001
+#define GLX_COLOR_INDEX_BIT_SGIX          0x00000002
+#define GLX_DRAWABLE_TYPE_SGIX            0x8010
+#define GLX_RENDER_TYPE_SGIX              0x8011
+#define GLX_X_RENDERABLE_SGIX             0x8012
+#define GLX_FBCONFIG_ID_SGIX              0x8013
+#define GLX_RGBA_TYPE_SGIX                0x8014
+#define GLX_COLOR_INDEX_TYPE_SGIX         0x8015
+typedef int ( *PFNGLXGETFBCONFIGATTRIBSGIXPROC) (Display *dpy, GLXFBConfigSGIX config, int attribute, int *value);
+typedef GLXFBConfigSGIX *( *PFNGLXCHOOSEFBCONFIGSGIXPROC) (Display *dpy, int screen, int *attrib_list, int *nelements);
+typedef GLXPixmap ( *PFNGLXCREATEGLXPIXMAPWITHCONFIGSGIXPROC) (Display *dpy, GLXFBConfigSGIX config, Pixmap pixmap);
+typedef GLXContext ( *PFNGLXCREATECONTEXTWITHCONFIGSGIXPROC) (Display *dpy, GLXFBConfigSGIX config, int render_type, GLXContext share_list, Bool direct);
+typedef XVisualInfo *( *PFNGLXGETVISUALFROMFBCONFIGSGIXPROC) (Display *dpy, GLXFBConfigSGIX config);
+typedef GLXFBConfigSGIX ( *PFNGLXGETFBCONFIGFROMVISUALSGIXPROC) (Display *dpy, XVisualInfo *vis);
+#ifdef GLX_GLXEXT_PROTOTYPES
+int glXGetFBConfigAttribSGIX (Display *dpy, GLXFBConfigSGIX config, int attribute, int *value);
+GLXFBConfigSGIX *glXChooseFBConfigSGIX (Display *dpy, int screen, int *attrib_list, int *nelements);
+GLXPixmap glXCreateGLXPixmapWithConfigSGIX (Display *dpy, GLXFBConfigSGIX config, Pixmap pixmap);
+GLXContext glXCreateContextWithConfigSGIX (Display *dpy, GLXFBConfigSGIX config, int render_type, GLXContext share_list, Bool direct);
+XVisualInfo *glXGetVisualFromFBConfigSGIX (Display *dpy, GLXFBConfigSGIX config);
+GLXFBConfigSGIX glXGetFBConfigFromVisualSGIX (Display *dpy, XVisualInfo *vis);
+#endif
+#endif /* GLX_SGIX_fbconfig */
+
+#ifndef GLX_SGIX_hyperpipe
+#define GLX_SGIX_hyperpipe 1
+typedef struct {
+    char    pipeName[80]; /* Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX] */
+    int     networkId;
+} GLXHyperpipeNetworkSGIX;
+typedef struct {
+    char    pipeName[80]; /* Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX] */
+    int     channel;
+    unsigned int participationType;
+    int     timeSlice;
+} GLXHyperpipeConfigSGIX;
+typedef struct {
+    char pipeName[80]; /* Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX] */
+    int srcXOrigin, srcYOrigin, srcWidth, srcHeight;
+    int destXOrigin, destYOrigin, destWidth, destHeight;
+} GLXPipeRect;
+typedef struct {
+    char pipeName[80]; /* Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX] */
+    int XOrigin, YOrigin, maxHeight, maxWidth;
+} GLXPipeRectLimits;
+#define GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX 80
+#define GLX_BAD_HYPERPIPE_CONFIG_SGIX     91
+#define GLX_BAD_HYPERPIPE_SGIX            92
+#define GLX_HYPERPIPE_DISPLAY_PIPE_SGIX   0x00000001
+#define GLX_HYPERPIPE_RENDER_PIPE_SGIX    0x00000002
+#define GLX_PIPE_RECT_SGIX                0x00000001
+#define GLX_PIPE_RECT_LIMITS_SGIX         0x00000002
+#define GLX_HYPERPIPE_STEREO_SGIX         0x00000003
+#define GLX_HYPERPIPE_PIXEL_AVERAGE_SGIX  0x00000004
+#define GLX_HYPERPIPE_ID_SGIX             0x8030
+typedef GLXHyperpipeNetworkSGIX *( *PFNGLXQUERYHYPERPIPENETWORKSGIXPROC) (Display *dpy, int *npipes);
+typedef int ( *PFNGLXHYPERPIPECONFIGSGIXPROC) (Display *dpy, int networkId, int npipes, GLXHyperpipeConfigSGIX *cfg, int *hpId);
+typedef GLXHyperpipeConfigSGIX *( *PFNGLXQUERYHYPERPIPECONFIGSGIXPROC) (Display *dpy, int hpId, int *npipes);
+typedef int ( *PFNGLXDESTROYHYPERPIPECONFIGSGIXPROC) (Display *dpy, int hpId);
+typedef int ( *PFNGLXBINDHYPERPIPESGIXPROC) (Display *dpy, int hpId);
+typedef int ( *PFNGLXQUERYHYPERPIPEBESTATTRIBSGIXPROC) (Display *dpy, int timeSlice, int attrib, int size, void *attribList, void *returnAttribList);
+typedef int ( *PFNGLXHYPERPIPEATTRIBSGIXPROC) (Display *dpy, int timeSlice, int attrib, int size, void *attribList);
+typedef int ( *PFNGLXQUERYHYPERPIPEATTRIBSGIXPROC) (Display *dpy, int timeSlice, int attrib, int size, void *returnAttribList);
+#ifdef GLX_GLXEXT_PROTOTYPES
+GLXHyperpipeNetworkSGIX *glXQueryHyperpipeNetworkSGIX (Display *dpy, int *npipes);
+int glXHyperpipeConfigSGIX (Display *dpy, int networkId, int npipes, GLXHyperpipeConfigSGIX *cfg, int *hpId);
+GLXHyperpipeConfigSGIX *glXQueryHyperpipeConfigSGIX (Display *dpy, int hpId, int *npipes);
+int glXDestroyHyperpipeConfigSGIX (Display *dpy, int hpId);
+int glXBindHyperpipeSGIX (Display *dpy, int hpId);
+int glXQueryHyperpipeBestAttribSGIX (Display *dpy, int timeSlice, int attrib, int size, void *attribList, void *returnAttribList);
+int glXHyperpipeAttribSGIX (Display *dpy, int timeSlice, int attrib, int size, void *attribList);
+int glXQueryHyperpipeAttribSGIX (Display *dpy, int timeSlice, int attrib, int size, void *returnAttribList);
+#endif
+#endif /* GLX_SGIX_hyperpipe */
+
+#ifndef GLX_SGIX_pbuffer
+#define GLX_SGIX_pbuffer 1
+#define GLX_PBUFFER_BIT_SGIX              0x00000004
+#define GLX_BUFFER_CLOBBER_MASK_SGIX      0x08000000
+#define GLX_FRONT_LEFT_BUFFER_BIT_SGIX    0x00000001
+#define GLX_FRONT_RIGHT_BUFFER_BIT_SGIX   0x00000002
+#define GLX_BACK_LEFT_BUFFER_BIT_SGIX     0x00000004
+#define GLX_BACK_RIGHT_BUFFER_BIT_SGIX    0x00000008
+#define GLX_AUX_BUFFERS_BIT_SGIX          0x00000010
+#define GLX_DEPTH_BUFFER_BIT_SGIX         0x00000020
+#define GLX_STENCIL_BUFFER_BIT_SGIX       0x00000040
+#define GLX_ACCUM_BUFFER_BIT_SGIX         0x00000080
+#define GLX_SAMPLE_BUFFERS_BIT_SGIX       0x00000100
+#define GLX_MAX_PBUFFER_WIDTH_SGIX        0x8016
+#define GLX_MAX_PBUFFER_HEIGHT_SGIX       0x8017
+#define GLX_MAX_PBUFFER_PIXELS_SGIX       0x8018
+#define GLX_OPTIMAL_PBUFFER_WIDTH_SGIX    0x8019
+#define GLX_OPTIMAL_PBUFFER_HEIGHT_SGIX   0x801A
+#define GLX_PRESERVED_CONTENTS_SGIX       0x801B
+#define GLX_LARGEST_PBUFFER_SGIX          0x801C
+#define GLX_WIDTH_SGIX                    0x801D
+#define GLX_HEIGHT_SGIX                   0x801E
+#define GLX_EVENT_MASK_SGIX               0x801F
+#define GLX_DAMAGED_SGIX                  0x8020
+#define GLX_SAVED_SGIX                    0x8021
+#define GLX_WINDOW_SGIX                   0x8022
+#define GLX_PBUFFER_SGIX                  0x8023
+typedef GLXPbufferSGIX ( *PFNGLXCREATEGLXPBUFFERSGIXPROC) (Display *dpy, GLXFBConfigSGIX config, unsigned int width, unsigned int height, int *attrib_list);
+typedef void ( *PFNGLXDESTROYGLXPBUFFERSGIXPROC) (Display *dpy, GLXPbufferSGIX pbuf);
+typedef void ( *PFNGLXQUERYGLXPBUFFERSGIXPROC) (Display *dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int *value);
+typedef void ( *PFNGLXSELECTEVENTSGIXPROC) (Display *dpy, GLXDrawable drawable, unsigned long mask);
+typedef void ( *PFNGLXGETSELECTEDEVENTSGIXPROC) (Display *dpy, GLXDrawable drawable, unsigned long *mask);
+#ifdef GLX_GLXEXT_PROTOTYPES
+GLXPbufferSGIX glXCreateGLXPbufferSGIX (Display *dpy, GLXFBConfigSGIX config, unsigned int width, unsigned int height, int *attrib_list);
+void glXDestroyGLXPbufferSGIX (Display *dpy, GLXPbufferSGIX pbuf);
+void glXQueryGLXPbufferSGIX (Display *dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int *value);
+void glXSelectEventSGIX (Display *dpy, GLXDrawable drawable, unsigned long mask);
+void glXGetSelectedEventSGIX (Display *dpy, GLXDrawable drawable, unsigned long *mask);
+#endif
+#endif /* GLX_SGIX_pbuffer */
+
+#ifndef GLX_SGIX_swap_barrier
+#define GLX_SGIX_swap_barrier 1
+typedef void ( *PFNGLXBINDSWAPBARRIERSGIXPROC) (Display *dpy, GLXDrawable drawable, int barrier);
+typedef Bool ( *PFNGLXQUERYMAXSWAPBARRIERSSGIXPROC) (Display *dpy, int screen, int *max);
+#ifdef GLX_GLXEXT_PROTOTYPES
+void glXBindSwapBarrierSGIX (Display *dpy, GLXDrawable drawable, int barrier);
+Bool glXQueryMaxSwapBarriersSGIX (Display *dpy, int screen, int *max);
+#endif
+#endif /* GLX_SGIX_swap_barrier */
+
+#ifndef GLX_SGIX_swap_group
+#define GLX_SGIX_swap_group 1
+typedef void ( *PFNGLXJOINSWAPGROUPSGIXPROC) (Display *dpy, GLXDrawable drawable, GLXDrawable member);
+#ifdef GLX_GLXEXT_PROTOTYPES
+void glXJoinSwapGroupSGIX (Display *dpy, GLXDrawable drawable, GLXDrawable member);
+#endif
+#endif /* GLX_SGIX_swap_group */
+
+#ifndef GLX_SGIX_video_resize
+#define GLX_SGIX_video_resize 1
+#define GLX_SYNC_FRAME_SGIX               0x00000000
+#define GLX_SYNC_SWAP_SGIX                0x00000001
+typedef int ( *PFNGLXBINDCHANNELTOWINDOWSGIXPROC) (Display *display, int screen, int channel, Window window);
+typedef int ( *PFNGLXCHANNELRECTSGIXPROC) (Display *display, int screen, int channel, int x, int y, int w, int h);
+typedef int ( *PFNGLXQUERYCHANNELRECTSGIXPROC) (Display *display, int screen, int channel, int *dx, int *dy, int *dw, int *dh);
+typedef int ( *PFNGLXQUERYCHANNELDELTASSGIXPROC) (Display *display, int screen, int channel, int *x, int *y, int *w, int *h);
+typedef int ( *PFNGLXCHANNELRECTSYNCSGIXPROC) (Display *display, int screen, int channel, GLenum synctype);
+#ifdef GLX_GLXEXT_PROTOTYPES
+int glXBindChannelToWindowSGIX (Display *display, int screen, int channel, Window window);
+int glXChannelRectSGIX (Display *display, int screen, int channel, int x, int y, int w, int h);
+int glXQueryChannelRectSGIX (Display *display, int screen, int channel, int *dx, int *dy, int *dw, int *dh);
+int glXQueryChannelDeltasSGIX (Display *display, int screen, int channel, int *x, int *y, int *w, int *h);
+int glXChannelRectSyncSGIX (Display *display, int screen, int channel, GLenum synctype);
+#endif
+#endif /* GLX_SGIX_video_resize */
+
+#ifndef GLX_SGIX_video_source
+#define GLX_SGIX_video_source 1
+typedef XID GLXVideoSourceSGIX;
+#ifdef _VL_H
+typedef GLXVideoSourceSGIX ( *PFNGLXCREATEGLXVIDEOSOURCESGIXPROC) (Display *display, int screen, VLServer server, VLPath path, int nodeClass, VLNode drainNode);
+typedef void ( *PFNGLXDESTROYGLXVIDEOSOURCESGIXPROC) (Display *dpy, GLXVideoSourceSGIX glxvideosource);
+#ifdef GLX_GLXEXT_PROTOTYPES
+GLXVideoSourceSGIX glXCreateGLXVideoSourceSGIX (Display *display, int screen, VLServer server, VLPath path, int nodeClass, VLNode drainNode);
+void glXDestroyGLXVideoSourceSGIX (Display *dpy, GLXVideoSourceSGIX glxvideosource);
+#endif
+#endif /* _VL_H */
+#endif /* GLX_SGIX_video_source */
+
+#ifndef GLX_SGIX_visual_select_group
+#define GLX_SGIX_visual_select_group 1
+#define GLX_VISUAL_SELECT_GROUP_SGIX      0x8028
+#endif /* GLX_SGIX_visual_select_group */
+
+#ifndef GLX_SGI_cushion
+#define GLX_SGI_cushion 1
+typedef void ( *PFNGLXCUSHIONSGIPROC) (Display *dpy, Window window, float cushion);
+#ifdef GLX_GLXEXT_PROTOTYPES
+void glXCushionSGI (Display *dpy, Window window, float cushion);
+#endif
+#endif /* GLX_SGI_cushion */
+
+#ifndef GLX_SGI_make_current_read
+#define GLX_SGI_make_current_read 1
+typedef Bool ( *PFNGLXMAKECURRENTREADSGIPROC) (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
+typedef GLXDrawable ( *PFNGLXGETCURRENTREADDRAWABLESGIPROC) (void);
+#ifdef GLX_GLXEXT_PROTOTYPES
+Bool glXMakeCurrentReadSGI (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
+GLXDrawable glXGetCurrentReadDrawableSGI (void);
+#endif
+#endif /* GLX_SGI_make_current_read */
+
+#ifndef GLX_SGI_swap_control
+#define GLX_SGI_swap_control 1
+typedef int ( *PFNGLXSWAPINTERVALSGIPROC) (int interval);
+#ifdef GLX_GLXEXT_PROTOTYPES
+int glXSwapIntervalSGI (int interval);
+#endif
+#endif /* GLX_SGI_swap_control */
+
+#ifndef GLX_SGI_video_sync
+#define GLX_SGI_video_sync 1
+typedef int ( *PFNGLXGETVIDEOSYNCSGIPROC) (unsigned int *count);
+typedef int ( *PFNGLXWAITVIDEOSYNCSGIPROC) (int divisor, int remainder, unsigned int *count);
+#ifdef GLX_GLXEXT_PROTOTYPES
+int glXGetVideoSyncSGI (unsigned int *count);
+int glXWaitVideoSyncSGI (int divisor, int remainder, unsigned int *count);
+#endif
+#endif /* GLX_SGI_video_sync */
+
+#ifndef GLX_SUN_get_transparent_index
+#define GLX_SUN_get_transparent_index 1
+typedef Status ( *PFNGLXGETTRANSPARENTINDEXSUNPROC) (Display *dpy, Window overlay, Window underlay, unsigned long *pTransparentIndex);
+#ifdef GLX_GLXEXT_PROTOTYPES
+Status glXGetTransparentIndexSUN (Display *dpy, Window overlay, Window underlay, unsigned long *pTransparentIndex);
+#endif
+#endif /* GLX_SUN_get_transparent_index */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/external/netzhaut.dev b/external/netzhaut.dev
index 5826dd4..c72abe7 160000
--- a/external/netzhaut.dev
+++ b/external/netzhaut.dev
@@ -1 +1 @@
-Subproject commit 5826dd4d873acc191d58579ba630eeba931a70b3
+Subproject commit c72abe7c17e099bc2952cbfaa60871b94df096dd
diff --git a/external/simple-opengl-loader-master/examples/x11/x11-example.c b/external/simple-opengl-loader-master/examples/x11/x11-example.c
index 9f0ef5c..72e34ac 100644
--- a/external/simple-opengl-loader-master/examples/x11/x11-example.c
+++ b/external/simple-opengl-loader-master/examples/x11/x11-example.c
@@ -112,37 +112,8 @@ int main(int argc, char const *argv[]) {
         }
     }
 
-    glClearColor(0.0, 0.0, 0.0, 1.0);
-
-    GLuint vertexArray = 0;
-    glGenVertexArrays(1, &vertexArray);
-    glBindVertexArray(vertexArray);
-
-    GLfloat positionData[] = {
-        -0.5, -0.5,
-        0.5, -0.5,
-        0.0, 0.5
-    };
-
-    GLuint positions = 0;
-    glGenBuffers(1, &positions);
-    glBindBuffer(GL_ARRAY_BUFFER, positions);
-    glBufferData(GL_ARRAY_BUFFER, 3 * 2 * sizeof(GLfloat), positionData, GL_STATIC_DRAW);
-    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, NULL);
-    glEnableVertexAttribArray(0);
-
-    GLubyte colorData[] = {
-        255, 0, 0,
-        0, 255, 0,
-        0, 0, 255
-    };
-
-    GLuint colors = 0;
-    glGenBuffers(1, &colors);
-    glBindBuffer(GL_ARRAY_BUFFER, colors);
-    glBufferData(GL_ARRAY_BUFFER, 3 * 3 * sizeof(GLubyte), colorData, GL_STATIC_DRAW);
-    glVertexAttribPointer(1, 3, GL_UNSIGNED_BYTE, GL_TRUE, 0, NULL);
-    glEnableVertexAttribArray(1);
+    glClearColor(1.0, 1.0, 1.0, 1.0);
+        glClear(GL_COLOR_BUFFER_BIT);
 
     const char* vsSource =
     "#version 450\n"
@@ -182,6 +153,43 @@ int main(int argc, char const *argv[]) {
         fprintf(stderr, "Program did not link!\n");
     }
 
+
+
+
+
+
+
+
+    GLuint vertexArray = 0;
+    glGenVertexArrays(1, &vertexArray);
+    glBindVertexArray(vertexArray);
+
+    GLfloat positionData[] = {
+        -0.5, -0.5,
+        0.5, -0.5,
+        0.0, 0.5
+    };
+
+    GLuint positions = 0;
+    glGenBuffers(1, &positions);
+    glBindBuffer(GL_ARRAY_BUFFER, positions);
+    glBufferData(GL_ARRAY_BUFFER, 3 * 2 * sizeof(GLfloat), positionData, GL_STATIC_DRAW);
+    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, NULL);
+    glEnableVertexAttribArray(0);
+
+    GLubyte colorData[] = {
+        255, 0, 0,
+        0, 255, 0,
+        0, 0, 255
+    };
+
+    GLuint colors = 0;
+    glGenBuffers(1, &colors);
+    glBindBuffer(GL_ARRAY_BUFFER, colors);
+    glBufferData(GL_ARRAY_BUFFER, 3 * 3 * sizeof(GLubyte), colorData, GL_STATIC_DRAW);
+    glVertexAttribPointer(1, 3, GL_UNSIGNED_BYTE, GL_TRUE, 0, NULL);
+    glEnableVertexAttribArray(1);
+
     glUseProgram(program);
 
     Atom wmDeleteMessage = XInternAtom(display, "WM_DELETE_WINDOW", False);
@@ -200,7 +208,6 @@ int main(int argc, char const *argv[]) {
             }
         }
 
-        glClear(GL_COLOR_BUFFER_BIT);
         glDrawArrays(GL_TRIANGLES, 0, 3);
 
         glXSwapBuffers(display, window);
diff --git a/external/simple-opengl-loader-master/simple-opengl-loader.h b/external/simple-opengl-loader-master/simple-opengl-loader.h
index 3f56166..8821822 100644
--- a/external/simple-opengl-loader-master/simple-opengl-loader.h
+++ b/external/simple-opengl-loader-master/simple-opengl-loader.h
@@ -37,11 +37,11 @@ extern "C" {
 #endif
 
 #ifndef SOGL_MAJOR_VERSION
-#define SOGL_MAJOR_VERSION 1
+#define SOGL_MAJOR_VERSION 4 // Changed by Netzhaut.
 #endif
 
 #ifndef SOGL_MINOR_VERSION
-#define SOGL_MINOR_VERSION 0
+#define SOGL_MINOR_VERSION 6 // Changed by Netzhaut.
 #endif
 
 #ifndef SOGL_MAX_REPORTED_FAILURES
diff --git a/src/bin/nhmake/Changelogs.c b/src/bin/nhmake/Changelogs.c
index 6786ace..f567fe5 100644
--- a/src/bin/nhmake/Changelogs.c
+++ b/src/bin/nhmake/Changelogs.c
@@ -62,7 +62,7 @@ static NH_BYTE *writeChangelog(
     nh_make_Version Revision = nh_make_getRevision(Runtime_p, Changes_p);
     sprintf(data_p+strlen(data_p), " | rev.%d%d%d%d", Revision.api, Revision.major, Revision.minor, Revision.patch);
     if (Changes_p->id_p) {
-        sprintf(data_p+strlen(data_p), " | [%s](../../patches/html/md_pages_%s.html)", Changes_p->id_p, Changes_p->id_p);
+        sprintf(data_p+strlen(data_p), " | [open patch](../../patches/html/md_pages_%s.html)", Changes_p->id_p);
     }
     sprintf(data_p+strlen(data_p), "\n\n ---");
     if (Changes_p->summary_p) {sprintf(data_p+strlen(data_p), "\n\n %s", Changes_p->summary_p);}
@@ -104,7 +104,7 @@ static NH_BYTE *writeChangelogIndex(
         sprintf(data_p+strlen(data_p), " | rev.%d%d%d%d", Revision.api, Revision.major, Revision.minor, Revision.patch);
         if (Changelog_p->Changes_p[i].id_p) {
             sprintf(data_p+strlen(data_p), 
-                " | [%s](../../patches/html/md_pages_%s.html)", Changelog_p->Changes_p[i].id_p, Changelog_p->Changes_p[i].id_p);
+                " | [open patch](../../patches/html/md_pages_%s.html)", Changelog_p->Changes_p[i].id_p);
         }
         sprintf(data_p+strlen(data_p), "\n\n ---\n");
 
diff --git a/src/bin/nhtty/Main.c b/src/bin/nhtty/Main.c
index b38a9f1..4083e86 100644
--- a/src/bin/nhtty/Main.c
+++ b/src/bin/nhtty/Main.c
@@ -9,10 +9,22 @@
 #include &ltstdlib.h>
 #include &ltstdio.h>
 #include &ltunistd.h>
+#include &ltstring.h>
 
 static nh_tty_TTY *TTY_p = NULL;
+static NH_BOOL rendererOption = NH_FALSE;
 
-void handleInput(
+static void handleStartupInput(
+    int argc, char **argv_pp)
+{
+    for (int i = 1; i &lt argc; ++i) {
+        if (!strcmp(argv_pp[i], "--renderer") || !strcmp(argv_pp[i], "-r")) {
+            rendererOption = NH_TRUE;
+        }
+    }
+}
+
+static void handleWindowInput(
     nh_wsi_Window *Window_p, nh_wsi_Event Event)
 {
     switch (Event.type)
@@ -25,12 +37,14 @@ void handleInput(
 
 int main(int argc, char **argv_pp) 
 {
+    handleStartupInput(argc, argv_pp);
+
     if (nh_initialize(NH_LOADER_SCOPE_SYSTEM, NULL, NH_FALSE) != NH_SUCCESS) {return 1;}
 
     TTY_p = nh_tty_openTTY();
     if (!TTY_p) {return 1;}
 
-    NH_TTY_RESULT standardIO = nh_tty_claimStandardIO(TTY_p);
+    NH_TTY_RESULT standardIO = rendererOption ? 1 : nh_tty_claimStandardIO(TTY_p);
     if (standardIO)
     {
         nh_terminal_Terminal *Terminal_p =  nh_terminal_openTerminal(TTY_p);
@@ -43,7 +57,7 @@ int main(int argc, char **argv_pp)
         nh_wsi_Window *Window_p = nh_wsi_createWindow("Window Title", Size);
         if (!Window_p) {return 1;}
     
-        nh_gfx_Surface *Surface_p = nh_gfx_createSurface(Window_p, NH_GFX_API_VULKAN);
+        nh_gfx_Surface *Surface_p = nh_gfx_createSurface(Window_p, NH_GFX_API_OPENGL);
         if (!Surface_p) {return 1;}
     
         nh_PixelPosition Position;
@@ -57,7 +71,7 @@ int main(int argc, char **argv_pp)
             return 1;
         }
         
-        nh_wsi_setEventListener(Window_p, handleInput);
+        nh_wsi_setEventListener(Window_p, handleWindowInput);
     }
 
     if (nh_tty_addDefaultProgram(TTY_p, "shell") != NH_TTY_SUCCESS) {
diff --git a/src/lib/nhgfx/Base/Surface.c b/src/lib/nhgfx/Base/Surface.c
index 917da2f..71dd255 100644
--- a/src/lib/nhgfx/Base/Surface.c
+++ b/src/lib/nhgfx/Base/Surface.c
@@ -9,11 +9,13 @@
 // INCLUDE =========================================================================================
 
 #include "Surface.h"
+#include "Viewport.h"
 
 #include "../Vulkan/Vulkan.h"
-#include "../Vulkan/Surface.h"
 #include "../Vulkan/Render.h"
 
+#include "../OpenGL/Render.h"
+
 #include "../Common/Macros/Macros.h"
 #include NH_GFX_FLOW
 #include NH_GFX_DEFAULT_CHECK
@@ -168,26 +170,80 @@ NH_GFX_BEGIN()
 NH_GFX_END(Surface_p)
 }
 
+static NH_GFX_RESULT nh_gfx_getSortedViewports(
+    nh_gfx_Surface *Surface_p, nh_List *SortedViewports_p)
+{
+NH_GFX_BEGIN()
+
+    nh_List Viewports = nh_initList(16);
+    
+    // find out which viewports to render
+    for (int i = 0; i &lt Surface_p->Viewports.size; ++i) {
+        if (((nh_gfx_Viewport*)Surface_p->Viewports.pp[i])->Sync.render) {
+            nh_appendToList(&Viewports, Surface_p->Viewports.pp[i]);
+        }
+    }
+
+    int *sortedIndices_p = nh_allocate(sizeof(int) * Viewports.size);
+    NH_GFX_CHECK_MEM(sortedIndices_p)
+
+    // sort viewports based on priority (from low to high priority)
+    int max = 0;
+    for (int i = 0; i &lt Viewports.size; ++i) {
+        nh_gfx_Viewport *Viewport_p = Viewports.pp[i];
+        if (Viewport_p->Settings.priority > max) {max = Viewport_p->Settings.priority;}
+    }
+    
+    for (int i = 0; i &lt Viewports.size; ++i) 
+    {
+        int diff = max, newMax = -1;
+        for (int j = 0; j &lt Viewports.size; ++j) 
+        {
+            nh_gfx_Viewport *Viewport_p = Viewports.pp[j];
+            if ((Viewport_p->Settings.priority - max) == 0) {sortedIndices_p[i] = j;}
+            else if ((max - Viewport_p->Settings.priority) &lt= diff) {
+                diff = max - Viewport_p->Settings.priority; 
+                newMax = Viewport_p->Settings.priority;
+            }
+        }
+        max = newMax;
+    }
+
+    for (int i = 0; i &lt Viewports.size; ++i) {
+        nh_appendToList(SortedViewports_p, Viewports.pp[sortedIndices_p[i]]);
+    }
+
+    nh_free(sortedIndices_p);
+    nh_freeList(&Viewports, NH_FALSE);
+
+NH_GFX_END(NH_GFX_SUCCESS)
+}
+
 static NH_GFX_RESULT nh_gfx_render(
     nh_gfx_Surface *Surface_p)
 {
 NH_GFX_BEGIN()
 
+    nh_List SortedViewports = nh_initList(16);
+    NH_GFX_CHECK(nh_gfx_getSortedViewports(Surface_p, &SortedViewports))
+
     switch (Surface_p->api)
     {
         case NH_GFX_API_VULKAN : 
 
-            NH_GFX_CHECK(nh_vk_render(Surface_p))
+            NH_GFX_CHECK(nh_vk_render(Surface_p, &SortedViewports))
             break;
 
         case NH_GFX_API_OPENGL : 
 
-//            NH_GFX_CHECK(nh_opengl_render(Surface_p))
+            NH_GFX_CHECK(nh_opengl_render(Surface_p, &SortedViewports))
             break;
 
         default : NH_GFX_DIAGNOSTIC_END(NH_GFX_ERROR_BAD_STATE)
     }
 
+    nh_freeList(&SortedViewports, NH_FALSE);
+
 NH_GFX_DIAGNOSTIC_END(NH_GFX_SUCCESS)
 }
 
diff --git a/src/lib/nhgfx/Base/Viewport.c b/src/lib/nhgfx/Base/Viewport.c
index 4b2fe94..74e244e 100644
--- a/src/lib/nhgfx/Base/Viewport.c
+++ b/src/lib/nhgfx/Base/Viewport.c
@@ -11,6 +11,8 @@
 #include "Viewport.h"
 
 #include "../Vulkan/Viewport.h"
+#include "../OpenGL/Viewport.h"
+
 #include "../Common/Macros/Macros.h"
 #include NH_GFX_FLOW
 #include NH_GFX_DEFAULT_CHECK
@@ -59,9 +61,11 @@ NH_GFX_BEGIN()
     switch (Surface_p->api)
     {
         case NH_GFX_API_VULKAN : 
-
             NH_GFX_CHECK(NULL, nh_vk_createViewport(Viewport_p)) 
             break;
+        case NH_GFX_API_OPENGL : 
+            NH_GFX_CHECK(NULL, nh_opengl_createViewport(Viewport_p)) 
+            break;
 
         default : NH_GFX_END(NULL)
     }
@@ -88,6 +92,9 @@ NH_GFX_BEGIN()
         case NH_GFX_API_VULKAN : 
             imageCount = Viewport_p->Vulkan.images = Viewport_p->Surface_p->Vulkan.imageCount; 
             break;
+        case NH_GFX_API_OPENGL : 
+            imageCount = 1; 
+            break;
         default : NH_GFX_DIAGNOSTIC_END(NH_GFX_ERROR_BAD_STATE)
     }
 
@@ -107,6 +114,9 @@ NH_GFX_BEGIN()
             case NH_GFX_API_VULKAN : 
                 Viewport_p->Vulkan.CommandBuffers_pp[i] = &Viewport_p->Vulkan.CommandBuffers_p[bufferIndex];
                 break;
+            case NH_GFX_API_OPENGL : 
+                Viewport_p->OpenGL.CommandBuffer_p = &Viewport_p->OpenGL.CommandBuffers_p[bufferIndex];
+                break;
         }
 
         Viewport_p->Sync.newestBuffers_p[i] = bufferIndex;
@@ -117,6 +127,9 @@ NH_GFX_BEGIN()
         case NH_GFX_API_VULKAN : 
             NH_GFX_CHECK(nh_vk_beginRecording(Viewport_p))
             break;
+        case NH_GFX_API_OPENGL : 
+            NH_GFX_CHECK(nh_opengl_beginRecording(Viewport_p))
+            break;
     }
 
 NH_GFX_DIAGNOSTIC_END(NH_GFX_SUCCESS)
@@ -134,6 +147,9 @@ NH_GFX_BEGIN()
         case NH_GFX_API_VULKAN : 
             NH_GFX_CHECK(nh_vk_endRecording(Viewport_p))
             break;
+        case NH_GFX_API_OPENGL : 
+            NH_GFX_CHECK(nh_opengl_endRecording(Viewport_p))
+            break;
         default : NH_GFX_DIAGNOSTIC_END(NH_GFX_ERROR_BAD_STATE)
     }
 
diff --git a/src/lib/nhgfx/Common/IndexMap.c b/src/lib/nhgfx/Common/IndexMap.c
index 3185963..2268292 100644
--- a/src/lib/nhgfx/Common/IndexMap.c
+++ b/src/lib/nhgfx/Common/IndexMap.c
@@ -79,7 +79,7 @@ NH_GFX_BEGIN()
     {
         int count = 0;
         const NH_BYTE **names_pp = NULL;
-        if (nh_gfx_getNames(type, (NH_BYTE***)&names_pp, &count) != NH_SUCCESS) {
+        if (nh_gfx_getNames(type, (NH_BYTE***)&names_pp, &count) != NH_GFX_SUCCESS) {
             NH_GFX_DIAGNOSTIC_END(NH_GFX_ERROR_BAD_STATE)
         }
 
diff --git a/src/lib/nhgfx/Common/Initialize.c b/src/lib/nhgfx/Common/Initialize.c
index 8eeeec0..d730b1a 100644
--- a/src/lib/nhgfx/Common/Initialize.c
+++ b/src/lib/nhgfx/Common/Initialize.c
@@ -9,6 +9,7 @@
 // INCLUDE =========================================================================================
 
 #include "Initialize.h"
+#include "IndexMap.h"
 #include "Config.h"
 #include "Macros/Macros.h"
 
@@ -16,6 +17,8 @@
 #include NH_GFX_DEFAULT_CHECK
 
 #include "../Vulkan/Vulkan.h"
+#include "../OpenGL/OpenGL.h"
+
 #include "../Fonts/FontManager.h"
 
 #include &ltstdlib.h>
@@ -28,9 +31,11 @@ NH_GFX_RESULT nh_gfx_initialize()
 {
     _nh_gfx_initConfig();
 
+    NH_GFX_CHECK(nh_gfx_createIndexMap())
     NH_GFX_CHECK(nh_gfx_initializeFontManager())
     NH_GFX_CHECK(nh_gfx_addInitialFonts())
 
     nh_vk_initVulkan();
+    nh_opengl_initOpenGL();
 }
 
diff --git a/src/lib/nhgfx/Common/Terminate.c b/src/lib/nhgfx/Common/Terminate.c
index 23dce1a..99d55e6 100644
--- a/src/lib/nhgfx/Common/Terminate.c
+++ b/src/lib/nhgfx/Common/Terminate.c
@@ -9,6 +9,7 @@
 // INCLUDE =========================================================================================
 
 #include "Terminate.h"
+#include "IndexMap.h"
 #include "Macros/Macros.h"
 
 #include NH_GFX_FLOW
@@ -26,6 +27,7 @@ NH_GFX_RESULT nh_gfx_terminate()
 {
 NH_GFX_BEGIN()
 
+    nh_gfx_freeIndexMap();
     nh_gfx_terminateFontManager();
 
 NH_GFX_DIAGNOSTIC_END(NH_GFX_SUCCESS)
diff --git a/src/lib/nhgfx/Common/Types/Private.h b/src/lib/nhgfx/Common/Types/Private.h
index c1cae69..f10ad7c 100644
--- a/src/lib/nhgfx/Common/Types/Private.h
+++ b/src/lib/nhgfx/Common/Types/Private.h
@@ -11,13 +11,24 @@
 
 #include "Public.h"
 
-// TODO Maybe we can download this file instead of requiring it from the system.
-#include &ltGL/glx.h>
-
 #ifndef VOLK_VULKAN_H_PATH
     #define VOLK_VULKAN_H_PATH "vulkan.h"
 #endif
-#include "../Vulkan/volk.h"
+
+//#ifdef NETZHAUT_VULKAN
+    #include "../Vulkan/volk.h"
+//#endif
+
+#ifdef NETZHAUT_OPENGL_IMPLEMENTATION
+    #define SOGL_IMPLEMENTATION_X11
+#endif
+
+//#ifdef NETZHAUT_OPENGL
+    #define SOGL_MAJOR_VERSION 4
+    #define SOGL_MINOR_VERSION 6
+    #include "../OpenGL/simple-opengl-loader.h"
+    #include "../OpenGL/glx.h"
+//#endif
 
 #endif
 
diff --git a/src/lib/nhgfx/Fonts/Text.c b/src/lib/nhgfx/Fonts/Text.c
index 51fa624..44ba0f9 100644
--- a/src/lib/nhgfx/Fonts/Text.c
+++ b/src/lib/nhgfx/Fonts/Text.c
@@ -181,8 +181,8 @@ NH_GFX_BEGIN()
         nh_gfx_HarfBuzzGlyphInfo *Infos_p = nh_gfx_getHarfBuzzGlyphInfos(Buffer, &glyphs);
 
         for (int i = 0; i &lt glyphs; ++i) {
-            int xAdvance = Infos_p[i].xAdvance/(float)(Segment_p->FontInstance_p->hres*64);
-            width += xAdvance;
+//            int xAdvance = Infos_p[i].xAdvance/(float)(Segment_p->FontInstance_p->hres*64);
+            width += Infos_p[i].xAdvance;
         }
 
         nh_free(Infos_p);
diff --git a/src/lib/nhgfx/OpenGL/API.c b/src/lib/nhgfx/OpenGL/API.c
index 79aae95..ecc7c7a 100644
--- a/src/lib/nhgfx/OpenGL/API.c
+++ b/src/lib/nhgfx/OpenGL/API.c
@@ -25,11 +25,15 @@ const NH_BYTE *NH_GFX_OPENGL_COMMAND_NAMES_PP[] = {
     "glAlphaFunc",
     "glAreTexturesResident",
     "glArrayElement",
+    "glAttachShader",
     "glBegin",
     "glEnd",
+    "glBindBuffer",
     "glBindTexture",
+    "glBindVertexArray",
     "glBitmap",
     "glBlendFunc",
+    "glBufferData",
     "glCallList",
     "glCallLists",
     "glClear",
@@ -76,11 +80,14 @@ const NH_BYTE *NH_GFX_OPENGL_COMMAND_NAMES_PP[] = {
     "glColorPointer",
     "glColorTableEXT",
     "glColorSubTableEXT",
+    "glCompileShader",
     "glCopyPixels",
     "glCopyTexImage1D",
     "glCopyTexImage2D",
     "glCopyTexSubImage1D",
     "glCopyTexSubImage2D",
+    "glCreateProgram",
+    "glCreateShader",
     "glCullFace",
     "glDeleteLists",
     "glDeleteTextures",
@@ -95,6 +102,7 @@ const NH_BYTE *NH_GFX_OPENGL_COMMAND_NAMES_PP[] = {
     "glEdgeFlagv",
     "glEdgeFlagPointer",
     "glEnable",
+    "glEnableVertexAttribArray",
     "glDisable",
     "glEnableClientState",
     "glDisableClientState",
@@ -119,8 +127,10 @@ const NH_BYTE *NH_GFX_OPENGL_COMMAND_NAMES_PP[] = {
     "glFogiv",
     "glFrontFace",
     "glFrustum",
+    "glGenBuffers",
     "glGenLists",
     "glGenTextures",
+    "glGenVertexArrays",
     "glGetBooleanv",
     "glGetClipPlane",
     "glGetColorTableEXT",
@@ -179,6 +189,7 @@ const NH_BYTE *NH_GFX_OPENGL_COMMAND_NAMES_PP[] = {
     "glLightModeliv",
     "glLineStipple",
     "glLineWidth",
+    "glLinkProgram",
     "glListBase",
     "glLoadIdentity",
     "glLoadMatrixd",
@@ -278,6 +289,7 @@ const NH_BYTE *NH_GFX_OPENGL_COMMAND_NAMES_PP[] = {
     "glScissor",
     "glSelectBuffer",
     "glShadeModel",
+    "glShaderSource",
     "glStencilFunc",
     "glStencilMask",
     "glStencilOp",
@@ -333,6 +345,7 @@ const NH_BYTE *NH_GFX_OPENGL_COMMAND_NAMES_PP[] = {
     "glTexSubImage2D",
     "glTranslated",
     "glTranslatef",
+    "glUseProgram",
     "glVertex2d", 
     "glVertex2f",
     "glVertex2i",
@@ -357,6 +370,7 @@ const NH_BYTE *NH_GFX_OPENGL_COMMAND_NAMES_PP[] = {
     "glVertex4fv",
     "glVertex4iv",
     "glVertex4sv", 
+    "glVertexAttribPointer",
     "glVertexPointer",
     "glViewport",
 };
@@ -366,17 +380,21 @@ size_t NH_GFX_OPENGL_COMMAND_NAMES_PP_COUNT =
 
 // COMMAND PARAMETER COUNTS ========================================================================
 
-static const int commandParameterCounts_p[] = {
+const int NH_GFX_OPENGL_COMMAND_PARAMETER_COUNTS_P[] = {
     2, // glAccum
     4, // glAddSwapHintRectWIN
     2, // glAlphaFunc
     3, // glAreTexturesResident
     1, // glArrayElement
+    2, // glAttachShader
     1, // glBegin
     0, // glEnd
+    2, // glBindBuffer
     2, // glBindTexture
+    1, // glBindVertexArray
     7, // glBitmap
     2, // glBlendFunc
+    4, // glBufferData
     1, // glCallList
     3, // glCallLists
     1, // glClear
@@ -423,11 +441,14 @@ static const int commandParameterCounts_p[] = {
     4, // glColorPointer
     6, // glColorTableEXT
     6, // glColorSubTableEXT
+    1, // glCompileShader
     5, // glCopyPixels
     7, // glCopyTexImage1D
     8, // glCopyTexImage2D
     6, // glCopyTexSubImage1D
     8, // glCopyTexSubImage2D
+    0, // glCreateProgram
+    1, // glCreateShader
     1, // glCullFace
     2, // glDeleteLists
     2, // glDeleteTextures
@@ -442,6 +463,7 @@ static const int commandParameterCounts_p[] = {
     1, // glEdgeFlagv
     2, // glEdgeFlagPointer
     1, // glEnable
+    1, // glEnableVertexAttribArray
     1, // glDisable
     1, // glEnableClientState
     1, // glDisableClientState
@@ -466,8 +488,10 @@ static const int commandParameterCounts_p[] = {
     2, // glFogiv
     1, // glFrontFace
     6, // glFrustum
+    2, // glGenBuffers
     1, // glGenLists
     2, // glGenTextures
+    2, // glGenVertexArrays
     2, // glGetBooleanv
     2, // glGetClipPlane
     4, // glGetColorTableEXT
@@ -526,6 +550,7 @@ static const int commandParameterCounts_p[] = {
     2, // glLightModeliv
     2, // glLineStipple
     1, // glLineWidth
+    1, // glLinkProgram
     1, // glListBase
     0, // glLoadIdentity
     1, // glLoadMatrixd
@@ -625,6 +650,7 @@ static const int commandParameterCounts_p[] = {
     4, // glScissor
     2, // glSelectBuffer
     1, // glShadeModel
+    4, // glShaderSource
     3, // glStencilFunc
     1, // glStencilMask
     3, // glStencilOp
@@ -680,6 +706,7 @@ static const int commandParameterCounts_p[] = {
     9, // glTexSubImage2D
     3, // glTranslated
     3, // glTranslatef
+    1, // glUseProgram
     2, // glVertex2d
     2, // glVertex2f
     2, // glVertex2i
@@ -704,10 +731,14 @@ static const int commandParameterCounts_p[] = {
     1, // glVertex4fv
     1, // glVertex4iv
     1, // glVertex4sv
+    6, // glVertexAttribPointer
     4, // glVertexPointer
     4, // glViewport
 };
 
+size_t NH_GFX_OPENGL_COMMAND_PARAMETER_COUNTS_P_COUNT = 
+    sizeof(NH_GFX_OPENGL_COMMAND_PARAMETER_COUNTS_P) / sizeof(NH_GFX_OPENGL_COMMAND_PARAMETER_COUNTS_P[0]);
+
 // GET TYPE ========================================================================================
 
 NH_GFX_OPENGL_COMMAND_E nh_opengl_getCommandType(
@@ -725,6 +756,6 @@ int nh_opengl_getCommandParameterCount(
     NH_GFX_OPENGL_COMMAND_E type)
 {
 NH_GFX_BEGIN()
-NH_GFX_END(commandParameterCounts_p[type])
+NH_GFX_END(NH_GFX_OPENGL_COMMAND_PARAMETER_COUNTS_P[type])
 }
 
diff --git a/src/lib/nhgfx/OpenGL/API.h b/src/lib/nhgfx/OpenGL/API.h
index b6b264c..f09e284 100644
--- a/src/lib/nhgfx/OpenGL/API.h
+++ b/src/lib/nhgfx/OpenGL/API.h
@@ -20,6 +20,9 @@
     extern const NH_BYTE *NH_GFX_OPENGL_COMMAND_NAMES_PP[];
     extern size_t NH_GFX_OPENGL_COMMAND_NAMES_PP_COUNT;
 
+    extern const int NH_GFX_OPENGL_COMMAND_PARAMETER_COUNTS_P[];
+    extern size_t NH_GFX_OPENGL_COMMAND_PARAMETER_COUNTS_P_COUNT;
+ 
 /** @} */
 
 /** @addtogroup lib_nhgfx_enums
@@ -32,11 +35,15 @@
         NH_GFX_OPENGL_COMMAND_GLALPHAFUNC,
         NH_GFX_OPENGL_COMMAND_GLARETEXTURESRESIDENT,
         NH_GFX_OPENGL_COMMAND_GLARRAYELEMENT,
+        NH_GFX_OPENGL_COMMAND_GLATTACHSHADER,
         NH_GFX_OPENGL_COMMAND_GLBEGIN,
         NH_GFX_OPENGL_COMMAND_GLEND,
+        NH_GFX_OPENGL_COMMAND_GLBINDBUFFER,
         NH_GFX_OPENGL_COMMAND_GLBINDTEXTURE,
+        NH_GFX_OPENGL_COMMAND_GLBINDVERTEXARRAY,
         NH_GFX_OPENGL_COMMAND_GLBITMAP,
         NH_GFX_OPENGL_COMMAND_GLBLENDFUNC,
+        NH_GFX_OPENGL_COMMAND_GLBUFFERDATA,
         NH_GFX_OPENGL_COMMAND_GLCALLLIST,
         NH_GFX_OPENGL_COMMAND_GLCALLLISTS,
         NH_GFX_OPENGL_COMMAND_GLCLEAR,
@@ -83,11 +90,14 @@
         NH_GFX_OPENGL_COMMAND_GLCOLORPOINTER,
         NH_GFX_OPENGL_COMMAND_GLCOLORTABLEEXT,
         NH_GFX_OPENGL_COMMAND_GLCOLORSUBTABLEEXT,
+        NH_GFX_OPENGL_COMMAND_GLCOMPILESHADER,
         NH_GFX_OPENGL_COMMAND_GLCOPYPIXELS,
         NH_GFX_OPENGL_COMMAND_GLCOPYTEXIMAGE1D,
         NH_GFX_OPENGL_COMMAND_GLCOPYTEXIMAGE2D,
         NH_GFX_OPENGL_COMMAND_GLCOPYTEXSUBIMAGE1D,
         NH_GFX_OPENGL_COMMAND_GLCOPYTEXSUBIMAGE2D,
+        NH_GFX_OPENGL_COMMAND_GLCREATEPROGRAM,
+        NH_GFX_OPENGL_COMMAND_GLCREATESHADER,
         NH_GFX_OPENGL_COMMAND_GLCULLFACE,
         NH_GFX_OPENGL_COMMAND_GLDELETELISTS,
         NH_GFX_OPENGL_COMMAND_GLDELETETEXTURES,
@@ -102,6 +112,7 @@
         NH_GFX_OPENGL_COMMAND_GLEDGEFLAGV,
         NH_GFX_OPENGL_COMMAND_GLEDGEFLAGPOINTER,
         NH_GFX_OPENGL_COMMAND_GLENABLE,
+        NH_GFX_OPENGL_COMMAND_GLENABLEVERTEXATTRIBARRAY,
         NH_GFX_OPENGL_COMMAND_GLDISABLE,
         NH_GFX_OPENGL_COMMAND_GLENABLECLIENTSTATE,
         NH_GFX_OPENGL_COMMAND_GLDISABLECLIENTSTATE,
@@ -126,8 +137,10 @@
         NH_GFX_OPENGL_COMMAND_GLFOGIV,
         NH_GFX_OPENGL_COMMAND_GLFRONTFACE,
         NH_GFX_OPENGL_COMMAND_GLFRUSTUM,
+        NH_GFX_OPENGL_COMMAND_GLGENBUFFERS,
         NH_GFX_OPENGL_COMMAND_GLGENLISTS,
         NH_GFX_OPENGL_COMMAND_GLGENTEXTURES,
+        NH_GFX_OPENGL_COMMAND_GLGENVERTEXARRAYS,
         NH_GFX_OPENGL_COMMAND_GLGETBOOLEANV,
         NH_GFX_OPENGL_COMMAND_GLGETCLIPPLANE,
         NH_GFX_OPENGL_COMMAND_GLGETCOLORTABLEEXT,
@@ -285,6 +298,7 @@
         NH_GFX_OPENGL_COMMAND_GLSCISSOR,
         NH_GFX_OPENGL_COMMAND_GLSELECTBUFFER,
         NH_GFX_OPENGL_COMMAND_GLSHADEMODEL,
+        NH_GFX_OPENGL_COMMAND_GLSHADERSOURCE,
         NH_GFX_OPENGL_COMMAND_GLSTENCILFUNC,
         NH_GFX_OPENGL_COMMAND_GLSTENCILMASK,
         NH_GFX_OPENGL_COMMAND_GLSTENCILOP,
@@ -340,6 +354,7 @@
         NH_GFX_OPENGL_COMMAND_GLTEXSUBIMAGE2D,
         NH_GFX_OPENGL_COMMAND_GLTRANSLATED,
         NH_GFX_OPENGL_COMMAND_GLTRANSLATEF,
+        NH_GFX_OPENGL_COMMAND_GLUSEPROGRAM,
         NH_GFX_OPENGL_COMMAND_GLVERTEX2D, 
         NH_GFX_OPENGL_COMMAND_GLVERTEX2F,
         NH_GFX_OPENGL_COMMAND_GLVERTEX2I,
@@ -364,6 +379,7 @@
         NH_GFX_OPENGL_COMMAND_GLVERTEX4FV,
         NH_GFX_OPENGL_COMMAND_GLVERTEX4IV,
         NH_GFX_OPENGL_COMMAND_GLVERTEX4SV,
+        NH_GFX_OPENGL_COMMAND_GLVERTEXATTRIBPOINTER,
         NH_GFX_OPENGL_COMMAND_GLVERTEXPOINTER,
         NH_GFX_OPENGL_COMMAND_GLVIEWPORT,
    NH_GFX_OPENGL_COMMAND_UNDEFINED,
diff --git a/src/lib/nhgfx/OpenGL/CommandBuffer.c b/src/lib/nhgfx/OpenGL/CommandBuffer.c
index 0e52658..4a83b1e 100644
--- a/src/lib/nhgfx/OpenGL/CommandBuffer.c
+++ b/src/lib/nhgfx/OpenGL/CommandBuffer.c
@@ -37,19 +37,20 @@ NH_GFX_BEGIN()
 NH_GFX_END(CommandBuffer)
 }
 
-static nh_opengl_Data *nh_opengl_addCommandArgument(
-    nh_opengl_Command *Command_p, nh_opengl_Data *Data_p)
+// TODO Fix memory leaks
+void nh_opengl_freeCommand(
+    nh_opengl_Command *Command_p)
 {
 NH_GFX_BEGIN()
 
-    nh_opengl_Data *Result_p = nh_allocate(sizeof(nh_opengl_Data));
-    NH_GFX_CHECK_MEM(NULL, Result_p)
-
-    memcpy(Result_p, Data_p, sizeof(nh_opengl_Data));
+    for (int i = 0; i &lt Command_p->Arguments.size; ++i) {
+        nh_opengl_freeData((nh_opengl_Data*)Command_p->Arguments.pp[i]);
+    }
 
-    nh_appendToList(&Command_p->Arguments, Data_p);
+    nh_freeList(&Command_p->Arguments, NH_FALSE);
+    nh_free(Command_p);
 
-NH_GFX_END(Result_p)
+NH_GFX_SILENT_END()
 }
 
 nh_opengl_Command *nh_opengl_addCommand(
@@ -61,17 +62,24 @@ NH_GFX_BEGIN()
     NH_GFX_CHECK_MEM(NULL, Command_p)
 
     NH_GFX_OPENGL_COMMAND_E type = nh_opengl_getCommandType(name_p);
-    if (type == NH_GFX_OPENGL_COMMAND_UNDEFINED) {NH_GFX_END(NULL)}
-    Command_p->type = type;
-    Command_p->Arguments = nh_initList(5);
+    if (type == NH_GFX_OPENGL_COMMAND_UNDEFINED) {
+        nh_free(Command_p);
+        NH_GFX_END(NULL)
+    }
 
-    va_list args;
-    va_start(args, name_p);
-    for(int i = 0; i &lt 5; i++) {
-        nh_opengl_Data Data = va_arg(args, nh_opengl_Data);
-        NH_GFX_CHECK_NULL(NULL, nh_opengl_addCommandArgument(Command_p, &Data))
+    int arguments = nh_opengl_getCommandParameterCount(type);
+
+    Command_p->type = type;
+    Command_p->Arguments = nh_initList(arguments);
+    Command_p->Result = nh_opengl_initData();
+
+    va_list args_p;
+    va_start(args_p, name_p);
+    for(int i = 0; i &lt arguments; i++) {
+        nh_opengl_Data *Data_p = va_arg(args_p, nh_opengl_Data*);
+        nh_appendToList(&Command_p->Arguments, Data_p);
     }
-    va_end(args);
+    va_end(args_p);
 
     nh_appendToList(&CommandBuffer_p->Commands, Command_p);
 
@@ -90,3 +98,30 @@ NH_GFX_BEGIN()
 NH_GFX_END(NH_GFX_SUCCESS)
 }
 
+NH_GFX_RESULT nh_opengl_freeCommandBuffer(
+    nh_opengl_CommandBuffer *CommandBuffer_p)
+{
+NH_GFX_BEGIN()
+
+    for (int i = 0; i &lt CommandBuffer_p->Commands.size; ++i) {
+        nh_opengl_freeCommand(CommandBuffer_p->Commands.pp[i]);
+    }
+
+    nh_freeList(&CommandBuffer_p->Commands, NH_FALSE);
+    *CommandBuffer_p = nh_opengl_initCommandBuffer();
+
+NH_GFX_END(NH_GFX_SUCCESS)
+}
+
+NH_GFX_RESULT nh_opengl_appendCommandBuffer(
+    nh_opengl_CommandBuffer *CommandBuffer_p, nh_opengl_CommandBuffer *ToBeAppended_p)
+{
+NH_GFX_BEGIN()
+
+    for (int i = 0; i &lt ToBeAppended_p->Commands.size; ++i) {
+        nh_appendToList(&CommandBuffer_p->Commands, ToBeAppended_p->Commands.pp[i]);
+    }
+
+NH_GFX_END(NH_GFX_SUCCESS)
+}
+
diff --git a/src/lib/nhgfx/OpenGL/CommandBuffer.h b/src/lib/nhgfx/OpenGL/CommandBuffer.h
index 6f04ad8..98b36a7 100644
--- a/src/lib/nhgfx/OpenGL/CommandBuffer.h
+++ b/src/lib/nhgfx/OpenGL/CommandBuffer.h
@@ -47,6 +47,14 @@
         nh_opengl_CommandBuffer *CommandBuffer_p
     );
 
+    NH_GFX_RESULT nh_opengl_freeCommandBuffer(
+        nh_opengl_CommandBuffer *CommandBuffer_p
+    );
+
+    NH_GFX_RESULT nh_opengl_appendCommandBuffer(
+        nh_opengl_CommandBuffer *CommandBuffer_p, nh_opengl_CommandBuffer *ToBeAppended_p
+    );
+
 /** @} */
 
 #endif
diff --git a/src/lib/nhgfx/OpenGL/Commands.c b/src/lib/nhgfx/OpenGL/Commands.c
index 00a497c..e12d164 100644
--- a/src/lib/nhgfx/OpenGL/Commands.c
+++ b/src/lib/nhgfx/OpenGL/Commands.c
@@ -31,14 +31,78 @@
 // nh_opengl_glAlphaFunc
 // nh_opengl_glAreTexturesResident
 // nh_opengl_glArrayElement
+
+static NH_GFX_RESULT nh_opengl_glAttachShader(
+    nh_opengl_Command *Command_p)
+{
+NH_GFX_BEGIN()
+
+    glAttachShader(
+        *((GLuint*)((nh_opengl_Data*)Command_p->Arguments.pp[0])->p),
+        *((GLuint*)((nh_opengl_Data*)Command_p->Arguments.pp[1])->p));
+
+NH_GFX_END(NH_GFX_SUCCESS)
+}
+
 // nh_opengl_glBegin
 // nh_opengl_glEnd
+
+static NH_GFX_RESULT nh_opengl_glBindBuffer(
+    nh_opengl_Command *Command_p)
+{
+NH_GFX_BEGIN()
+
+    glBindBuffer(
+        *((GLenum*)((nh_opengl_Data*)Command_p->Arguments.pp[0])->p),
+        *((GLuint*)((nh_opengl_Data*)Command_p->Arguments.pp[1])->p));
+
+NH_GFX_END(NH_GFX_SUCCESS)
+}
+
 // nh_opengl_glBindTexture
+
+static NH_GFX_RESULT nh_opengl_glBindVertexArray(
+    nh_opengl_Command *Command_p)
+{
+NH_GFX_BEGIN()
+
+    glBindVertexArray(
+        *((GLuint*)((nh_opengl_Data*)Command_p->Arguments.pp[0])->p));
+
+NH_GFX_END(NH_GFX_SUCCESS)
+}
+
 // nh_opengl_glBitmap
 // nh_opengl_glBlendFunc
+
+static NH_GFX_RESULT nh_opengl_glBufferData(
+    nh_opengl_Command *Command_p)
+{
+NH_GFX_BEGIN()
+
+    glBufferData(
+        *((GLenum*)((nh_opengl_Data*)Command_p->Arguments.pp[0])->p),
+       *(GLsizeiptr*)((nh_opengl_Data*)Command_p->Arguments.pp[1])->p,
+      (const void*)((nh_opengl_Data*)Command_p->Arguments.pp[2])->p,
+        *((GLenum*)((nh_opengl_Data*)Command_p->Arguments.pp[3])->p));
+
+NH_GFX_END(NH_GFX_SUCCESS)
+}
+
 // nh_opengl_glCallList
 // nh_opengl_glCallLists
-// nh_opengl_glClear
+
+static NH_GFX_RESULT nh_opengl_glClear(
+    nh_opengl_Command *Command_p)
+{
+NH_GFX_BEGIN()
+
+    glClear(
+        *((GLint*)((nh_opengl_Data*)Command_p->Arguments.pp[0])->p));
+
+NH_GFX_END(NH_GFX_SUCCESS)
+}
+
 // nh_opengl_glClearAccum
 
 static NH_GFX_RESULT nh_opengl_glClearColor(
@@ -50,8 +114,7 @@ NH_GFX_BEGIN()
         *((GLfloat*)((nh_opengl_Data*)Command_p->Arguments.pp[0])->p),
         *((GLfloat*)((nh_opengl_Data*)Command_p->Arguments.pp[1])->p),
         *((GLfloat*)((nh_opengl_Data*)Command_p->Arguments.pp[2])->p),
-        *((GLfloat*)((nh_opengl_Data*)Command_p->Arguments.pp[3])->p)
-    );
+        *((GLfloat*)((nh_opengl_Data*)Command_p->Arguments.pp[3])->p));
 
 NH_GFX_END(NH_GFX_SUCCESS)
 }
@@ -97,18 +160,66 @@ NH_GFX_END(NH_GFX_SUCCESS)
 // nh_opengl_glColorPointer
 // nh_opengl_glColorTableEXT
 // nh_opengl_glColorSubTableEXT
+
+static NH_GFX_RESULT nh_opengl_glCompileShader(
+    nh_opengl_Command *Command_p)
+{
+NH_GFX_BEGIN()
+
+    glCompileShader(
+        *((GLuint*)((nh_opengl_Data*)Command_p->Arguments.pp[0])->p));
+
+NH_GFX_END(NH_GFX_SUCCESS)
+}
+
 // nh_opengl_glCopyPixels
 // nh_opengl_glCopyTexImage1D
 // nh_opengl_glCopyTexImage2D
 // nh_opengl_glCopyTexSubImage1D
 // nh_opengl_glCopyTexSubImage2D
+
+static NH_GFX_RESULT nh_opengl_glCreateProgram(
+    nh_opengl_Command *Command_p)
+{
+NH_GFX_BEGIN()
+
+    nh_opengl_gluint(&Command_p->Result, glCreateProgram());
+
+NH_GFX_END(NH_GFX_SUCCESS)
+}
+
+static NH_GFX_RESULT nh_opengl_glCreateShader(
+    nh_opengl_Command *Command_p)
+{
+NH_GFX_BEGIN()
+
+    nh_opengl_gluint(&Command_p->Result, 
+        glCreateShader(
+            *((GLenum*)((nh_opengl_Data*)Command_p->Arguments.pp[0])->p)));
+
+NH_GFX_END(NH_GFX_SUCCESS)
+}
+
 // nh_opengl_glCullFace
 // nh_opengl_glDeleteLists
 // nh_opengl_glDeleteTextures
 // nh_opengl_glDepthFunc
 // nh_opengl_glDepthMask
 // nh_opengl_glDepthRange
-// nh_opengl_glDrawArrays
+
+static NH_GFX_RESULT nh_opengl_glDrawArrays(
+    nh_opengl_Command *Command_p)
+{
+NH_GFX_BEGIN()
+
+    glDrawArrays(
+        *((GLenum*)((nh_opengl_Data*)Command_p->Arguments.pp[0])->p),
+        *((GLint*)((nh_opengl_Data*)Command_p->Arguments.pp[1])->p),
+        *((GLsizei*)((nh_opengl_Data*)Command_p->Arguments.pp[2])->p));
+
+NH_GFX_END(NH_GFX_SUCCESS)
+}
+
 // nh_opengl_glDrawBuffer
 // nh_opengl_glDrawElements
 // nh_opengl_glDrawPixels
@@ -116,6 +227,19 @@ NH_GFX_END(NH_GFX_SUCCESS)
 // nh_opengl_glEdgeFlagv
 // nh_opengl_glEdgeFlagPointer
 // nh_opengl_glEnable
+
+
+static NH_GFX_RESULT nh_opengl_glEnableVertexAttribArray(
+    nh_opengl_Command *Command_p)
+{
+NH_GFX_BEGIN()
+
+    glEnableVertexAttribArray(
+        *((GLuint*)((nh_opengl_Data*)Command_p->Arguments.pp[0])->p));
+
+NH_GFX_END(NH_GFX_SUCCESS)
+}
+
 // nh_opengl_glDisable
 // nh_opengl_glEnableClientState
 // nh_opengl_glDisableClientState
@@ -140,8 +264,34 @@ NH_GFX_END(NH_GFX_SUCCESS)
 // nh_opengl_glFogiv
 // nh_opengl_glFrontFace
 // nh_opengl_glFrustum
+
+static NH_GFX_RESULT nh_opengl_glGenBuffers(
+    nh_opengl_Command *Command_p)
+{
+NH_GFX_BEGIN()
+
+    glGenBuffers(
+        *((GLsizei*)((nh_opengl_Data*)Command_p->Arguments.pp[0])->p),
+           (GLuint*)((nh_opengl_Data*)Command_p->Arguments.pp[1])->p);
+
+NH_GFX_END(NH_GFX_SUCCESS)
+}
+
 // nh_opengl_glGenLists
 // nh_opengl_glGenTextures
+
+static NH_GFX_RESULT nh_opengl_glGenVertexArrays(
+    nh_opengl_Command *Command_p)
+{
+NH_GFX_BEGIN()
+
+    glGenVertexArrays(
+        *((GLsizei*)((nh_opengl_Data*)Command_p->Arguments.pp[0])->p),
+           (GLuint*)((nh_opengl_Data*)Command_p->Arguments.pp[1])->p);
+
+NH_GFX_END(NH_GFX_SUCCESS)
+}
+
 // nh_opengl_glGetBooleanv
 // nh_opengl_glGetClipPlane
 // nh_opengl_glGetColorTableEXT
@@ -200,6 +350,18 @@ NH_GFX_END(NH_GFX_SUCCESS)
 // nh_opengl_glLightModeliv
 // nh_opengl_glLineStipple
 // nh_opengl_glLineWidth
+
+static NH_GFX_RESULT nh_opengl_glLinkProgram(
+    nh_opengl_Command *Command_p)
+{
+NH_GFX_BEGIN()
+
+    glLinkProgram(
+        *((GLuint*)((nh_opengl_Data*)Command_p->Arguments.pp[0])->p));
+
+NH_GFX_END(NH_GFX_SUCCESS)
+}
+
 // nh_opengl_glListBase
 // nh_opengl_glLoadIdentity
 // nh_opengl_glLoadMatrixd
@@ -208,8 +370,8 @@ NH_GFX_END(NH_GFX_SUCCESS)
 // nh_opengl_glLogicOp
 // nh_opengl_glMap1d
 // nh_opengl_glMap1f
-// nh_opengl_ glMap2d
-// nh_opengl_ glMap2f
+// nh_opengl_glMap2d
+// nh_opengl_glMap2f
 // nh_opengl_glMapGrid1d
 // nh_opengl_glMapGrid1f
 // nh_opengl_glMapGrid2d
@@ -299,6 +461,21 @@ NH_GFX_END(NH_GFX_SUCCESS)
 // nh_opengl_glScissor
 // nh_opengl_glSelectBuffer
 // nh_opengl_glShadeModel
+
+static NH_GFX_RESULT nh_opengl_glShaderSource(
+    nh_opengl_Command *Command_p)
+{
+NH_GFX_BEGIN()
+
+    glShaderSource(
+        *((GLuint*)((nh_opengl_Data*)Command_p->Arguments.pp[0])->p),
+        *((GLsizei*)((nh_opengl_Data*)Command_p->Arguments.pp[1])->p),
+          (const GLchar**)((nh_opengl_Data*)Command_p->Arguments.pp[2])->pp,
+          (const GLint*)((nh_opengl_Data*)Command_p->Arguments.pp[3])->p);
+
+NH_GFX_END(NH_GFX_SUCCESS)
+}
+
 // nh_opengl_glStencilFunc
 // nh_opengl_glStencilMask
 // nh_opengl_glStencilOp
@@ -354,6 +531,18 @@ NH_GFX_END(NH_GFX_SUCCESS)
 // nh_opengl_glTexSubImage2D
 // nh_opengl_glTranslated
 // nh_opengl_glTranslatef
+
+static NH_GFX_RESULT nh_opengl_glUseProgram(
+    nh_opengl_Command *Command_p)
+{
+NH_GFX_BEGIN()
+
+    glUseProgram(
+        *((GLuint*)((nh_opengl_Data*)Command_p->Arguments.pp[0])->p));
+
+NH_GFX_END(NH_GFX_SUCCESS)
+}
+
 // nh_opengl_glVertex2d
 // nh_opengl_glVertex2f
 // nh_opengl_glVertex2i
@@ -378,6 +567,23 @@ NH_GFX_END(NH_GFX_SUCCESS)
 // nh_opengl_glVertex4fv
 // nh_opengl_glVertex4iv
 // nh_opengl_glVertex4sv
+
+static NH_GFX_RESULT nh_opengl_glVertexAttribPointer(
+    nh_opengl_Command *Command_p)
+{
+NH_GFX_BEGIN()
+
+    glVertexAttribPointer(
+        *((GLuint*)((nh_opengl_Data*)Command_p->Arguments.pp[0])->p),
+         *((GLint*)((nh_opengl_Data*)Command_p->Arguments.pp[1])->p),
+        *((GLenum*)((nh_opengl_Data*)Command_p->Arguments.pp[2])->p),
+     *((GLboolean*)((nh_opengl_Data*)Command_p->Arguments.pp[3])->p),
+       *((GLsizei*)((nh_opengl_Data*)Command_p->Arguments.pp[4])->p),
+      (const void*)((nh_opengl_Data*)Command_p->Arguments.pp[5])->p);
+
+NH_GFX_END(NH_GFX_SUCCESS)
+}
+
 // nh_opengl_glVertexPointer
 
 static NH_GFX_RESULT nh_opengl_glViewport(
@@ -389,8 +595,7 @@ NH_GFX_BEGIN()
         *((GLint*)((nh_opengl_Data*)Command_p->Arguments.pp[0])->p),
         *((GLint*)((nh_opengl_Data*)Command_p->Arguments.pp[1])->p),
         *((GLsizei*)((nh_opengl_Data*)Command_p->Arguments.pp[2])->p),
-        *((GLsizei*)((nh_opengl_Data*)Command_p->Arguments.pp[3])->p)
-    );
+        *((GLsizei*)((nh_opengl_Data*)Command_p->Arguments.pp[3])->p));
 
 NH_GFX_END(NH_GFX_SUCCESS)
 }
@@ -407,16 +612,20 @@ nh_opengl_command_f commands_p[] = {
     NULL, // nh_opengl_glAlphaFunc
     NULL, // nh_opengl_glAreTexturesResident
     NULL, // nh_opengl_glArrayElement
+    nh_opengl_glAttachShader,
     NULL, // nh_opengl_glBegin
     NULL, // nh_opengl_glEnd
+    nh_opengl_glBindBuffer,
     NULL, // nh_opengl_glBindTexture
+    nh_opengl_glBindVertexArray,
     NULL, // nh_opengl_glBitmap
     NULL, // nh_opengl_glBlendFunc
+    nh_opengl_glBufferData,
     NULL, // nh_opengl_glCallList
     NULL, // nh_opengl_glCallLists
-    NULL, // nh_opengl_glClear
+    nh_opengl_glClear,
     NULL, // nh_opengl_glClearAccum
-    nh_opengl_glClearColor, // nh_opengl_glClearColor
+    nh_opengl_glClearColor,
     NULL, // nh_opengl_glClearDepth
     NULL, // nh_opengl_glClearIndex
     NULL, // nh_opengl_glClearStencil
@@ -458,18 +667,21 @@ nh_opengl_command_f commands_p[] = {
     NULL, // nh_opengl_glColorPointer
     NULL, // nh_opengl_glColorTableEXT
     NULL, // nh_opengl_glColorSubTableEXT
+    nh_opengl_glCompileShader,
     NULL, // nh_opengl_glCopyPixels
     NULL, // nh_opengl_glCopyTexImage1D
     NULL, // nh_opengl_glCopyTexImage2D
     NULL, // nh_opengl_glCopyTexSubImage1D
     NULL, // nh_opengl_glCopyTexSubImage2D
+    nh_opengl_glCreateProgram,
+    nh_opengl_glCreateShader,
     NULL, // nh_opengl_glCullFace
     NULL, // nh_opengl_glDeleteLists
     NULL, // nh_opengl_glDeleteTextures
     NULL, // nh_opengl_glDepthFunc
     NULL, // nh_opengl_glDepthMask
     NULL, // nh_opengl_glDepthRange
-    NULL, // nh_opengl_glDrawArrays
+    nh_opengl_glDrawArrays,
     NULL, // nh_opengl_glDrawBuffer
     NULL, // nh_opengl_glDrawElements
     NULL, // nh_opengl_glDrawPixels
@@ -477,6 +689,7 @@ nh_opengl_command_f commands_p[] = {
     NULL, // nh_opengl_glEdgeFlagv
     NULL, // nh_opengl_glEdgeFlagPointer
     NULL, // nh_opengl_glEnable
+    nh_opengl_glEnableVertexAttribArray,
     NULL, // nh_opengl_glDisable
     NULL, // nh_opengl_glEnableClientState
     NULL, // nh_opengl_glDisableClientState
@@ -501,8 +714,10 @@ nh_opengl_command_f commands_p[] = {
     NULL, // nh_opengl_glFogiv
     NULL, // nh_opengl_glFrontFace
     NULL, // nh_opengl_glFrustum
+    nh_opengl_glGenBuffers,
     NULL, // nh_opengl_glGenLists
     NULL, // nh_opengl_glGenTextures
+    nh_opengl_glGenVertexArrays,
     NULL, // nh_opengl_glGetBooleanv
     NULL, // nh_opengl_glGetClipPlane
     NULL, // nh_opengl_glGetColorTableEXT
@@ -561,6 +776,7 @@ nh_opengl_command_f commands_p[] = {
     NULL, // nh_opengl_glLightModeliv
     NULL, // nh_opengl_glLineStipple
     NULL, // nh_opengl_glLineWidth
+    nh_opengl_glLinkProgram,
     NULL, // nh_opengl_glListBase
     NULL, // nh_opengl_glLoadIdentity
     NULL, // nh_opengl_glLoadMatrixd
@@ -569,8 +785,8 @@ nh_opengl_command_f commands_p[] = {
     NULL, // nh_opengl_glLogicOp
     NULL, // nh_opengl_glMap1d
     NULL, // nh_opengl_glMap1f
-    NULL, // nh_opengl_ glMap2d
-    NULL, // nh_opengl_ glMap2f
+    NULL, // nh_opengl_glMap2d
+    NULL, // nh_opengl_glMap2f
     NULL, // nh_opengl_glMapGrid1d
     NULL, // nh_opengl_glMapGrid1f
     NULL, // nh_opengl_glMapGrid2d
@@ -660,6 +876,7 @@ nh_opengl_command_f commands_p[] = {
     NULL, // nh_opengl_glScissor
     NULL, // nh_opengl_glSelectBuffer
     NULL, // nh_opengl_glShadeModel
+    nh_opengl_glShaderSource,
     NULL, // nh_opengl_glStencilFunc
     NULL, // nh_opengl_glStencilMask
     NULL, // nh_opengl_glStencilOp
@@ -715,6 +932,7 @@ nh_opengl_command_f commands_p[] = {
     NULL, // nh_opengl_glTexSubImage2D
     NULL, // nh_opengl_glTranslated
     NULL, // nh_opengl_glTranslatef
+    nh_opengl_glUseProgram,
     NULL, // nh_opengl_glVertex2d
     NULL, // nh_opengl_glVertex2f
     NULL, // nh_opengl_glVertex2i
@@ -739,8 +957,9 @@ nh_opengl_command_f commands_p[] = {
     NULL, // nh_opengl_glVertex4fv
     NULL, // nh_opengl_glVertex4iv
     NULL, // nh_opengl_glVertex4sv
+    nh_opengl_glVertexAttribPointer,
     NULL, // nh_opengl_glVertexPointer
-    nh_opengl_glViewport, // nh_opengl_glViewport
+    nh_opengl_glViewport,
 };
 
 // EXECUTE COMMAND =================================================================================
diff --git a/src/lib/nhgfx/OpenGL/Data.c b/src/lib/nhgfx/OpenGL/Data.c
index d966d66..50fb7d5 100644
--- a/src/lib/nhgfx/OpenGL/Data.c
+++ b/src/lib/nhgfx/OpenGL/Data.c
@@ -12,7 +12,7 @@
 
 #include "../Common/Macros/Macros.h"
 #include NH_GFX_FLOW
-#include NH_GFX_DEFAULT_CHECK
+#include NH_GFX_CUSTOM_CHECK
 
 #include "../../nhcore/System/Memory.h"
 
@@ -21,96 +21,131 @@
 #include &ltstdio.h>
 #include &ltstdlib.h>
 
-// INIT ============================================================================================
+// CREATE ==========================================================================================
 
-static nh_opengl_Data nh_opengl_initData(
-    NH_GFX_OPENGL_DATA_E type)
+nh_opengl_Data nh_opengl_initData()
 {
 NH_GFX_BEGIN()
 
     nh_opengl_Data Data;
-    Data.id_p = NULL;
-    Data.type = type;
+    Data.type = 0;
+    Data.size = 0;
     Data.p = NULL;
+    Data.pp = NULL;
 
 NH_GFX_END(Data)
 }
 
-// DATA ============================================================================================
-
-nh_opengl_Data nh_opengl_glboolean(
-    GLboolean data)
+static nh_opengl_Data *nh_opengl_createData(
+    nh_opengl_Data *Data_p, NH_GFX_OPENGL_DATA_E type, int size, NH_BYTE *data_p, NH_BYTE **data_pp)
 {
 NH_GFX_BEGIN()
 
-    nh_opengl_Data Data = nh_opengl_initData(NH_GFX_OPENGL_DATA_GLBOOLEAN);
-    Data.p = nh_allocate(sizeof(GLboolean));
-    memcpy(Data.p, &data, sizeof(GLboolean));
+    if (!Data_p) {
+        Data_p = nh_allocate(sizeof(nh_opengl_Data));
+        NH_GFX_CHECK_MEM(NULL, Data_p)
+    }
 
-NH_GFX_END(Data)
+    Data_p->type = type;
+    Data_p->size = size;
+    Data_p->p = Data_p->size ? nh_allocate(Data_p->size) : NULL;
+    Data_p->pp = data_pp;
+
+    if (Data_p->size) {
+        NH_GFX_CHECK_MEM(NULL, Data_p->p)
+        memcpy(Data_p->p, data_p, Data_p->size);
+    }
+
+NH_GFX_END(Data_p)
 }
 
-nh_opengl_Data nh_opengl_glbyte(
-    GLbyte *data_p, int length)
+void nh_opengl_freeData(
+    nh_opengl_Data *Data_p)
 {
 NH_GFX_BEGIN()
 
-    nh_opengl_Data Data = nh_opengl_initData(NH_GFX_OPENGL_DATA_GLBYTE);
-    Data.p = nh_allocate(sizeof(GLbyte)*length);
-    memcpy(Data.p, data_p, sizeof(GLbyte)*length);
+    nh_free(Data_p->p);
+    nh_free(Data_p);
 
-NH_GFX_END(Data)
+NH_GFX_SILENT_END()
 }
 
-nh_opengl_Data nh_opengl_glint(
-    GLint data)
+// DATA ============================================================================================
+
+nh_opengl_Data *nh_opengl_glboolean(
+    nh_opengl_Data *Data_p, GLboolean data)
 {
 NH_GFX_BEGIN()
-
-    nh_opengl_Data Data = nh_opengl_initData(NH_GFX_OPENGL_DATA_GLINT);
-    Data.p = nh_allocate(sizeof(GLint));
-    memcpy(Data.p, &data, sizeof(GLint));
-
-NH_GFX_END(Data)
+NH_GFX_END(nh_opengl_createData(Data_p, NH_GFX_OPENGL_DATA_GLBOOLEAN, sizeof(GLboolean), (NH_BYTE*)&data, NULL))
 }
 
-nh_opengl_Data nh_opengl_gluint(
-    GLuint data)
+nh_opengl_Data *nh_opengl_glbyte(
+    nh_opengl_Data *Data_p, GLbyte *data_p, int length)
 {
 NH_GFX_BEGIN()
+NH_GFX_END(nh_opengl_createData(Data_p, NH_GFX_OPENGL_DATA_GLBYTE, sizeof(GLbyte)*length, (NH_BYTE*)data_p, NULL))
+}
 
-    nh_opengl_Data Data = nh_opengl_initData(NH_GFX_OPENGL_DATA_GLUINT);
-    Data.p = nh_allocate(sizeof(GLuint));
-    memcpy(Data.p, &data, sizeof(GLuint));
-
-NH_GFX_END(Data)
+nh_opengl_Data *nh_opengl_glubyte(
+    nh_opengl_Data *Data_p, GLubyte *data_p, int length)
+{
+NH_GFX_BEGIN()
+NH_GFX_END(nh_opengl_createData(Data_p, NH_GFX_OPENGL_DATA_GLUBYTE, sizeof(GLubyte)*length, (NH_UNSIGNED_BYTE*)data_p, NULL))
 }
 
-nh_opengl_Data nh_opengl_glfloat(
-    GLfloat data)
+nh_opengl_Data *nh_opengl_glint(
+    nh_opengl_Data *Data_p, GLint data)
 {
 NH_GFX_BEGIN()
+NH_GFX_END(nh_opengl_createData(Data_p, NH_GFX_OPENGL_DATA_GLINT, sizeof(GLint), (NH_BYTE*)&data, NULL))
+}
 
-    nh_opengl_Data Data = nh_opengl_initData(NH_GFX_OPENGL_DATA_GLFLOAT);
-    Data.p = nh_allocate(sizeof(GLfloat));
-    memcpy(Data.p, &data, sizeof(GLfloat));
+nh_opengl_Data *nh_opengl_gluint(
+    nh_opengl_Data *Data_p, GLuint data)
+{
+NH_GFX_BEGIN()
+NH_GFX_END(nh_opengl_createData(Data_p, NH_GFX_OPENGL_DATA_GLUINT, sizeof(GLuint), (NH_BYTE*)&data, NULL))
+}
 
-NH_GFX_END(Data)
+nh_opengl_Data *nh_opengl_glfloat(
+    nh_opengl_Data *Data_p, GLfloat data)
+{
+NH_GFX_BEGIN()
+NH_GFX_END(nh_opengl_createData(Data_p, NH_GFX_OPENGL_DATA_GLFLOAT, sizeof(GLfloat), (NH_BYTE*)&data, NULL))
 }
 
-// ID ==============================================================================================
+nh_opengl_Data *nh_opengl_glsizei(
+    nh_opengl_Data *Data_p, GLsizei data)
+{
+NH_GFX_BEGIN()
+NH_GFX_END(nh_opengl_createData(Data_p, NH_GFX_OPENGL_DATA_GLSIZEI, sizeof(GLsizei), (NH_BYTE*)&data, NULL))
+}
 
-// TODO Fix error handling.
-nh_opengl_Data nh_opengl_setId(
-    nh_opengl_Data Data, NH_BYTE *id_p)
+nh_opengl_Data *nh_opengl_glsizeiptr(
+    nh_opengl_Data *Data_p, GLsizeiptr data)
 {
 NH_GFX_BEGIN()
+NH_GFX_END(nh_opengl_createData(Data_p, NH_GFX_OPENGL_DATA_GLSIZEIPTR, sizeof(GLsizeiptr), (NH_BYTE*)&data, NULL))
+}
 
-    Data.id_p = nh_allocate(sizeof(NH_BYTE)*(strlen(id_p)+1));
-    if (!Data.id_p) {NH_GFX_END(Data)}
+nh_opengl_Data *nh_opengl_glchar(
+    nh_opengl_Data *Data_p, GLchar *data_p, int length, GLchar **data_pp)
+{
+NH_GFX_BEGIN()
+NH_GFX_END(nh_opengl_createData(Data_p, NH_GFX_OPENGL_DATA_GLBYTE, length, (NH_BYTE*)data_p, (NH_BYTE**)data_pp))
+}
 
-    strcpy(Data.id_p, id_p);
+nh_opengl_Data *nh_opengl_glenum(
+    nh_opengl_Data *Data_p, GLenum data)
+{
+NH_GFX_BEGIN()
+NH_GFX_END(nh_opengl_createData(Data_p, NH_GFX_OPENGL_DATA_GLENUM, sizeof(GLenum), (NH_BYTE*)&data, NULL))
+}
 
-NH_GFX_END(Data)
+nh_opengl_Data *nh_opengl_null(
+    nh_opengl_Data *Data_p, NH_GFX_OPENGL_DATA_E type)
+{
+NH_GFX_BEGIN()
+NH_GFX_END(nh_opengl_createData(Data_p, type, 0, NULL, NULL))
 }
 
diff --git a/src/lib/nhgfx/OpenGL/Data.h b/src/lib/nhgfx/OpenGL/Data.h
index b9edf8c..d0e2c08 100644
--- a/src/lib/nhgfx/OpenGL/Data.h
+++ b/src/lib/nhgfx/OpenGL/Data.h
@@ -9,6 +9,7 @@
  * Published under MIT
  */
 
+#define NETZHAUT_OPENGL
 #include "../Common/Types/Private.h"
 
 #endif
@@ -49,8 +50,9 @@
 
     typedef struct nh_opengl_Data {
         NH_GFX_OPENGL_DATA_E type;
-        NH_BYTE *id_p;
    void *p;
+        void *pp;
+        int size;
     } nh_opengl_Data;
 
 /** @} */
@@ -59,28 +61,55 @@
  *  @{
  */
 
-    nh_opengl_Data nh_opengl_glboolean(
-        GLboolean data
+    nh_opengl_Data *nh_opengl_glboolean(
+        nh_opengl_Data *Data_p, GLboolean data
     );
     
-    nh_opengl_Data nh_opengl_glbyte(
-        GLbyte *data_p, int length
+    nh_opengl_Data *nh_opengl_glbyte(
+        nh_opengl_Data *Data_p, GLbyte *data_p, int length
+    );
+
+    nh_opengl_Data *nh_opengl_glubyte(
+        nh_opengl_Data *Data_p, GLubyte *data_p, int length
     );
     
-    nh_opengl_Data nh_opengl_glint(
-        GLint data
+    nh_opengl_Data *nh_opengl_glint(
+        nh_opengl_Data *Data_p, GLint data
     );
     
-    nh_opengl_Data nh_opengl_gluint(
-        GLuint data
+    nh_opengl_Data *nh_opengl_gluint(
+        nh_opengl_Data *Data_p, GLuint data
     );
     
-    nh_opengl_Data nh_opengl_glfloat(
-        GLfloat data
+    nh_opengl_Data *nh_opengl_glfloat(
+        nh_opengl_Data *Data_p, GLfloat data
+    );
+
+    nh_opengl_Data *nh_opengl_glsizei(
+        nh_opengl_Data *Data_p, GLsizei data
+    );
+
+    nh_opengl_Data *nh_opengl_glsizeiptr(
+        nh_opengl_Data *Data_p, GLsizeiptr data
+    );
+
+    nh_opengl_Data *nh_opengl_glchar(
+        nh_opengl_Data *Data_p, GLchar *data_p, int length, GLchar **data_pp
+    );
+
+    nh_opengl_Data *nh_opengl_glenum(
+        nh_opengl_Data *Data_p, GLenum data
+    );
+
+    nh_opengl_Data *nh_opengl_null(
+        nh_opengl_Data *Data_p, NH_GFX_OPENGL_DATA_E type
+    );
+
+    nh_opengl_Data nh_opengl_initData(
     );
 
-    nh_opengl_Data nh_opengl_setId(
-        nh_opengl_Data Data, NH_BYTE *id_p
+    void nh_opengl_freeData(
+        nh_opengl_Data *Data_p
     );
 
 /** @} */
diff --git a/src/lib/nhgfx/OpenGL/OpenGL.c b/src/lib/nhgfx/OpenGL/OpenGL.c
new file mode 100644
index 0000000..e7727f5
--- /dev/null
+++ b/src/lib/nhgfx/OpenGL/OpenGL.c
@@ -0,0 +1,32 @@
+// LICENSE NOTICE ==================================================================================
+
+/**
+ * netzhaut - Web Browser Engine
+ * Copyright (C) 2020 The netzhaut Authors
+ * Published under MIT
+ */
+
+// INCLUDE =========================================================================================
+
+#include "OpenGL.h"
+
+#include "../Common/Macros/Macros.h"
+#include NH_GFX_FLOW
+#include NH_GFX_CUSTOM_CHECK
+
+// HOST ============================================================================================
+
+NH_GFX_RESULT nh_opengl_initOpenGL()
+{
+NH_GFX_BEGIN()
+
+    if (!sogl_loadOpenGL()) {
+        const NH_BYTE **failures_pp = sogl_getFailures();
+        while (*failures_pp) {
+            failures_pp++;
+        }
+    }
+
+NH_GFX_DIAGNOSTIC_END(NH_GFX_SUCCESS)
+}
+
diff --git a/src/lib/nhgfx/OpenGL/OpenGL.h b/src/lib/nhgfx/OpenGL/OpenGL.h
new file mode 100644
index 0000000..65b290a
--- /dev/null
+++ b/src/lib/nhgfx/OpenGL/OpenGL.h
@@ -0,0 +1,34 @@
+#ifndef NH_OPENGL_OPENGL_H
+#define NH_OPENGL_OPENGL_H
+
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+
+/**
+ * netzhaut - Web Browser Engine
+ * Copyright (C) 2020 The netzhaut Authors
+ * Published under MIT
+ */
+
+#define NETZHAUT_OPENGL
+#define NETZHAUT_OPENGL_IMPLEMENTATION
+
+#include "../Common/Types/Private.h"
+
+#endif
+
+/** @addtogroup lib_nhgfx_structs
+ *  @{
+ */
+
+/** @} */
+
+/** @addtogroup lib_nhgfx_functions
+ *  @{
+ */
+
+    NH_GFX_RESULT nh_opengl_initOpenGL(
+    );
+
+/** @} */
+
+#endif 
diff --git a/src/lib/nhgfx/OpenGL/Render.c b/src/lib/nhgfx/OpenGL/Render.c
index 0ff4355..d462186 100644
--- a/src/lib/nhgfx/OpenGL/Render.c
+++ b/src/lib/nhgfx/OpenGL/Render.c
@@ -9,9 +9,6 @@
 // INCLUDE =========================================================================================
 
 #include "Render.h"
-#include "Vulkan.h"
-#include "Surface.h"
-#include "GPU.h"
 
 #include "../Base/Viewport.h"
 #include "../Base/Surface.h"
@@ -22,73 +19,25 @@
 #include "../../nhcore/Util/List.h"
 #include "../../nhcore/System/Memory.h"
 
-#include &ltlimits.h>
-#include &ltstring.h>
-#include &ltstdio.h>
-#include &ltstdlib.h>
-#include &lttime.h>
+#include "../../nhwsi/Main/Window.h"
 
 // RENDER ==========================================================================================
 
 NH_GFX_RESULT nh_opengl_render(
-    nh_gfx_Surface *Surface_p)
+    nh_gfx_Surface *Surface_p, nh_List *SortedViewports_p)
 {
 NH_GFX_BEGIN()
 
     glXMakeCurrent(Surface_p->Window_p->X11.Display_p, Surface_p->Window_p->X11.XWindow, 
         Surface_p->OpenGL.Context_p);
-    glXSwapBuffers(Surface_p->Window_p->X11.Display_p, Surface_p->Window_p->X11.XWindow);
 
-NH_GFX_DIAGNOSTIC_END(NH_GFX_SUCCESS)
-}
-
-NH_GFX_RESULT nh_vk_render( // TODO multi GPU rendering
-    nh_gfx_Surface *Surface_p)
-{
-NH_GFX_BEGIN()
-
-    VkSemaphore *Semaphores_pp[2] = {&Surface_p->Vulkan.Sync.Semaphore_p[0], &Surface_p->Vulkan.Sync.Semaphore_p[1]};
-
-    nh_List Render = nh_initList(8);
-    
-    // find out which commandbuffers to render
-    for (int i = 0; i &lt Surface_p->Viewports.size; ++i) {
-        if (((nh_gfx_Viewport*)Surface_p->Viewports.pp[i])->Sync.render) {
-            nh_appendToList(&Render, Surface_p->Viewports.pp[i]);
-        }
+    for (int i = 0; i &lt SortedViewports_p->size; ++i) {
+        nh_gfx_Viewport *Viewport_p = SortedViewports_p->pp[i];
+        NH_GFX_CHECK(nh_opengl_executeCommandBuffer(Viewport_p->OpenGL.CommandBuffer_p))
     }
 
-    VkCommandBuffer *Commands_p = nh_allocate(sizeof(void*) * Render.size);
-    NH_GFX_CHECK_MEM(Commands_p)
-
-    VkCommandBuffer *SortedCommands_p = nh_allocate(sizeof(void*) * (Render.size + 1));
-    NH_GFX_CHECK_MEM(SortedCommands_p)
-
-    int *sortedIndices_p = nh_allocate(sizeof(int) * Render.size);
-    NH_GFX_CHECK_MEM(sortedIndices_p)
-
-    NH_BOOL *onTop_p = nh_allocate(sizeof(NH_BOOL) * Render.size);
-    NH_GFX_CHECK_MEM(onTop_p)
-
-    // insert clear commandbuffer
-    NH_GFX_CHECK(nh_vk_clearSurface(Surface_p, &Surface_p->Vulkan.GPU_p->Driver))
-    SortedCommands_p[0] = Surface_p->Vulkan.CommandBuffers_p[Surface_p->Vulkan.currentImage];
-
-    // get commandbuffers
-    for (int i = 0; i &lt Render.size; ++i) 
-    {
-        nh_gfx_Viewport *Viewport_p = Render.pp[i];
-        Viewport_p->Sync.submittedBuffers_p[Surface_p->Vulkan.currentImage]
-            = Viewport_p->Sync.newestBuffers_p[Surface_p->Vulkan.currentImage];
-
-//        while (Viewport_p->Sync.isRecording) {}
+    glXSwapBuffers(Surface_p->Window_p->X11.Display_p, Surface_p->Window_p->X11.XWindow);
 
-        Commands_p[i] = Viewport_p->Vulkan.CommandBuffers_p[
-            Viewport_p->Sync.submittedBuffers_p[
-                Surface_p->Vulkan.currentImage
-            ]
-        ];
-    }
+NH_GFX_DIAGNOSTIC_END(NH_GFX_SUCCESS)
+}
 
-    // sort commandbuffers based on tab priority (from low to high priority)
-    int max = 0;
diff --git a/src/lib/nhgfx/OpenGL/Render.h b/src/lib/nhgfx/OpenGL/Render.h
index 798840a..f4e6244 100644
--- a/src/lib/nhgfx/OpenGL/Render.h
+++ b/src/lib/nhgfx/OpenGL/Render.h
@@ -9,7 +9,6 @@
  * Published under MIT
  */
 
-#include "GPU.h"
 #include "Surface.h"
 
 #include "../Common/Types/Private.h"
@@ -21,7 +20,7 @@
  */
 
     NH_GFX_RESULT nh_opengl_render(
-        nh_gfx_Surface *Surface_p
+        nh_gfx_Surface *Surface_p, nh_List *SortedViewports_p
     );
 
 /** @} */
diff --git a/src/lib/nhgfx/OpenGL/Surface.c b/src/lib/nhgfx/OpenGL/Surface.c
index dff52c4..1bf01f2 100644
--- a/src/lib/nhgfx/OpenGL/Surface.c
+++ b/src/lib/nhgfx/OpenGL/Surface.c
@@ -77,7 +77,7 @@ NH_GFX_BEGIN()
     /* Set desired minimum OpenGL version */
     static int contextAttribs_p[] = {
         GLX_CONTEXT_MAJOR_VERSION_ARB, 4,
-        GLX_CONTEXT_MINOR_VERSION_ARB, 2,
+        GLX_CONTEXT_MINOR_VERSION_ARB, 6,
         None
     };
 
@@ -90,8 +90,10 @@ NH_GFX_BEGIN()
     }
 
     int bufferCount = 3;
+
     Surface_p->CommandBuffers_p = nh_allocate(sizeof(nh_opengl_CommandBuffer)*bufferCount);
     NH_GFX_CHECK_MEM(Surface_p->CommandBuffers_p)
+
     Surface_p->bufferCount = bufferCount;
     Surface_p->currentBuffer = 0;
 
diff --git a/src/lib/nhgfx/OpenGL/Viewport.c b/src/lib/nhgfx/OpenGL/Viewport.c
index f2feebe..35e466c 100644
--- a/src/lib/nhgfx/OpenGL/Viewport.c
+++ b/src/lib/nhgfx/OpenGL/Viewport.c
@@ -9,6 +9,7 @@
 // INCLUDE =========================================================================================
 
 #include "Viewport.h"
+#include "CommandBuffer.h"
 
 #include "../Base/Viewport.h"
 #include "../Common/Macros/Macros.h"
@@ -26,18 +27,9 @@ NH_GFX_RESULT nh_opengl_createViewport(
 {
 NH_GFX_BEGIN()
 
-//    nh_vk_Driver *Driver_p = &Viewport_p->Surface_p->Vulkan.GPU_p->Driver;
-//
-//    VkCommandBufferAllocateInfo AllocateInfo = {
-//        .sType              = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
-//        .commandPool        = Driver_p->GraphicsCommandPools_p[nh_getThreadIndex()],  
-//        .level              = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
-//        .commandBufferCount = 6,
-//    };
-//
-//    NH_GFX_CHECK_VULKAN(Driver_p->Functions.vkAllocateCommandBuffers(
-//        Driver_p->Device, &AllocateInfo, Viewport_p->Vulkan.CommandBuffers_p
-//    ))
+    Viewport_p->OpenGL.CommandBuffers_p[0] = nh_opengl_initCommandBuffer();
+    Viewport_p->OpenGL.CommandBuffers_p[1] = nh_opengl_initCommandBuffer();
+    Viewport_p->OpenGL.CommandBuffer_p = NULL;
 
 NH_GFX_DIAGNOSTIC_END(NH_GFX_SUCCESS)
 }
@@ -47,15 +39,6 @@ void nh_opengl_destroyViewport(
 {
 NH_GFX_BEGIN()
 
-//    nh_vk_Driver *Driver_p = &Viewport_p->Surface_p->Vulkan.GPU_p->Driver;
-//  
-//    Driver_p->Functions.vkFreeCommandBuffers(
-//        Driver_p->Device, 
-//        Driver_p->GraphicsCommandPools_p[nh_getThreadIndex()], 
-//        6,
-//        Viewport_p->Vulkan.CommandBuffers_p
-//    );
-
 NH_GFX_SILENT_END()
 }
 
@@ -66,81 +49,29 @@ NH_GFX_RESULT nh_opengl_beginRecording(
 {
 NH_GFX_BEGIN()
 
-//    nh_vk_Driver *Driver_p = &Viewport_p->Surface_p->Vulkan.GPU_p->Driver;
-//
-//    for (int i = 0; i &lt Viewport_p->OpenGL.images; ++i)
-//    {
-//        VkCommandBuffer *CommandBuffer_p = Viewport_p->Vulkan.CommandBuffers_pp[i];
-//        Driver_p->Functions.vkResetCommandBuffer(*CommandBuffer_p, VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT);
-//
-//        VkCommandBufferBeginInfo CommandBufferInfo = 
-//        {
-//            .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
-//            .flags = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT
-//        };
-//
-//        NH_GFX_CHECK_VULKAN(Driver_p->Functions.vkBeginCommandBuffer(*CommandBuffer_p, &CommandBufferInfo))
-//
-//        VkClearColorValue clearColorValue = {{
-//            Viewport_p->Settings.ClearColor.r,
-//            Viewport_p->Settings.ClearColor.g,
-//            Viewport_p->Settings.ClearColor.b,
-//            Viewport_p->Settings.ClearColor.a
-//        }};
-//        VkClearDepthStencilValue depthStencilValue =
-//        {
-//            .depth   = 1.0f,
-//            .stencil = 0
-//        };
-//        VkClearValue clearValues[2];
-//        clearValues[0].color        = clearColorValue;
-//        clearValues[1].depthStencil = depthStencilValue;
-//
-//        VkRenderPassBeginInfo RenderPassInfo =
-//        {
-//            .sType                    = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
-//            .renderPass               = Driver_p->RenderPass_p[0],
-//            .framebuffer              = Viewport_p->Surface_p->Vulkan.Framebuffer_p[i],
-//            .renderArea.offset.x      = 0,
-//            .renderArea.offset.y      = 0,
-//            .renderArea.extent.width  = Viewport_p->Surface_p->Vulkan.Extent2D.width,
-//            .renderArea.extent.height = Viewport_p->Surface_p->Vulkan.Extent2D.height,
-//            .clearValueCount          = 2,
-//            .pClearValues             = clearValues
-//        };
-//
-//        Driver_p->Functions.vkCmdBeginRenderPass(*CommandBuffer_p, &RenderPassInfo, VK_SUBPASS_CONTENTS_INLINE);
-//
-//        VkViewport Viewport = 
-//        { 
-//            .x        = Viewport_p->Settings.Position.x, 
-//            .y        = Viewport_p->Settings.Position.y, 
-//            .width    = Viewport_p->Settings.Size.width, 
-//            .height   = Viewport_p->Settings.Size.height, 
-//            .minDepth = 0.0f, 
-//            .maxDepth = 1.0f 
-//        };
-//
-//        VkRect2D Scissor = nh_vk_getDefaultScissor(Viewport_p->Settings.Size); 
-//        Scissor.offset.x = Viewport_p->Settings.Position.x;
-//        Scissor.offset.y = Viewport_p->Settings.Position.y;
-//
-//        Driver_p->Functions.vkCmdSetViewport(*CommandBuffer_p, 0, 1, &Viewport);
-//        Driver_p->Functions.vkCmdSetScissor(*CommandBuffer_p, 0, 1, &Scissor);
-//
-//        VkClearAttachment ClearAttachment = {
-//            .aspectMask      = VK_IMAGE_ASPECT_COLOR_BIT,
-//            .colorAttachment = 0,
-//            .clearValue      = clearValues[0],
-//        };
-//
-//        VkClearRect ClearRect = { 
-//            .rect           = Scissor,
-//            .baseArrayLayer = 0,
-//            .layerCount     = 1,
-//        };
-//        Driver_p->Functions.vkCmdClearAttachments(*CommandBuffer_p, 1, &ClearAttachment, 1, &ClearRect);
-//    }
+    nh_opengl_addCommand(
+        Viewport_p->OpenGL.CommandBuffer_p,
+        "glViewport",
+        nh_opengl_glint(NULL, Viewport_p->Settings.Position.x),
+        nh_opengl_glint(NULL, Viewport_p->Settings.Position.y),
+        nh_opengl_glsizei(NULL, Viewport_p->Settings.Size.width),
+        nh_opengl_glsizei(NULL, Viewport_p->Settings.Size.height)
+    );
+ 
+    nh_opengl_addCommand(
+        Viewport_p->OpenGL.CommandBuffer_p,
+        "glClearColor",
+        nh_opengl_glfloat(NULL, Viewport_p->Settings.ClearColor.r),
+        nh_opengl_glfloat(NULL, Viewport_p->Settings.ClearColor.g),
+        nh_opengl_glfloat(NULL, Viewport_p->Settings.ClearColor.b),
+        nh_opengl_glfloat(NULL, Viewport_p->Settings.ClearColor.a)
+    );
+
+    nh_opengl_addCommand(
+        Viewport_p->OpenGL.CommandBuffer_p,
+        "glClear",
+        nh_opengl_glint(NULL, GL_COLOR_BUFFER_BIT)
+    );
 
 NH_GFX_DIAGNOSTIC_END(NH_GFX_SUCCESS)
 }
@@ -150,10 +81,7 @@ NH_GFX_RESULT nh_opengl_endRecording(
 {
 NH_GFX_BEGIN()
 
-//    for (int i = 0; i &lt Viewport_p->Vulkan.images; ++i) {
-//        Viewport_p->Surface_p->Vulkan.GPU_p->Driver.Functions.vkCmdEndRenderPass(*Viewport_p->Vulkan.CommandBuffers_pp[i]);
-//        Viewport_p->Surface_p->Vulkan.GPU_p->Driver.Functions.vkEndCommandBuffer(*Viewport_p->Vulkan.CommandBuffers_pp[i]);
-//    }
+    // TODO Needs something to happen here?
 
 NH_GFX_DIAGNOSTIC_END(NH_GFX_SUCCESS)
 }
diff --git a/src/lib/nhgfx/OpenGL/Viewport.h b/src/lib/nhgfx/OpenGL/Viewport.h
index 6dc4dd2..5307964 100644
--- a/src/lib/nhgfx/OpenGL/Viewport.h
+++ b/src/lib/nhgfx/OpenGL/Viewport.h
@@ -20,7 +20,8 @@
  */
 
     typedef struct nh_opengl_Viewport {
-        nh_opengl_CommandBuffer CommandBuffers_p[3];
+        nh_opengl_CommandBuffer CommandBuffers_p[2];
+        nh_opengl_CommandBuffer *CommandBuffer_p;
     } nh_opengl_Viewport;
 
 /** @} */
diff --git a/src/lib/nhgfx/Vulkan/Driver.c b/src/lib/nhgfx/Vulkan/Driver.c
index f029efd..ad31e10 100644
--- a/src/lib/nhgfx/Vulkan/Driver.c
+++ b/src/lib/nhgfx/Vulkan/Driver.c
@@ -195,8 +195,10 @@ NH_GFX_BEGIN()
     Driver_p->Functions.vkDestroyDescriptorPool(Driver_p->Device, Driver_p->DescriptorPool_p[0], VK_NULL_HANDLE);
 
     for (int i = 0; i &lt NH_MAX_THREADS; ++i) {
-        Driver_p->Functions.vkDestroyCommandPool(Driver_p->Device, Driver_p->GraphicsCommandPools_p[i], VK_NULL_HANDLE);
-        Driver_p->Functions.vkDestroyCommandPool(Driver_p->Device, Driver_p->ComputeCommandPools_p[i], VK_NULL_HANDLE);
+        Driver_p->Functions.vkDestroyCommandPool(
+            Driver_p->Device, Driver_p->GraphicsCommandPools_p[i], VK_NULL_HANDLE);
+        Driver_p->Functions.vkDestroyCommandPool(
+            Driver_p->Device, Driver_p->ComputeCommandPools_p[i], VK_NULL_HANDLE);
     }
 
     Driver_p->Functions.vkDestroyRenderPass(Driver_p->Device, Driver_p->RenderPass_p[0], VK_NULL_HANDLE);
@@ -305,7 +307,8 @@ NH_GFX_BEGIN()
         .ppEnabledExtensionNames = deviceExtensions_pp,
         .enabledLayerCount       = 0
     };
-    NH_GFX_CHECK_VULKAN(Host_p->Functions.vkCreateDevice(Driver_p->PhysicalDevice, &DeviceInfo, VK_NULL_HANDLE, &Driver_p->Device))
+    NH_GFX_CHECK_VULKAN(
+        Host_p->Functions.vkCreateDevice(Driver_p->PhysicalDevice, &DeviceInfo, VK_NULL_HANDLE, &Driver_p->Device))
 
     volkLoadDeviceTable(&Driver_p->Functions, Driver_p->Device);
     NH_GFX_CHECK(nh_vk_validateFunctions(Driver_p))
@@ -568,10 +571,12 @@ NH_GFX_BEGIN();
 
 #include NH_GFX_CUSTOM_CHECK
 
-    VkQueueFamilyProperties *QueueFamilyProperties_p = nh_allocate(sizeof(VkQueueFamilyProperties) * queueFamilyCount);
+    VkQueueFamilyProperties *QueueFamilyProperties_p = 
+        nh_allocate(sizeof(VkQueueFamilyProperties) * queueFamilyCount);
     NH_GFX_CHECK_NULL(-1, QueueFamilyProperties_p)
 
-    Host_p->Functions.vkGetPhysicalDeviceQueueFamilyProperties(*Physical_p, &queueFamilyCount, QueueFamilyProperties_p);
+    Host_p->Functions.vkGetPhysicalDeviceQueueFamilyProperties(
+        *Physical_p, &queueFamilyCount, QueueFamilyProperties_p);
 
     for (uint32_t i = 0; i &lt queueFamilyCount; ++i) 
     {
diff --git a/src/lib/nhgfx/Vulkan/Host.h b/src/lib/nhgfx/Vulkan/Host.h
index 9e80601..1041fcb 100644
--- a/src/lib/nhgfx/Vulkan/Host.h
+++ b/src/lib/nhgfx/Vulkan/Host.h
@@ -9,6 +9,7 @@
  * Published under MIT
  */
 
+#define NETZHAUT_VULKAN
 #include "../Common/Types/Private.h"
 
 #endif
diff --git a/src/lib/nhgfx/Vulkan/Render.c b/src/lib/nhgfx/Vulkan/Render.c
index a9d5995..32d830c 100644
--- a/src/lib/nhgfx/Vulkan/Render.c
+++ b/src/lib/nhgfx/Vulkan/Render.c
@@ -103,41 +103,23 @@ NH_GFX_DIAGNOSTIC_END(NH_GFX_SUCCESS)
 }
 
 NH_GFX_RESULT nh_vk_render( // TODO multi GPU rendering
-    nh_gfx_Surface *Surface_p)
+    nh_gfx_Surface *Surface_p, nh_List *SortedViewports_p)
 {
 NH_GFX_BEGIN()
 
     VkSemaphore *Semaphores_pp[2] = {&Surface_p->Vulkan.Sync.Semaphore_p[0], &Surface_p->Vulkan.Sync.Semaphore_p[1]};
 
-    nh_List Render = nh_initList(8);
-    
-    // find out which commandbuffers to render
-    for (int i = 0; i &lt Surface_p->Viewports.size; ++i) {
-        if (((nh_gfx_Viewport*)Surface_p->Viewports.pp[i])->Sync.render) {
-            nh_appendToList(&Render, Surface_p->Viewports.pp[i]);
-        }
-    }
-
-    VkCommandBuffer *Commands_p = nh_allocate(sizeof(void*) * Render.size);
+    VkCommandBuffer *Commands_p = nh_allocate(sizeof(void*)*(SortedViewports_p->size+1));
     NH_GFX_CHECK_MEM(Commands_p)
 
-    VkCommandBuffer *SortedCommands_p = nh_allocate(sizeof(void*) * (Render.size + 1));
-    NH_GFX_CHECK_MEM(SortedCommands_p)
-
-    int *sortedIndices_p = nh_allocate(sizeof(int) * Render.size);
-    NH_GFX_CHECK_MEM(sortedIndices_p)
-
-    NH_BOOL *onTop_p = nh_allocate(sizeof(NH_BOOL) * Render.size);
-    NH_GFX_CHECK_MEM(onTop_p)
-
     // insert clear commandbuffer
     NH_GFX_CHECK(nh_vk_clearSurface(Surface_p, &Surface_p->Vulkan.GPU_p->Driver))
-    SortedCommands_p[0] = Surface_p->Vulkan.CommandBuffers_p[Surface_p->Vulkan.currentImage];
+    Commands_p[0] = Surface_p->Vulkan.CommandBuffers_p[Surface_p->Vulkan.currentImage];
 
-    // get commandbuffers
-    for (int i = 0; i &lt Render.size; ++i) 
+    // get viewport commandbuffers
+    for (int i = 0; i &lt SortedViewports_p->size; ++i) 
     {
-        nh_gfx_Viewport *Viewport_p = Render.pp[i];
+        nh_gfx_Viewport *Viewport_p = SortedViewports_p->pp[i];
         Viewport_p->Sync.submittedBuffers_p[Surface_p->Vulkan.currentImage]
             = Viewport_p->Sync.newestBuffers_p[Surface_p->Vulkan.currentImage];
 
@@ -150,33 +132,6 @@ NH_GFX_BEGIN()
         ];
     }
 
-    // sort commandbuffers based on tab priority (from low to high priority)
-    int max = 0;
-    for (int i = 0; i &lt Render.size; ++i) {
-        nh_gfx_Viewport *Viewport_p = Render.pp[i];
-        if (Viewport_p->Settings.priority > max) {max = Viewport_p->Settings.priority;}
-    }
-    
-    for (int i = 0; i &lt Render.size; ++i) 
-    {
-        int diff = max, newMax = -1;
-        for (int j = 0; j &lt Render.size; ++j) 
-        {
-            nh_gfx_Viewport *Viewport_p = Render.pp[j];
-            if ((Viewport_p->Settings.priority - max) == 0) {sortedIndices_p[i] = j;}
-            else if ((max - Viewport_p->Settings.priority) &lt= diff) {
-                diff = max - Viewport_p->Settings.priority; 
-                newMax = Viewport_p->Settings.priority;
-            }
-        }
-        max = newMax;
-    }
-
-    int count = 1;
-    for (int i = 0; i &lt Render.size; ++i) {
-        SortedCommands_p[count++] = Commands_p[sortedIndices_p[i]];
-    }
-
     // submit graphics
     VkPipelineStageFlags waitStages[] = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT};
     VkSubmitInfo submitInfo = 
@@ -187,8 +142,8 @@ NH_GFX_BEGIN()
         .pWaitSemaphores      = Semaphores_pp[0], 
         .pWaitDstStageMask    = waitStages,
         .pSignalSemaphores    = VK_NULL_HANDLE,
-        .commandBufferCount   = count,
-        .pCommandBuffers      = SortedCommands_p,
+        .commandBufferCount   = SortedViewports_p->size+1,
+        .pCommandBuffers      = Commands_p,
     };
 
     nh_vk_GPU *GPU_p = Surface_p->Vulkan.GPU_p;
@@ -211,10 +166,6 @@ NH_GFX_BEGIN()
     NH_GFX_CHECK_VULKAN(GPU_p->Driver.Functions.vkQueuePresentKHR(GPU_p->Driver.GraphicsQueue, &presentInfo))
 
     nh_free(Commands_p); 
-    nh_free(SortedCommands_p); 
-    nh_free(onTop_p); 
-    nh_free(sortedIndices_p);
-    nh_freeList(&Render, NH_FALSE);
 
 NH_GFX_DIAGNOSTIC_END(NH_GFX_SUCCESS)
 }
diff --git a/src/lib/nhgfx/Vulkan/Render.h b/src/lib/nhgfx/Vulkan/Render.h
index 7bdf1cc..81a1bde 100644
--- a/src/lib/nhgfx/Vulkan/Render.h
+++ b/src/lib/nhgfx/Vulkan/Render.h
@@ -25,7 +25,7 @@
     );
 
     NH_GFX_RESULT nh_vk_render(
-        nh_gfx_Surface *Surface_p
+        nh_gfx_Surface *Surface_p, nh_List *SortedViewports_p
     );
 
 /** @} */
diff --git a/src/lib/nhterminal/OpenGL/Render.c b/src/lib/nhterminal/OpenGL/Render.c
index d131488..2e254f6 100644
--- a/src/lib/nhterminal/OpenGL/Render.c
+++ b/src/lib/nhterminal/OpenGL/Render.c
@@ -9,50 +9,29 @@
 // INCLUDE =========================================================================================
 
 #include "Render.h"
-#include "Text.h"
-#include "Pipeline.h"
+//#include "Text.h"
+//#include "Pipeline.h"
 
 #include "../Common/Macros/Macros.h"
 #include NH_TERMINAL_FLOW
 #include NH_TERMINAL_DEFAULT_CHECK
 
 #include "../../nhgfx/Base/Viewport.h"
-#include "../../nhgfx/Vulkan/GPU.h"
+//#include "../../nhgfx/Vulkan/GPU.h"
 
 #include &ltstdlib.h>
 #include &ltstring.h>
 
 // TEXT ============================================================================================
 
-static void nh_terminal_recordText(
-    nh_terminal_VulkanText *Text_p, nh_vk_GPU *GPU_p, VkCommandBuffer *CommandBuffer_p, int indices)
+static void nh_terminal_renderText(
+    nh_terminal_OpenGLText *Text_p, nh_opengl_CommandBuffer *CommandBuffer_p)
 {
 NH_TERMINAL_BEGIN()
 
-    GPU_p->Driver.Functions.vkCmdBindPipeline(
-        *CommandBuffer_p, VK_PIPELINE_BIND_POINT_GRAPHICS, 
-        GPU_p->Term.Pipelines_p[NH_TERMINAL_VULKAN_PIPELINE_SDF].Pipeline
-    );
-    VkDeviceSize size_p[1] = {0};
-
-    GPU_p->Driver.Functions.vkCmdBindVertexBuffers(
-        *CommandBuffer_p, 0, 1, &Text_p->VertexBuffer.Buffer, size_p
-    );
-    
-    GPU_p->Driver.Functions.vkCmdBindDescriptorSets(
-        *CommandBuffer_p, VK_PIPELINE_BIND_POINT_GRAPHICS, 
-        GPU_p->Term.Pipelines_p[NH_TERMINAL_VULKAN_PIPELINE_SDF].PipelineLayout, 
-        0, 1, &Text_p->DescriptorSet.DescriptorSet, 0, VK_NULL_HANDLE
-    );
-
-    GPU_p->Driver.Functions.vkCmdBindIndexBuffer(
-        *CommandBuffer_p, Text_p->IndexBuffer.Buffer, 0, VK_INDEX_TYPE_UINT32
-    );
-
-    GPU_p->Driver.Functions.vkCmdDrawIndexed(
-        *CommandBuffer_p, indices, 1, 0, 0, 0
-    );
-
+    nh_opengl_addCommand(CommandBuffer_p, "glUseProgram", &Text_p->Program_p->Result);
+    nh_opengl_addCommand(CommandBuffer_p, "glDrawArrays", nh_opengl_glenum(NULL, GL_TRIANGLES), nh_opengl_glint(NULL, 0), nh_opengl_glsizei(NULL, 3));
+ 
 NH_TERMINAL_SILENT_END()
 }
 
@@ -67,20 +46,19 @@ NH_TERMINAL_BEGIN()
         Graphics_p->Fonts.pp[Graphics_p->font], Graphics_p->fontSize
     );
 
-    NH_TERMINAL_CHECK(nh_terminal_updateVulkanText(
-        Graphics_p->Viewport_p->Surface_p->Vulkan.GPU_p, FontInstance_p, &Graphics_p->Vulkan.Text, 
-        &Graphics_p->TextVertices, &Graphics_p->TextIndices
-    ))
-
     nh_gfx_beginRecording(Graphics_p->Viewport_p);
 
-    for (int i = 0; i &lt Graphics_p->Viewport_p->Vulkan.images; ++i) {
-        nh_terminal_recordText(
-            &Graphics_p->Vulkan.Text, Graphics_p->Viewport_p->Surface_p->Vulkan.GPU_p, 
-            Graphics_p->Viewport_p->Vulkan.CommandBuffers_pp[i], Graphics_p->TextIndices.length 
-        );
+    if (Graphics_p->OpenGL.init) {
+        nh_opengl_appendCommandBuffer(Graphics_p->Viewport_p->OpenGL.CommandBuffer_p, &Graphics_p->OpenGL.Text.CommandBuffer);
+        Graphics_p->OpenGL.init = NH_FALSE;
     }
 
+    NH_TERMINAL_CHECK(nh_terminal_updateOpenGLText(
+        FontInstance_p, Graphics_p->Viewport_p->OpenGL.CommandBuffer_p, &Graphics_p->TextVertices, &Graphics_p->TextIndices
+    ))
+
+    nh_terminal_renderText(&Graphics_p->OpenGL.Text, Graphics_p->Viewport_p->OpenGL.CommandBuffer_p);
+
     nh_gfx_endRecording(Graphics_p->Viewport_p);
 
 NH_TERMINAL_END(NH_TERMINAL_SUCCESS)
diff --git a/src/lib/nhterminal/OpenGL/Text.c b/src/lib/nhterminal/OpenGL/Text.c
new file mode 100644
index 0000000..d90020e
--- /dev/null
+++ b/src/lib/nhterminal/OpenGL/Text.c
@@ -0,0 +1,147 @@
+// LICENSE NOTICE ==================================================================================
+
+/**
+ * netzhaut - Web Browser Engine
+ * Copyright (C) 2020 The netzhaut Authors
+ * Published under MIT
+ */
+
+// INCLUDE ========================================================================================
+
+#include "Text.h"
+
+#include "../Common/Macros/Macros.h"
+#include NH_TERMINAL_FLOW
+#include NH_TERMINAL_DEFAULT_CHECK
+
+//#include "../../nhcore/Util/Array.h"
+//#include "../../nhgfx/Vulkan/Texture.h"
+#include "../../nhgfx/Common/Macros/Macros.h"
+#include NH_GFX_FLOW
+#include NH_GFX_CUSTOM_CHECK
+
+#include &ltstdlib.h>
+#include &ltunistd.h>
+#include &lttime.h>
+#include &ltstdio.h>
+#include &ltstring.h>
+#include &ltinttypes.h>
+#include &ltlimits.h>
+#include &ltfloat.h>
+
+// INIT ============================================================================================
+
+NH_TERMINAL_RESULT nh_terminal_initOpenGLText(
+    nh_terminal_OpenGLText *Text_p)
+{
+NH_TERMINAL_BEGIN()
+
+    Text_p->CommandBuffer = nh_opengl_initCommandBuffer();
+
+    static const char* vsSource_p =
+    "#version 450\n"
+    "layout(location=0) in vec4 position;\n"
+    "layout(location=1) in vec3 color;\n"
+    "out vec3 vColor;\n"
+    "void main() {\n"
+    "    vColor = color;\n"
+    "    gl_Position = position;\n"
+    "}\n";
+
+    static const char* fsSource_p =
+    "#version 450\n"
+    "in vec3 vColor;\n"
+    "out vec4 fragColor;\n"
+    "void main() {\n"
+    "    fragColor = vec4(vColor, 1.0);\n"
+    "}\n";
+
+//    const uint32_t vs_code[] =
+//    {
+//        #include "../Common/Data/GLSL/TextSDF.vert"
+//    };
+//    const uint32_t fs_code[] =
+//    {
+//        #include "../Common/Data/GLSL/TextSDF.frag"
+//    };
+
+    nh_opengl_Command *VertexShader_p = 
+        nh_opengl_addCommand(&Text_p->CommandBuffer, "glCreateShader", nh_opengl_glint(NULL, GL_VERTEX_SHADER));
+    nh_opengl_addCommand(&Text_p->CommandBuffer, "glShaderSource", 
+        &VertexShader_p->Result, nh_opengl_gluint(NULL, 1), nh_opengl_glchar(NULL, NULL, 0, &vsSource_p), 
+        nh_opengl_null(NULL, NH_GFX_OPENGL_DATA_GLINT));
+
+    nh_opengl_addCommand(&Text_p->CommandBuffer, "glCompileShader", &VertexShader_p->Result);
+
+    nh_opengl_Command *FragmentShader_p = 
+        nh_opengl_addCommand(&Text_p->CommandBuffer, "glCreateShader", nh_opengl_glint(NULL, GL_FRAGMENT_SHADER));
+    nh_opengl_addCommand(&Text_p->CommandBuffer, "glShaderSource", 
+        &FragmentShader_p->Result, nh_opengl_gluint(NULL, 1), nh_opengl_glchar(NULL, NULL, 0, &fsSource_p), 
+        nh_opengl_null(NULL, NH_GFX_OPENGL_DATA_GLINT));
+
+    nh_opengl_addCommand(&Text_p->CommandBuffer, "glCompileShader", &FragmentShader_p->Result);
+
+    nh_opengl_Command *Program_p = nh_opengl_addCommand(&Text_p->CommandBuffer, "glCreateProgram");
+    nh_opengl_addCommand(&Text_p->CommandBuffer, "glAttachShader", &Program_p->Result, &VertexShader_p->Result);
+    nh_opengl_addCommand(&Text_p->CommandBuffer, "glAttachShader", &Program_p->Result, &FragmentShader_p->Result);
+    nh_opengl_addCommand(&Text_p->CommandBuffer, "glLinkProgram", &Program_p->Result);
+
+    Text_p->Program_p = Program_p;
+
+NH_TERMINAL_DIAGNOSTIC_END(NH_TERMINAL_SUCCESS)
+}
+
+NH_TERMINAL_RESULT nh_terminal_updateOpenGLText(
+    nh_gfx_FontInstance *FontInstance_p, nh_opengl_CommandBuffer *CommandBuffer_p, nh_Array *Vertices_p, nh_Array *Indices_p)
+{
+NH_TERMINAL_BEGIN()
+
+    nh_opengl_Data *VertexArray_p = nh_opengl_gluint(NULL, 0);
+    nh_opengl_addCommand(CommandBuffer_p, "glGenVertexArrays", nh_opengl_gluint(NULL, 1), VertexArray_p);
+    nh_opengl_addCommand(CommandBuffer_p, "glBindVertexArray", VertexArray_p);
+
+    GLfloat positionData[] = {
+        -0.5, -0.5,
+        0.5, -0.5,
+        0.0, 0.5
+    };
+    
+    nh_opengl_Data *PositionData_p = nh_opengl_glubyte(NULL, positionData, 3*2*sizeof(GLfloat)); 
+    nh_opengl_Data *Positions_p = nh_opengl_gluint(NULL, 0);
+   
+     nh_opengl_addCommand(CommandBuffer_p, "glGenBuffers", nh_opengl_gluint(NULL, 1), Positions_p);
+     nh_opengl_addCommand(CommandBuffer_p, "glBindBuffer", nh_opengl_glenum(NULL, GL_ARRAY_BUFFER), Positions_p);
+
+     nh_opengl_addCommand(CommandBuffer_p, "glBufferData", 
+         nh_opengl_glenum(NULL, GL_ARRAY_BUFFER), nh_opengl_glsizeiptr(NULL, 3*2*sizeof(GLfloat)), PositionData_p,
+         nh_opengl_glenum(NULL, GL_STATIC_DRAW));
+     nh_opengl_addCommand(CommandBuffer_p, "glVertexAttribPointer", 
+         nh_opengl_gluint(NULL, 0), nh_opengl_gluint(NULL, 2), nh_opengl_glenum(NULL, GL_FLOAT), 
+         nh_opengl_glboolean(NULL, GL_FALSE), nh_opengl_glsizei(NULL, 0), nh_opengl_null(NULL, 0));
+
+     nh_opengl_addCommand(CommandBuffer_p, "glEnableVertexAttribArray", nh_opengl_gluint(NULL, 0));
+     
+     GLubyte colorData[] = {
+         255, 0, 0,
+         0, 255, 0,
+         0, 0, 255
+     };
+     
+     nh_opengl_Data *ColorData_p = nh_opengl_glubyte(NULL, colorData, 3*3*sizeof(GLubyte)); 
+     nh_opengl_Data *Colors_p = nh_opengl_gluint(NULL, 0);
+     
+     nh_opengl_addCommand(CommandBuffer_p, "glGenBuffers", nh_opengl_gluint(NULL, 1), Colors_p);
+     nh_opengl_addCommand(CommandBuffer_p, "glBindBuffer", nh_opengl_glenum(NULL, GL_ARRAY_BUFFER), Colors_p);
+
+     nh_opengl_addCommand(CommandBuffer_p, "glBufferData", 
+         nh_opengl_glenum(NULL, GL_ARRAY_BUFFER), nh_opengl_glsizeiptr(NULL, 3*3*sizeof(GLubyte)), 
+         ColorData_p, nh_opengl_glenum(NULL, GL_STATIC_DRAW));
+     nh_opengl_addCommand(CommandBuffer_p, "glVertexAttribPointer", 
+         nh_opengl_gluint(NULL, 1), nh_opengl_gluint(NULL, 3), nh_opengl_glenum(NULL, GL_UNSIGNED_BYTE), 
+         nh_opengl_glboolean(NULL, GL_TRUE), nh_opengl_glsizei(NULL, 0), nh_opengl_null(NULL, 0));
+
+     nh_opengl_addCommand(CommandBuffer_p, "glEnableVertexAttribArray", nh_opengl_gluint(NULL, 1));
+
+NH_TERMINAL_DIAGNOSTIC_END(NH_SUCCESS)
+}
+
diff --git a/src/lib/nhterminal/OpenGL/Text.h b/src/lib/nhterminal/OpenGL/Text.h
new file mode 100644
index 0000000..9f82649
--- /dev/null
+++ b/src/lib/nhterminal/OpenGL/Text.h
@@ -0,0 +1,48 @@
+#ifndef NH_TERMINAL_OPENGL_TEXT_H
+#define NH_TERMINAL_OPENGL_TEXT_H
+
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+
+/**
+ * netzhaut - Web Browser Engine
+ * Copyright (C) 2020 The netzhaut Authors
+ * Published under MIT
+ */
+
+#include "../Common/Types/Private.h"
+
+#include "../../nhgfx/OpenGL/CommandBuffer.h"
+#include "../../nhgfx/OpenGL/Commands.h"
+
+#include "../../nhgfx/Fonts/FontManager.h"
+
+#include &ltstdint.h>
+
+#endif
+
+/** @addtogroup lib_nhterminal_structs
+ *  @{
+ */
+
+    typedef struct nh_terminal_OpenGLText {
+        nh_opengl_CommandBuffer CommandBuffer;
+        nh_opengl_Command *Program_p;
+    } nh_terminal_OpenGLText;
+
+/** @} */
+
+/** @addtogroup lib_nhterminal_functions
+ *  @{
+ */
+
+    NH_TERMINAL_RESULT nh_terminal_initOpenGLText(
+        nh_terminal_OpenGLText *Text_p
+    );
+
+    NH_TERMINAL_RESULT nh_terminal_updateOpenGLText(
+        nh_gfx_FontInstance *FontInstance_p, nh_opengl_CommandBuffer *CommandBuffer_p, nh_Array *Vertices_p, nh_Array *Indices_p
+    );
+
+/** @} */
+
+#endif 
diff --git a/src/lib/nhterminal/Terminal/Graphics.c b/src/lib/nhterminal/Terminal/Graphics.c
index f5e8204..20ea783 100644
--- a/src/lib/nhterminal/Terminal/Graphics.c
+++ b/src/lib/nhterminal/Terminal/Graphics.c
@@ -11,6 +11,8 @@
 #include "Graphics.h"
 
 #include "../Vulkan/Render.h"
+#include "../OpenGL/Render.h"
+
 #include "../Common/Log.h"
 #include "../Common/Macros/Macros.h"
 #include NH_TERMINAL_DEFAULT_CHECK
@@ -59,11 +61,13 @@ NH_TERMINAL_BEGIN()
     Graphics_p->TextVertices = nh_initArray(sizeof(float), 1024);  
     Graphics_p->TextIndices  = nh_initArray(sizeof(uint32_t), 1024);
 
-    Graphics_p->Background.r = 0.01f;
-    Graphics_p->Background.g = 0.01f;
-    Graphics_p->Background.b = 0.01f;
+    Graphics_p->Background.r = 1.0f;
+    Graphics_p->Background.g = 1.0f;
+    Graphics_p->Background.b = 1.0f;
     Graphics_p->Background.a = 1.0f;
 
+    Graphics_p->OpenGL.init = NH_TRUE;
+
 NH_TERMINAL_END(NH_TERMINAL_SUCCESS)
 }
 
@@ -124,6 +128,9 @@ NH_TERMINAL_BEGIN()
             case NH_GFX_API_VULKAN :
                 nh_terminal_initVulkanText(Viewport_p->Surface_p->Vulkan.GPU_p, &Graphics_p->Vulkan.Text);
                 break;
+            case NH_GFX_API_OPENGL :
+                nh_terminal_initOpenGLText(&Graphics_p->OpenGL.Text);
+                break;
             default :
                 NH_TERMINAL_END(NH_TERMINAL_ERROR_BAD_STATE)
         }
@@ -147,6 +154,9 @@ NH_TERMINAL_BEGIN()
         case NH_GFX_API_VULKAN :
             NH_TERMINAL_CHECK(nh_terminal_renderUsingVulkan(Graphics_p))
             break;
+       case NH_GFX_API_OPENGL :
+            NH_TERMINAL_CHECK(nh_terminal_renderUsingOpenGL(Graphics_p))
+            break;
         default :
             NH_TERMINAL_END(NH_TERMINAL_ERROR_BAD_STATE)
     }
diff --git a/src/lib/nhterminal/Terminal/Graphics.h b/src/lib/nhterminal/Terminal/Graphics.h
index 8389115..2dc33be 100644
--- a/src/lib/nhterminal/Terminal/Graphics.h
+++ b/src/lib/nhterminal/Terminal/Graphics.h
@@ -11,6 +11,7 @@
 
 #include "Grid.h"
 #include "../Vulkan/Text.h"
+#include "../OpenGL/Text.h"
 
 #endif
 
@@ -18,13 +19,19 @@
  *  @{
  */
 
-    typedef struct nh_terminal_VulkanGraphics {
+    typedef struct nh_terminal_Vulkan {
         nh_terminal_VulkanText Text;
-    } nh_terminal_VulkanGraphics;
+    } nh_terminal_Vulkan;
+
+    typedef struct nh_terminal_OpenGL {
+        NH_BOOL init;
+        nh_terminal_OpenGLText Text;
+    } nh_terminal_OpenGL;
 
     typedef struct nh_terminal_Graphics {
         nh_gfx_Viewport *Viewport_p;
-        nh_terminal_VulkanGraphics Vulkan;
+        nh_terminal_Vulkan Vulkan;
+        nh_terminal_OpenGL OpenGL;
         nh_Array TextVertices;
         nh_Array TextIndices;
         nh_List Fonts;
diff --git a/src/lib/nhterminal/Terminal/Terminal.c b/src/lib/nhterminal/Terminal/Terminal.c
index 1510a73..19811ed 100644
--- a/src/lib/nhterminal/Terminal/Terminal.c
+++ b/src/lib/nhterminal/Terminal/Terminal.c
@@ -94,8 +94,6 @@ NH_TERMINAL_BEGIN()
         Terminal_p->Grid.cols = Terminal_p->Grid.Size.width / nh_gfx_getTextWidth(&Text);
         Terminal_p->Grid.rows = Terminal_p->Grid.Size.height / 10;
 
-//printf("%d cols %d twidth\n", Terminal_p->Grid.cols, nh_gfx_getTextWidth(&Text));
-//exit(0);
         Terminal_p->View_p->cols = Terminal_p->Grid.cols;
         Terminal_p->View_p->rows = Terminal_p->Grid.rows;
 
diff --git a/src/lib/nhwsi/Main/Window.h b/src/lib/nhwsi/Main/Window.h
index 61e3ac4..c59982f 100644
--- a/src/lib/nhwsi/Main/Window.h
+++ b/src/lib/nhwsi/Main/Window.h
@@ -72,6 +72,10 @@
         nh_wsi_Window *Window_p, NH_WSI_MOUSE_CURSOR type
     );
 
+    NH_WSI_RESULT nh_wsi_opengl_makeCurrent(
+    
+    );
+
 /** @} */
 
 #endif 
diff --git a/src/lib/nhwsi/Platforms/X11.c b/src/lib/nhwsi/Platforms/X11.c
index 974ae71..d38187a 100644
--- a/src/lib/nhwsi/Platforms/X11.c
+++ b/src/lib/nhwsi/Platforms/X11.c
@@ -314,12 +314,14 @@ NH_WSI_BEGIN()
     Attributes.background_pixel = 0xff000000; // ARGB
     Attributes.colormap = XCreateColormap(Display_p, DefaultRootWindow(Display_p), vinfo.visual, AllocNone);
 
-    Window_p->XWindow = XCreateWindow(
-        Display_p, DefaultRootWindow(Display_p), 0, 0, width, height, 0,
-        vinfo.depth, InputOutput, vinfo.visual, CWEventMask | CWBackPixel | CWBorderPixel | CWColormap, 
-        &Attributes
-    );
+//    Window_p->XWindow = XCreateWindow(
+//        Display_p, DefaultRootWindow(Display_p), 0, 0, width, height, 0,
+//        vinfo.depth, InputOutput, vinfo.visual, CWEventMask | CWBackPixel | CWBorderPixel | CWColormap, 
+//        &Attributes
+//    );
     
+    Window_p->XWindow = XCreateSimpleWindow(Display_p, DefaultRootWindow(Display_p), 0, 0, width, height, 0, 0, 0);
+
     XMapWindow(Display_p, Window_p->XWindow);
     
 // window delete protocol
-- 
2.35.1


</pre>
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
  <!-- HTML footer for doxygen 1.8.15-->
  <!-- start footer part -->
  <div id="nav-path" class="navpath">
    <!--  -->
    <!-- <li class="footer">Generated by -->
    <!-- <a href="http://www.doxygen.org/index.html"> -->
    <!-- <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li> -->
    <div id="foot"> 
        <a href="https://github.com/netzdevs/netzhaut"><div id="footelem">Open Code Repository</div></a>
        <a href="https://github.com/netzdevs/netzhaut.dev"><div id="footelem">Open Docs Repository</div></a>
        <a href="mailto:contact@netzhaut.dev"><div id="footelem">Send EMail</div></a>
    </div>
</html>
